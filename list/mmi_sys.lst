C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MMI_SYS
OBJECT MODULE PLACED IN .\output\mmi_sys.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE mmi_src\mmi_sys.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;.
                    -\Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd_rf
                    -id;.\mmi_inc) DEBUG PRINT(.\list\mmi_sys.lst) TABS(2) OBJECT(.\output\mmi_sys.obj)

line level    source

   1          #ifndef __MMI_SYS_C__
   2          #define __MMI_SYS_C__
   3          
   4          #include "mmi_feature.h"
   5          #include "mmi_sys.h"
   6          #include "mmi_audio.h"
   7          #include "mmi_rst.h"
   8          #include "mmi_queue.h"
   9          #include "dqiot_drv.h"
  10          #include "mmi_ms.h"
  11          #include "mmi_fs.h"
  12          #include "mmi_bsp.h"
  13          #include "mmi_motor.h"
  14          #include "mmi_wifi.h"
  15          #include "mmi_decode.h"
  16          #include <stdio.h>
  17          #include "mmi_rtc.h"
  18          
  19          #ifdef __LOCK_VIRTUAL_PASSWORD__
  20          #include "mmi_rtc.h"
  21          #define MMI_MAX_ERROR_TIMES 5
  22          #define MMI_ERROR_LOCK_TIME 60
  23          // #define MMI_TIMER_BASE_TIME 4
  24          #define MMI_TIMER_ENTER_SLEEP 10000
  25          #define MMI_TIMER_ENTER_SLEEP_COUNT (MMI_TIMER_ENTER_SLEEP / MMI_TIMER_BASE_TIME)
  26          #define MMI_TIMER_ENTER_SLEEP_DELAY 20000
  27          #define MMI_TIMER_ENTER_SLEEP_DELAY_COUNT (MMI_TIMER_ENTER_SLEEP_DELAY / MMI_TIMER_BASE_TIME)
  28          static uint32_t g_last_error_time = 0;
  29          static unsigned char g_multiple_error_times = 0;
  30          static uint8_t lock_easy_open_mode = 0;
  31          static uint8_t lock_inside_lock = 0;
  32          //static unsigned int g_enter_sleep_set_time = MMI_TIMER_ENTER_SLEEP_COUNT;
  33          #endif //__LOCK_VIRTUAL_PASSWORD__
  34          
  35          // extern void printfS(char *show, char *status);
  36          // extern void printfV(char *show, int value);
  37          
  38          static unsigned char g_sys_door_open_flag = 0;
  39          
  40          static unsigned int g_timer2_sleep_count = 0;
  41          static unsigned int g_timer2_count = 0;
  42          static unsigned int g_timer2_set_count = 0;
  43          static unsigned char g_timer2_flag = 0;
  44          
  45          static unsigned char g_wifi_check_flag = 0;
  46          static unsigned char g_wifi_check_count = 0;
  47          static unsigned char g_wifi_check_type = 0;
  48          
  49          /* clock */
  50          static unsigned char g_clock_flag = 0;
  51          
  52          /* RFID */
  53          static unsigned char g_rfid_flag = 0;
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 2   

  54          
  55          #define LOCK_MAX_EEROR_TIMES 5
  56          static unsigned char g_lock_error_flag = 0;
  57          static unsigned int g_lock_error_count = 0;
  58          
  59          timer2_delay_pro g_timer2_delay_pro = 0;
  60          
  61          #define MMI_TIMER_BASE_TIME 100
  62          #define MMI_TIMER_ENTER_SLEEP 10000
  63          #define MMI_TIMER_ENTER_SLEEP_COUNT (MMI_TIMER_ENTER_SLEEP / MMI_TIMER_BASE_TIME)
  64          #define MMI_TIMER_ENTER_SLEEP_DELAY 20000
  65          #define MMI_TIMER_ENTER_SLEEP_DEALY_COUNT (MMI_TIMER_ENTER_SLEEP_DELAY / MMI_TIMER_BASE_TIME)
  66          #define MMI_TIMER_DOOR_OPEN 6000
  67          #define MMI_TIMER_DOOR_OPEN_COUNT (MMI_TIMER_DOOR_OPEN / MMI_TIMER_BASE_TIME)
  68          #define MMI_TIMER_MOTOR 300
  69          #define MMI_TIMER_MOTOR_COUNT (MMI_TIMER_MOTOR / MMI_TIMER_BASE_TIME)
  70          #define MMI_TIMER_WIFI_CHECK 1000
  71          #define MMI_TIMER_WIFI_CHECK_COUNT (MMI_TIMER_WIFI_CHECK / MMI_TIMER_BASE_TIME)
  72          #define MMI_WIFI_SETTING_DELAY 60000
  73          #define MMI_WIFI_SETTING_DELAY_COUNT (MMI_WIFI_SETTING_DELAY / MMI_TIMER_BASE_TIME)
  74          #define MMI_LOCK_ERROR_DELAY 60000
  75          #define MMI_LOCK_ERROR_DELAY_COUNT (MMI_LOCK_ERROR_DELAY / MMI_TIMER_BASE_TIME)
  76          /*
  77          parameter: 
  78            none
  79          return :
  80            none
  81          */
  82          void mmi_dq_sys_init(void)
  83          {
  84   1        mmi_InitQueue();
  85   1        mmi_ms_pwd_init_var();
  86   1        mmi_dq_fs_init();
  87   1      }
  88          /*
  89          parameter: 
  90            none
  91          return :
  92            none
  93          */
  94          // #ifndef __LOCK_VIRTUAL_PASSWORD__
  95          void mmi_dq_sys_show_message_with_id(unsigned char text_id, unsigned long time_msec)
  96          {
  97   1        unsigned char audio_id = 0;
  98   1      
  99   1        time_msec = 0;
 100   1      
 101   1      #ifdef __LOCK_AUDIO_SUPPORT__
 102   1        audio_id = mmi_dq_aud_get_audio_id(text_id);
 103   1        mmi_dq_aud_play_with_id(audio_id);
 104   1      #endif
 105   1        return;
 106   1      }
 107          // #endif
 108          
 109          /*
 110          parameter: 
 111            none
 112          return :
 113            none
 114          */
 115          void mmi_dq_sys_lock_add_admin_suc(void)
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 3   

 116          {
 117   1        mmi_dq_fs_set_admin_status(1);
 118   1      
 119   1        mmi_dq_ms_set_sys_state(SYS_STATUS_IDLE);
 120   1      }
 121          
 122          /*
 123          function: system enter sleep
 124          parameter: 
 125            none
 126          return :
 127            none
 128          */
 129          void mmi_dq_sys_enter_sleep(void)
 130          {
 131   1        mmi_dq_bsp_enter_sleep();
 132   1      
 133   1        g_timer2_flag = 0;
 134   1        g_sys_door_open_flag = 0;
 135   1      
 136   1        mmi_dq_ms_set_sys_state(SYS_STATUS_ENTER_SLEEP);
 137   1      }
 138          
 139          /*
 140          function: system wake up
 141          parameter: 
 142            none
 143          return :
 144            none
 145          */
 146          void mmi_dq_sys_wake_up(void)
 147          {
 148   1      
 149   1        mmi_dq_bsp_wake_up();
 150   1        if (mmi_dq_sys_check_vbat() == 0)
 151   1        {
 152   2      #ifdef __LOCK_WIFI_SUPPORT__
 153   2          mmi_dq_wifi_wakeup();
 154   2      #endif
 155   2      #ifdef __LOCK_FP_SUPPORT__
                  mmi_dq_fp_init(); //握手、点灯
              #endif
 158   2          mmi_dq_ms_set_sys_state(SYS_STATUS_IDLE);
 159   2        }
 160   1      }
 161          
 162          /*
 163          function: 
 164          parameter: 
 165            none
 166          return :
 167            none
 168          */
 169          void mmi_dq_sys_door_open_cb(void)
 170          {
 171   1      #ifdef __LOCK_MOTOR_SUPPORT__
 172   1        mmi_dq_motor_stop();
 173   1      #endif
 174   1      #ifdef __LOCK_AUDIO_SUPPORT__
 175   1        mmi_dq_aud_play_with_id(AUD_ID_DOOR_OPEN);
 176   1      #endif
 177   1        mmi_dq_sys_set_delay_event(MMI_TIMER_DOOR_OPEN_COUNT, mmi_dq_sys_door_close);
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 4   

 178   1      }
 179          
 180          /*
 181          function: 
 182          parameter: 
 183            none
 184          return :
 185            none
 186          */
 187          void mmi_dq_sys_door_open(sys_open_type type)
 188          {
 189   1      #ifdef __LOCK_BUS_SUPPORT__
 190   1        if ((mmi_dq_fs_get_business_flag() == 1) && ((type & SYS_OPEN_BY_110) == 0) && (SYS_OPEN_BY_WIFI != type)
             -)
 191   1        {
 192   2      #ifdef __LOCK_AUDIO_SUPPORT__
 193   2          mmi_dq_aud_play_with_id(AUD_ID_IS_BUSINESS);
 194   2      #endif
 195   2      #ifdef __LOCK_WIFI_SUPPORT__
 196   2          switch (type)
 197   2          {
 198   3          case SYS_OPEN_BY_PASSWORD:
 199   3            mmi_dq_wifi_pw_alarm();
 200   3            break;
 201   3          case SYS_OPEN_BY_FP:
 202   3            mmi_dq_wifi_fp_alarm();
 203   3            break;
 204   3          case SYS_OPEN_BY_RFID:
 205   3            mmi_dq_wifi_rfid_alarm();
 206   3            break;
 207   3          }
 208   2      #endif
 209   2          return;
 210   2        }
 211   1      #endif
 212   1        g_lock_error_flag = 0;
 213   1        if ((mmi_dq_fs_get_open_mode() == SYS_OPEN_MODE_DBL) && (SYS_OPEN_BY_WIFI != type) && ((type & SYS_OPEN_B
             -Y_110) == 0))
 214   1        {
 215   2          if ((g_sys_door_open_flag & (~type)) != 0)
 216   2          {
 217   3            g_sys_door_open_flag = 0;
 218   3          }
 219   2          else
 220   2          {
 221   3            g_sys_door_open_flag |= type;
 222   3      #ifdef __LOCK_AUDIO_SUPPORT__
 223   3            mmi_dq_aud_play_with_id(AUD_ID_SYS_DBL_OPEN_MODE);
 224   3      #endif
 225   3            return;
 226   3          }
 227   2        }
 228   1      
 229   1        mmi_dq_ms_set_sys_state(SYS_STATUS_DOOR_OPEN);
 230   1      
 231   1      #ifdef __LOCK_MOTOR_SUPPORT__
 232   1        mmi_dq_motor_turn_right();
 233   1      #endif
 234   1        //mmi_dq_wifi_open_door();
 235   1        mmi_dq_sys_set_delay_event(MMI_TIMER_MOTOR_COUNT, mmi_dq_sys_door_open_cb);
 236   1      
 237   1      #ifdef __LOCK_WIFI_SUPPORT__
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 5   

 238   1        switch (type)
 239   1        {
 240   2      #ifdef __LOCK_110_SUPPORT__
 241   2        case SYS_OPEN_BY_110_PASSWORD:
 242   2          mmi_dq_wifi_send_pwd_110(get_index);
 243   2          // printfV("get_index",(int)get_index);
 244   2          break;
 245   2        case SYS_OPEN_BY_110_FP:
 246   2          mmi_dq_wifi_send_fp_110(get_index);
 247   2          // printfV("get_index",(int)get_index);
 248   2          break;
 249   2      #endif
 250   2        case SYS_OPEN_BY_PASSWORD:
 251   2          mmi_dq_wifi_open_by_password(get_index);
 252   2          // printfV("get_index",(int)get_index);
 253   2          break;
 254   2      #ifdef __LOCK_FP_SUPPORT__
                case SYS_OPEN_BY_FP:
                  mmi_dq_wifi_open_by_fp(get_index);
                  // printfV("get_index",(int)get_index);
                  break;
              #endif
 260   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 261   2        case SYS_OPEN_BY_RFID:
 262   2          mmi_dq_wifi_open_by_rfid(get_index);
 263   2          // printfV("get_index",(int)get_index);
 264   2          break;
 265   2      #endif
 266   2        case SYS_OPEN_BY_WIFI:
 267   2          mmi_dq_wifi_open_by_wifi();
 268   2          break;
 269   2        }
 270   1      
 271   1        if (pv_add_switch == 0)
 272   1          ;
 273   1        else if (pv_add_switch == 1)
 274   1          mmi_dq_wifi_take_photos(); //拍照
 275   1        else if (pv_add_switch == 2)
 276   1          mmi_dq_wifi_take_videos(); //录像
 277   1        else if (pv_add_switch == 3)
 278   1        {
 279   2          mmi_dq_wifi_take_photos(); //拍照
 280   2          mmi_dq_wifi_take_videos(); //录像
 281   2        }
 282   1      
 283   1      #endif
 284   1      }
 285          
 286          /*
 287          function: 
 288          parameter: 
 289            none
 290          return :
 291            none
 292          */
 293          void mmi_dq_sys_door_open_fail(sys_open_type type)
 294          {
 295   1        g_lock_error_count = 0;
 296   1        g_lock_error_flag++;
 297   1        switch (type)
 298   1        {
 299   2        case SYS_OPEN_BY_PASSWORD:
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 6   

 300   2      #ifdef __LOCK_AUDIO_SUPPORT__
 301   2          mmi_dq_aud_play_with_id(AUD_ID_PWD_WRONG_TRY);
 302   2      #endif
 303   2      #ifdef __LOCK_WIFI_SUPPORT__
 304   2          if (g_lock_error_flag >= LOCK_MAX_EEROR_TIMES)
 305   2            mmi_dq_wifi_pw_alarm();
 306   2      #endif
 307   2          break;
 308   2      #ifdef __LOCK_FP_SUPPORT__
                case SYS_OPEN_BY_FP:
              #ifdef __LOCK_AUDIO_SUPPORT__
                  mmi_dq_aud_play_with_id(AUD_ID_FP_WRONG_TRY);
              #endif
              #ifdef __LOCK_WIFI_SUPPORT__
                  if (g_lock_error_flag >= LOCK_MAX_EEROR_TIMES)
                    mmi_dq_wifi_fp_alarm();
              #endif
                  break;
              #endif
 319   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 320   2        case SYS_OPEN_BY_RFID:
 321   2      #ifdef __LOCK_AUDIO_SUPPORT__
 322   2          mmi_dq_aud_play_with_id(AUD_ID_RFCARD_WRONG_TRY);
 323   2      #endif
 324   2      #ifdef __LOCK_WIFI_SUPPORT__
 325   2          if (g_lock_error_flag >= LOCK_MAX_EEROR_TIMES)
 326   2            mmi_dq_wifi_rfid_alarm();
 327   2      #endif
 328   2          break;
 329   2      #endif
 330   2        }
 331   1      }
 332          
 333          /*
 334          function: 
 335          parameter: 
 336            none
 337          return :
 338            none
 339          */
 340          unsigned char mmi_dq_sys_door_state_check(void)
 341          {
 342   1        if (g_lock_error_flag >= LOCK_MAX_EEROR_TIMES)
 343   1          return 1;
 344   1        return 0;
 345   1      }
 346          
 347          /*
 348          function: 
 349          parameter: 
 350            none
 351          return :
 352            none
 353          */
 354          void mmi_dq_sys_door_close_cb(void)
 355          {
 356   1      #ifdef __LOCK_MOTOR_SUPPORT__
 357   1        mmi_dq_motor_stop();
 358   1      #endif
 359   1      #ifdef __LOCK_AUDIO_SUPPORT__
 360   1        mmi_dq_aud_play_with_id(AUD_ID_DOOR_CLOSE);
 361   1      #endif
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 7   

 362   1        mmi_dq_ms_set_sys_state(SYS_STATUS_WAIT_FOR_ENTER_SLEEP);
 363   1      }
 364          
 365          /*
 366          function: 
 367          parameter: 
 368            none
 369          return :
 370            none
 371          */
 372          void mmi_dq_sys_door_close(void)
 373          {
 374   1      #ifdef __LOCK_MOTOR_SUPPORT__
 375   1        mmi_dq_motor_turn_back();
 376   1      #endif
 377   1        //mmi_dq_wifi_close_door();
 378   1        mmi_dq_sys_set_delay_event(MMI_TIMER_MOTOR_COUNT, mmi_dq_sys_door_close_cb);
 379   1      }
 380          
 381          /*
 382          function: 
 383          parameter: 
 384            none
 385          return :
 386            none
 387          */
 388          void mmi_dq_sys_aud_end(void)
 389          {
 390   1        mmi_dq_ms_set_msg_que(QUE_EVENT_AUDIO_END, QUE_PRO_LOW, 0);
 391   1      }
 392          
 393          /*
 394          function: 
 395          parameter: 
 396            none
 397          return :
 398            none
 399          */
 400          void mmi_dq_sys_time_out_handle(void)
 401          {
 402   1        SYS_BASE_STATUS state = mmi_dq_ms_get_sys_state();
 403   1      
 404   1        if ((state >= SYS_STATUS_ADD_PWD && state < SYS_STATUS_ADD_ADMIN_PWD) || (state == SYS_STATUS_SYS_MENU) |
             -| (state == SYS_STATUS_CHG_ADMIN_PWD))
 405   1        {
 406   2      #ifdef __LOCK_AUDIO_SUPPORT__
 407   2          mmi_dq_aud_play_with_id(AUD_ID_TIME_OUT);
 408   2      #endif
 409   2          mmi_dq_ms_set_sys_state(SYS_STATUS_WAIT_FOR_ENTER_SLEEP);
 410   2        }
 411   1      #ifdef __LOCK_FP_SUPPORT__
                else if (state == SYS_STATUS_ADD_ADMIN_FP1 || state == SYS_STATUS_ADD_ADMIN_FP2)
                {
                  if (mmi_dq_fs_get_admin_status() == 0)
                    g_timer2_sleep_count = 0;
                  else
                  {
              #ifdef __LOCK_AUDIO_SUPPORT__
                    mmi_dq_aud_play_with_id(AUD_ID_TIME_OUT);
              #endif
                    mmi_dq_ms_set_sys_state(SYS_STATUS_WAIT_FOR_ENTER_SLEEP);
                  }
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 8   

                }
              #endif
 425   1        else if (state == SYS_STATUS_ADD_ADMIN_PWD)
 426   1        {
 427   2          g_timer2_sleep_count = 0;
 428   2      #ifdef __LOCK_AUDIO_SUPPORT__
 429   2          mmi_dq_aud_play_with_id(AUD_ID_ADD_ADMIN_PWD_FIRST);
 430   2      #endif
 431   2        }
 432   1        else
 433   1          mmi_dq_ms_set_sys_state(SYS_STATUS_WAIT_FOR_ENTER_SLEEP);
 434   1      }
 435          
 436          /*
 437          function: 
 438          parameter: 
 439            none
 440          return :
 441            none
 442          */
 443          void System_timer_event_handler(void)
 444          {
 445   1        SYS_BASE_STATUS state = mmi_dq_ms_get_sys_state();
 446   1      
 447   1        g_rfid_flag = 1; /* RFID */
 448   1      
 449   1        /* clock */
 450   1        g_clock_flag++;
 451   1        if (g_clock_flag == 10)
 452   1        {
 453   2          g_clock_flag = 0;
 454   2          /* 秒 */
 455   2          if (t.tm_sec < 59)
 456   2            t.tm_sec++;
 457   2          else
 458   2          {
 459   3            t.tm_sec = 0;
 460   3            /* 分 */
 461   3            if (t.tm_min < 59)
 462   3              t.tm_min++;
 463   3            else
 464   3            {
 465   4              t.tm_min = 0;
 466   4              /* 时 */
 467   4              if (t.tm_hour < 23)
 468   4                t.tm_hour++;
 469   4              else
 470   4              {
 471   5                t.tm_hour = 0;
 472   5                /* 日 */
 473   5                if (t.tm_mon == 1 || t.tm_mon == 3 || t.tm_mon == 5 || t.tm_mon == 7 || t.tm_mon == 8 || t.tm_mon == 
             -10 || t.tm_mon == 12)
 474   5                {
 475   6                  if (t.tm_mday < 30)
 476   6                    t.tm_mday++;
 477   6                  else
 478   6                  {
 479   7                    t.tm_mday = 1;
 480   7                    /* 月 */
 481   7                    if (t.tm_mon < 11)
 482   7                      t.tm_mon++;
 483   7                    else
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 9   

 484   7                    {
 485   8                      t.tm_mon = 1;
 486   8                      t.tm_year++;
 487   8                    }
 488   7                  }
 489   6                }
 490   5                else if (t.tm_mon == 4 || t.tm_mon == 6 || t.tm_mon == 9 || t.tm_mon == 11)
 491   5                {
 492   6                  if (t.tm_mday < 29)
 493   6                    t.tm_mday++;
 494   6                  else
 495   6                  {
 496   7                    t.tm_mday = 1;
 497   7                    /* 月 */
 498   7                    if (t.tm_mon < 11)
 499   7                      t.tm_mon++;
 500   7                    else
 501   7                    {
 502   8                      t.tm_mon = 1;
 503   8                      t.tm_year++;
 504   8                    }
 505   7                  }
 506   6                }
 507   5                else if (t.tm_mon == 2)
 508   5                {
 509   6                  //判断闰年 1.能被4整除而不能被100整除。2.能被100整除也能被400整除。
 510   6                  if ((t.tm_year % 4 == 0 && t.tm_year % 100 > 0) || (t.tm_year % 100 == 0 && t.tm_year % 400 == 0))
 511   6                  {
 512   7                    if (t.tm_mday < 28)
 513   7                      t.tm_mday++;
 514   7                    else
 515   7                    {
 516   8                      t.tm_mday = 1;
 517   8                      /* 月 */
 518   8                      if (t.tm_mon < 11)
 519   8                        t.tm_mon++;
 520   8                      else
 521   8                      {
 522   9                        t.tm_mon = 1;
 523   9                        t.tm_year++;
 524   9                      }
 525   8                    }
 526   7                  }
 527   6                  else
 528   6                  {
 529   7                    if (t.tm_mday < 27)
 530   7                      t.tm_mday++;
 531   7                    else
 532   7                    {
 533   8                      t.tm_mday = 1;
 534   8                      /* 月 */
 535   8                      if (t.tm_mon < 11)
 536   8                        t.tm_mon++;
 537   8                      else
 538   8                      {
 539   9                        t.tm_mon = 1;
 540   9                        t.tm_year++;
 541   9                      }
 542   8                    }
 543   7                  }
 544   6                }
 545   5              }
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 10  

 546   4            }
 547   3          }
 548   2        }
 549   1      
 550   1        if (g_timer2_flag == 1)
 551   1        {
 552   2          g_timer2_count++;
 553   2          if (g_timer2_count >= g_timer2_set_count)
 554   2          {
 555   3            g_timer2_flag = 2;
 556   3            g_timer2_count = 0;
 557   3            //mmi_dq_ms_set_msg_que(QUE_EVENT_TIMER_END,QUE_PRO_LOW,0);
 558   3          }
 559   2        }
 560   1      
 561   1        if (g_wifi_check_flag == 1)
 562   1        {
 563   2          g_wifi_check_count++;
 564   2          if (g_wifi_check_count >= MMI_TIMER_WIFI_CHECK_COUNT)
 565   2          {
 566   3            g_wifi_check_flag = 2;
 567   3            g_wifi_check_count = 0;
 568   3          }
 569   2        }
 570   1      
 571   1        if (g_lock_error_flag > 0)
 572   1        {
 573   2          g_lock_error_count++;
 574   2          if (g_lock_error_count >= MMI_LOCK_ERROR_DELAY_COUNT)
 575   2            g_lock_error_flag = 0;
 576   2        }
 577   1      
 578   1        if ((mmi_dq_rst_timer_event() != 0) && (SYS_STATUS_ENTER_SLEEP != state && SYS_STATUS_WAIT_FOR_ENTER_SLEE
             -P != state) && (g_timer2_flag != 1) && (mmi_dq_ms_get_run_flag() == 0)
 579   1      #ifdef __LOCK_WIFI_SUPPORT__
 580   1          && (mmi_dq_wifi_get_running_flag() == 0)
 581   1      #endif
 582   1        )
 583   1        {
 584   2          unsigned char flag = 0;
 585   2          g_timer2_sleep_count++;
 586   2          if (state == SYS_STATUS_ADD_PWD || state == SYS_STATUS_DEL_PWD || state == SYS_STATUS_ADD_ADMIN_PWD
 587   2      #ifdef __LOCK_FP_SUPPORT__
                    || state == SYS_STATUS_ADD_ADMIN_FP1 || state == SYS_STATUS_ADD_ADMIN_FP2 || state == SYS_STATUS_ADD_FP
             - || state == SYS_STATUS_DEL_FP
              #endif
 590   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 591   2            || state == SYS_STATUS_ADD_RFID || state == SYS_STATUS_DEL_RFID
 592   2      #endif
 593   2          )
 594   2          {
 595   3            if (g_timer2_sleep_count > MMI_TIMER_ENTER_SLEEP_DEALY_COUNT)
 596   3            {
 597   4              flag = 1;
 598   4            }
 599   3          }
 600   2          else if (g_timer2_sleep_count > MMI_TIMER_ENTER_SLEEP_COUNT)
 601   2          {
 602   3            flag = 1;
 603   3          }
 604   2      
 605   2          if (flag)
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 11  

 606   2          {
 607   3            mmi_dq_sys_time_out_handle();
 608   3          }
 609   2        }
 610   1        else
 611   1          g_timer2_sleep_count = 0;
 612   1      }
 613          
 614          /*
 615          function: 
 616          parameter: 
 617            none
 618          return :
 619            none
 620          */
 621          unsigned char mmi_dq_sys_get_rfid_flag(void)
 622          {
 623   1        if (g_rfid_flag == 1)
 624   1        {
 625   2          g_rfid_flag = 0;
 626   2          return 1;
 627   2        }
 628   1        return 0;
 629   1      }
 630          
 631          /*
 632          function: 
 633          parameter: 
 634            none
 635          return :
 636            none
 637          */
 638          unsigned char mmi_dq_sys_get_wifi_check_flag(void)
 639          {
 640   1        if (g_wifi_check_flag == 2)
 641   1        {
 642   2          g_wifi_check_flag = 0;
 643   2          return 1;
 644   2        }
 645   1        return 0;
 646   1      }
 647          
 648          /*
 649          function: 
 650          parameter: 
 651            none
 652          return :
 653            none
 654          */
 655          void mmi_dq_sys_set_wifi_check(unsigned char type)
 656          {
 657   1        g_wifi_check_count = 0;
 658   1        g_wifi_check_flag = 1;
 659   1        g_wifi_check_type = type;
 660   1      }
 661          
 662          /*
 663          function: 
 664          parameter: 
 665            none
 666          return :
 667            none
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 12  

 668          */
 669          unsigned char mmi_dq_sys_get_wifi_check_type(void)
 670          {
 671   1        return g_wifi_check_type;
 672   1      }
 673          
 674          /*
 675          function: 
 676          parameter: 
 677            none
 678          return :
 679            none
 680          */
 681          void mmi_dq_sys_sleep_timer_reset(void)
 682          {
 683   1        g_timer2_sleep_count = 0;
 684   1        return;
 685   1      }
 686          
 687          /*
 688          function: 
 689          parameter: 
 690            none
 691          return :
 692            none
 693          */
 694          unsigned char mmi_dq_sys_get_timer2_flag(void)
 695          {
 696   1        if (g_timer2_flag == 2)
 697   1        {
 698   2          g_timer2_flag = 0;
 699   2          return 1;
 700   2        }
 701   1        return 0;
 702   1      }
 703          
 704          /*
 705          function: 
 706          parameter: 
 707            none
 708          return :
 709            none
 710          */
 711          void mmi_dq_sys_set_delay_event(unsigned int count, timer2_delay_pro pro)
 712          {
 713   1        if (count != 0)
 714   1        {
 715   2          g_timer2_count = 0;
 716   2          g_timer2_set_count = count;
 717   2          g_timer2_delay_pro = pro;
 718   2          g_timer2_flag = 1;
 719   2        }
 720   1        else
 721   1          pro();
 722   1      }
 723          
 724          /*
 725          function: 
 726          parameter: 
 727            none
 728          return :
 729            none
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 13  

 730          */
 731          void mmi_dq_sys_delay_event_pro(void)
 732          {
 733   1        if (g_timer2_delay_pro != 0)
 734   1          g_timer2_delay_pro();
 735   1      }
 736          
 737          /*
 738          function: 
 739          parameter: 
 740            none
 741          return :
 742            none
 743          */
 744          unsigned char mmi_dq_sys_check_vbat(void)
 745          {
 746   1        unsigned char state = adc_VolT();
 747   1        if (state > 0)
 748   1        {
 749   2      #ifdef __LOCK_AUDIO_SUPPORT__
 750   2          mmi_dq_aud_play_with_id(AUD_ID_LOW_BATTERY);
 751   2      #endif
 752   2      #ifdef __LOCK_WIFI_SUPPORT__
 753   2          mmi_dq_wifi_lowpower_alarm();
 754   2      #endif
 755   2          if (state == 2)
 756   2          {
 757   3            mmi_dq_ms_set_sys_state(SYS_STATUS_LOW_POWER);
 758   3            return 1;
 759   3          }
 760   2        }
 761   1      
 762   1        return 0;
 763   1      }
 764          
 765          /**
 766            * @brief  远程开门
 767            * @param  none
 768            * @return none
 769            * @note   none
 770            * @see    none
 771            */
 772          void mmi_dq_sys_wifi_open(void)
 773          {
 774   1      #ifdef __LOCK_WIFI_SUPPORT__
 775   1        if (mmi_dq_wifi_open_ask() == 0)
 776   1      #ifdef __LOCK_AUDIO_SUPPORT__
 777   1          mmi_dq_aud_play_with_id(AUD_ID_SET_FAIL);
 778   1      #else
                  ;
              #endif
 781   1      #endif
 782   1      }
 783          
 784          /*
 785          parameter: 
 786            none
 787          return :
 788            none
 789          */
 790          void mmi_dq_sys_add_admin_pwd(void)
 791          {
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 14  

 792   1      #ifdef __LOCK_AUDIO_SUPPORT__
 793   1        mmi_dq_aud_play_with_id(AUD_ID_ADD_ADMIN_PWD_FIRST);
 794   1      #endif
 795   1        mmi_ms_pwd_init_var();
 796   1        mmi_dq_ms_set_sys_state(SYS_STATUS_ADD_ADMIN_PWD);
 797   1        return;
 798   1      }
 799          
 800          //--------------------------------------------------------------------------------------------------------
             ------------------------------------------------------------------------------------
 801          //********************************************************************************************************
             -***********************************************************************************
 802          //--------------------------------------------------------------------------------------------------------
             ------------------------------------------------------------------------------------
 803          //
 804          //        menu part
 805          //
 806          //--------------------------------------------------------------------------------------------------------
             ------------------------------------------------------------------------------------
 807          //********************************************************************************************************
             -***********************************************************************************
 808          //--------------------------------------------------------------------------------------------------------
             ------------------------------------------------------------------------------------
 809          
 810          /*
 811          parameter: 
 812            none
 813          return :
 814            none
 815          */
 816          void mmi_dq_sys_add_pwd(void)
 817          {
 818   1        if (mmi_dq_fs_get_pwd_unuse_index() == 0xFF)
 819   1        {
 820   2      #ifdef __LOCK_AUDIO_SUPPORT__
 821   2          mmi_dq_aud_play_with_id(AUD_ID_PWD_FULL);
 822   2      #endif
 823   2          mmi_dq_sys_show_cur_menu_list();
 824   2        }
 825   1        else
 826   1        {
 827   2      #ifdef __LOCK_AUDIO_SUPPORT__
 828   2          mmi_dq_aud_play_with_id(AUD_ID_INPUT_68_PWD);
 829   2      #endif
 830   2          mmi_ms_pwd_init_var();
 831   2          mmi_dq_ms_set_sys_state(SYS_STATUS_ADD_PWD);
 832   2        }
 833   1        return;
 834   1      }
 835          
 836          void mmi_dq_sys_add_pwd_con(void)
 837          {
 838   1      #ifdef __LOCK_AUDIO_SUPPORT__
 839   1        mmi_dq_aud_play_with_id(AUD_ID_CONTINUE_ADD_PWD);
 840   1      #endif
 841   1        mmi_dq_ms_set_sys_state(SYS_STATUS_ADD_PWD_CON);
 842   1        return;
 843   1      }
 844          
 845          #ifdef __LOCK_110_SUPPORT__
 846          /*
 847          parameter: 
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 15  

 848            none
 849          return :
 850            none
 851          */
 852          void mmi_dq_sys_add_110_pwd(void)
 853          {
 854   1        mmi_dq_wifi_wakeup();
 855   1        if (mmi_dq_wifi_check() == 1)
 856   1        {
 857   2      #ifdef __LOCK_AUDIO_SUPPORT__
 858   2          mmi_dq_aud_play_with_id(AUD_ID_WIFI_UNFINDE);
 859   2      #endif
 860   2          mmi_dq_sys_show_cur_menu_list();
 861   2          return;
 862   2        }
 863   1      #ifdef __LOCK_AUDIO_SUPPORT__
 864   1        mmi_dq_aud_play_with_id(AUD_ID_INPUT_68_PWD);
 865   1      #endif
 866   1        mmi_ms_pwd_init_var();
 867   1        mmi_dq_ms_set_sys_state(SYS_STATUS_ADD_110_PWD);
 868   1        return;
 869   1      }
 870          #endif
 871          /*
 872          parameter: 
 873            none
 874          return :
 875            none
 876          */
 877          static void mmi_dq_sys_chg_pwd(void)
 878          {
 879   1        //mmi_dq_ms_set_sys_state(SYS_STATUS_CHG_PWD);
 880   1        return;
 881   1      }
 882          
 883          /*
 884          parameter: 
 885            none
 886          return :
 887            none
 888          */
 889          void mmi_dq_sys_del_pwd(void)
 890          {
 891   1      #ifdef __LOCK_AUDIO_SUPPORT__
 892   1        mmi_dq_aud_play_with_id(AUD_ID_INPUT_DEL_NUM);
 893   1      #endif
 894   1        mmi_ms_pwd_init_var();
 895   1        mmi_dq_ms_set_sys_state(SYS_STATUS_DEL_PWD);
 896   1        return;
 897   1      }
 898          
 899          void mmi_dq_sys_del_pwd_con(void)
 900          {
 901   1      #ifdef __LOCK_AUDIO_SUPPORT__
 902   1        mmi_dq_aud_play_with_id(AUD_ID_DEL_CONFIRM);
 903   1      #endif
 904   1        mmi_dq_ms_set_sys_state(SYS_STATUS_DEL_PWD_CON);
 905   1        return;
 906   1      }
 907          
 908          /*
 909          parameter: 
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 16  

 910            none
 911          return :
 912            none
 913          */
 914          static void mmi_dq_sys_clear_pwd(void)
 915          {
 916   1      #ifdef __LOCK_AUDIO_SUPPORT__
 917   1        mmi_dq_aud_play_with_id(AUD_ID_CLR_PWD_CONFIRM);
 918   1      #endif
 919   1        mmi_dq_ms_set_sys_state(SYS_STATUS_CLR_PWD);
 920   1        return;
 921   1      }
 922          
 923          #if defined(__LOCK_FP_SUPPORT__)
              /*
              parameter: 
                none
              return :
                none
              */
              void mmi_dq_sys_add_fp(void)
              {
                if (mmi_dq_fs_get_fp_unuse_index() == 0xFF)
                {
              #ifdef __LOCK_AUDIO_SUPPORT__
                  mmi_dq_aud_play_with_id(AUD_ID_FP_FULL);
              #endif
                  mmi_dq_sys_show_cur_menu_list();
                }
                else
                {
              #ifdef __LOCK_AUDIO_SUPPORT__
                  mmi_dq_aud_play_with_id(AUD_ID_PRESS_FP);
              #endif
                  mmi_dq_fp_light(FP_BLUE);
                  mmi_ms_opt_time_init();
                  mmi_dq_ms_set_sys_state(SYS_STATUS_ADD_FP);
                }
                return;
              }
              
              void mmi_dq_sys_add_fp_con(void)
              {
              #ifdef __LOCK_AUDIO_SUPPORT__
                mmi_dq_aud_play_with_id(AUD_ID_CONTINUE_ADD_PWD);
              #endif
                mmi_dq_ms_set_sys_state(SYS_STATUS_ADD_FP_CON);
                return;
              }
              
              #ifdef __LOCK_110_SUPPORT__
              /*
              parameter: 
                none
              return :
                none
              */
              void mmi_dq_sys_add_110_fp(void)
              {
                mmi_dq_wifi_wakeup();
                if (mmi_dq_wifi_check() == 1)
                {
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 17  

              #ifdef __LOCK_AUDIO_SUPPORT__
                  mmi_dq_aud_play_with_id(AUD_ID_WIFI_UNFINDE);
              #endif
                  mmi_dq_sys_show_cur_menu_list();
                  return;
                }
              #ifdef __LOCK_AUDIO_SUPPORT__
                mmi_dq_aud_play_with_id(AUD_ID_PRESS_FP);
              #endif
                mmi_dq_fp_light(FP_BLUE);
                mmi_ms_opt_time_init();
                mmi_dq_ms_set_sys_state(SYS_STATUS_ADD_110_FP);
                return;
              }
              
              /*
              parameter: 
                none
              return :
                none
              */
              void mmi_dq_sys_del_110_fp(void)
              {
                mmi_dq_wifi_wakeup();
                if (mmi_dq_wifi_check() == 1)
                {
              #ifdef __LOCK_AUDIO_SUPPORT__
                  mmi_dq_aud_play_with_id(AUD_ID_WIFI_UNFINDE);
              #endif
                  mmi_dq_sys_show_cur_menu_list();
                  return;
                }
              #ifdef __LOCK_AUDIO_SUPPORT__
                mmi_dq_aud_play_with_id(AUD_ID_PRESS_FP);
              #endif
                mmi_dq_fp_light(FP_BLUE);
                mmi_ms_opt_time_init();
                mmi_dq_ms_set_sys_state(SYS_STATUS_DEL_110_FP);
                return;
              }
              
              #endif
              
              /*
              parameter: 
                none
              return :
                none
              */
              static void mmi_dq_sys_chg_fp(void)
              {
                //mmi_dq_ms_set_sys_state(SYS_STATUS_CHG_FP);
                return;
              }
              
              /*
              parameter: 
                none
              return :
                none
              */
              void mmi_dq_sys_del_fp(void)
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 18  

              {
              #ifdef __LOCK_AUDIO_SUPPORT__
                mmi_dq_aud_play_with_id(AUD_ID_INPUT_DEL_FP_NUM);
              #endif
                mmi_dq_fp_light(FP_BLUE);
                mmi_ms_opt_time_init();
                mmi_dq_ms_set_sys_state(SYS_STATUS_DEL_FP);
                return;
              }
              
              void mmi_dq_sys_del_fp_con(void)
              {
              #ifdef __LOCK_AUDIO_SUPPORT__
                mmi_dq_aud_play_with_id(AUD_ID_DEL_CONFIRM);
              #endif
                mmi_dq_ms_set_sys_state(SYS_STATUS_DEL_FP_CON);
                return;
              }
              
              /*
              parameter: 
                none
              return :
                none
              */
              static void mmi_dq_sys_clear_fp(void)
              {
              #ifdef __LOCK_AUDIO_SUPPORT__
                mmi_dq_aud_play_with_id(AUD_ID_CLR_FP_CONFIRM);
              #endif
                mmi_dq_ms_set_sys_state(SYS_STATUS_CLR_FP);
                return;
              }
              #endif
1068          #ifdef __LOCK_RFID_CARD_SUPPORT__
1069          /*
1070          parameter: 
1071            none
1072          return :
1073            none
1074          */
1075          void mmi_dq_sys_add_rf(void)
1076          {
1077   1      
1078   1        if (mmi_dq_fs_get_rfid_unuse_index() == 0xFF)
1079   1        {
1080   2      #ifdef __LOCK_AUDIO_SUPPORT__
1081   2          mmi_dq_aud_play_with_id(AUD_ID_RFCARD_FULL);
1082   2      #endif
1083   2          mmi_dq_sys_show_cur_menu_list();
1084   2        }
1085   1        else
1086   1        {
1087   2      #ifdef __LOCK_AUDIO_SUPPORT__
1088   2          mmi_dq_aud_play_with_id(AUD_ID_PRESS_RFCARD);
1089   2      #endif
1090   2          mmi_ms_opt_time_init();
1091   2          mmi_dq_ms_set_sys_state(SYS_STATUS_ADD_RFID);
1092   2        }
1093   1        return;
1094   1      }
1095          
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 19  

1096          void mmi_dq_sys_add_rf_con(void)
1097          {
1098   1      #ifdef __LOCK_AUDIO_SUPPORT__
1099   1        mmi_dq_aud_play_with_id(AUD_ID_CONTINUE_ADD_PWD);
1100   1      #endif
1101   1        mmi_dq_ms_set_sys_state(SYS_STATUS_ADD_RFID_CON);
1102   1        return;
1103   1      }
1104          
1105          /*
1106          parameter: 
1107            none
1108          return :
1109            none
1110          */
1111          static void mmi_dq_sys_chg_rf(void)
1112          {
1113   1        //mmi_dq_ms_set_sys_state(SYS_STATUS_CHG_RFID);
1114   1        return;
1115   1      }
1116          
1117          /*
1118          parameter: 
1119            none
1120          return :
1121            none
1122          */
1123          void mmi_dq_sys_del_rf(void)
1124          {
1125   1      #ifdef __LOCK_AUDIO_SUPPORT__
1126   1        mmi_dq_aud_play_with_id(AUD_ID_INPUT_DEL_RFCARD_NUM);
1127   1      #endif
1128   1        mmi_ms_opt_time_init();
1129   1        mmi_dq_ms_set_sys_state(SYS_STATUS_DEL_RFID);
1130   1        return;
1131   1      }
1132          
1133          void mmi_dq_sys_del_rf_con(void)
1134          {
1135   1      #ifdef __LOCK_AUDIO_SUPPORT__
1136   1        mmi_dq_aud_play_with_id(AUD_ID_DEL_CONFIRM);
1137   1      #endif
1138   1        mmi_dq_ms_set_sys_state(SYS_STATUS_DEL_RFID_CON);
1139   1        return;
1140   1      }
1141          
1142          /*
1143          parameter: 
1144            none
1145          return :
1146            none
1147          */
1148          static void mmi_dq_sys_clear_rf(void)
1149          {
1150   1      #ifdef __LOCK_AUDIO_SUPPORT__
1151   1        mmi_dq_aud_play_with_id(AUD_ID_CLR_RFCARD_CONFIRM);
1152   1      #endif
1153   1        mmi_dq_ms_set_sys_state(SYS_STATUS_CLR_RFID);
1154   1        return;
1155   1      }
1156          #endif
1157          
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 20  

1158          #ifdef __LOCK_DECODE_SUPPORT__
1159          /**
1160            * @brief  add 8key from decode
1161            * @param  none
1162            * @return none
1163            * @note   none
1164            * @see    none
1165            */
1166          void mmi_dq_sys_add_decode(void)
1167          {
1168   1        dqiot_drv_uart0A_init();
1169   1        printf("###############\n");
1170   1        printf("A %04d-%02d-%02d %02d:%02d:%02d\r\n", t.tm_year, t.tm_mon + 1, t.tm_mday, t.tm_hour + 8, t.tm_min
             -, t.tm_sec);
1171   1        dqiot_drv_uart0B_init();
1172   1      
1173   1        if (mmi_dq_fs_get_decode_unuse_index() == 0xFF)
1174   1        {
1175   2      #ifdef __LOCK_AUDIO_SUPPORT__
1176   2          mmi_dq_aud_play_with_id(AUD_ID_ADD_FAIL_RETRY);
1177   2      #endif
1178   2          mmi_dq_sys_show_cur_menu_list();
1179   2        }
1180   1        else
1181   1        {
1182   2      #ifdef __LOCK_AUDIO_SUPPORT__
1183   2          mmi_dq_aud_play_with_id(AUD_ID_INPUT_68_PWD);
1184   2      #endif
1185   2          mmi_ms_opt_time_init();
1186   2          mmi_dq_ms_set_sys_state(SYS_STATUS_ADD_DECODE_RANDOM);
1187   2        }
1188   1        return;
1189   1      }
1190          #endif
1191          
1192          /*
1193          parameter: 
1194            none
1195          return :
1196            none
1197          */
1198          static void mmi_dq_sys_open_pro_sound(void)
1199          {
1200   1        mmi_dq_sys_set_menu_father_id(STR_ID_SETTING);
1201   1      
1202   1        if (mmi_dq_fs_set_pro_sound(1) == RET_SUCESS)
1203   1      #ifdef __LOCK_AUDIO_SUPPORT__
1204   1          mmi_dq_aud_play_with_id(AUD_ID_OPEN_PRO_AUDIO_SUCESS)
1205   1      #endif
1206   1            ;
1207   1        else
1208   1      #ifdef __LOCK_AUDIO_SUPPORT__
1209   1          mmi_dq_aud_play_with_id(AUD_ID_OPEN_PRO_AUDIO_FAIL)
1210   1      #endif
1211   1            ;
1212   1      
1213   1        mmi_dq_sys_show_cur_menu_list();
1214   1        return;
1215   1      }
1216          
1217          /*
1218          parameter: 
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 21  

1219            none
1220          return :
1221            none
1222          */
1223          static void mmi_dq_sys_close_pro_sound(void)
1224          {
1225   1        mmi_dq_sys_set_menu_father_id(STR_ID_SETTING);
1226   1      
1227   1        if (mmi_dq_fs_set_pro_sound(0) == RET_SUCESS)
1228   1      #ifdef __LOCK_AUDIO_SUPPORT__
1229   1          mmi_dq_aud_play_with_id(AUD_ID_CLOSE_PRO_AUDIO_SUCESS)
1230   1      #endif
1231   1            ;
1232   1        else
1233   1      #ifdef __LOCK_AUDIO_SUPPORT__
1234   1          mmi_dq_aud_play_with_id(AUD_ID_CLOSE_PRO_AUDIO_FAIL)
1235   1      #endif
1236   1            ;
1237   1      
1238   1        mmi_dq_sys_show_cur_menu_list();
1239   1        return;
1240   1      }
1241          
1242          /*
1243          parameter: 
1244            none
1245          return :
1246            none
1247          */
1248          static void mmi_dq_sys_sin_open_mode(void)
1249          {
1250   1        mmi_dq_sys_set_menu_father_id(STR_ID_SETTING);
1251   1      
1252   1        if (mmi_dq_fs_set_open_mode(SYS_OPEN_MODE_SIN) == RET_SUCESS)
1253   1      #ifdef __LOCK_AUDIO_SUPPORT__
1254   1          mmi_dq_aud_play_with_id(AUD_ID_SIN_OPEN_MODE_SUCESS)
1255   1      #endif
1256   1            ;
1257   1        else
1258   1      #ifdef __LOCK_AUDIO_SUPPORT__
1259   1          mmi_dq_aud_play_with_id(AUD_ID_SIN_OPEN_MODE_FAIL)
1260   1      #endif
1261   1            ;
1262   1      
1263   1        mmi_dq_sys_show_cur_menu_list();
1264   1        return;
1265   1      }
1266          
1267          /*
1268          parameter: 
1269            none
1270          return :
1271            none
1272          */
1273          static void mmi_dq_sys_dbl_open_mode(void)
1274          {
1275   1        mmi_dq_sys_set_menu_father_id(STR_ID_SETTING);
1276   1      
1277   1        if (mmi_dq_fs_set_open_mode(SYS_OPEN_MODE_DBL) == RET_SUCESS)
1278   1      #ifdef __LOCK_AUDIO_SUPPORT__
1279   1          mmi_dq_aud_play_with_id(AUD_ID_DBL_OPEN_MODE_SUCESS)
1280   1      #endif
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 22  

1281   1            ;
1282   1        else
1283   1      #ifdef __LOCK_AUDIO_SUPPORT__
1284   1          mmi_dq_aud_play_with_id(AUD_ID_DBL_OPEN_MODE_FAIL)
1285   1      #endif
1286   1            ;
1287   1      
1288   1        mmi_dq_sys_show_cur_menu_list();
1289   1        return;
1290   1      }
1291          
1292          #if defined(__LOCK_FP_SUPPORT__)
              /*
              parameter: 
                none
              return :
                none
              */
              void mmi_dq_sys_chg_admin_fp_No1(void)
              {
              #ifdef __LOCK_AUDIO_SUPPORT__
                mmi_dq_aud_play_with_id(AUD_ID_NEW_ADMIN_FP);
              #endif
                mmi_dq_fp_light(FP_BLUE);
                mmi_ms_opt_time_init();
                mmi_dq_ms_set_sys_state(SYS_STATUS_ADD_ADMIN_FP1);
                return;
              }
              
              /*
              parameter: 
                none
              return :
                none
              */
              void mmi_dq_sys_chg_admin_fp_No2(void)
              {
              #ifdef __LOCK_AUDIO_SUPPORT__
                mmi_dq_aud_play_with_id(AUD_ID_NEW_ADMIN_FP);
              #endif
                mmi_dq_fp_light(FP_BLUE);
                mmi_ms_opt_time_init();
                mmi_dq_ms_set_sys_state(SYS_STATUS_ADD_ADMIN_FP2);
                return;
              }
              #endif
1327          
1328          /*
1329          parameter: 
1330            none
1331          return :
1332            none
1333          */
1334          void mmi_dq_sys_chg_admin_pwd(void)
1335          {
1336   1      #ifdef __LOCK_AUDIO_SUPPORT__
1337   1        mmi_dq_aud_play_with_id(AUD_ID_INPUT_NEW_ADMIN_PWD);
1338   1      #endif
1339   1        mmi_ms_pwd_init_var();
1340   1        mmi_dq_ms_set_sys_state(SYS_STATUS_CHG_ADMIN_PWD);
1341   1        return;
1342   1      }
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 23  

1343          
1344          /*
1345          parameter: 
1346            none
1347          return :
1348            none
1349          */
1350          void mmi_dq_sys_restore_lock(void)
1351          {
1352   1        unsigned char retval = 0;
1353   1        mmi_dq_ms_set_sys_state(SYS_STATUS_RESTORE_LOCK);
1354   1      
1355   1        if (RET_SUCESS != mmi_dq_fs_clr_set())
1356   1          retval = 1;
1357   1        if (RET_SUCESS != mmi_dq_fs_clr_pwd())
1358   1          retval = 1;
1359   1      #ifdef __LOCK_FP_SUPPORT__
                if (RET_SUCESS != mmi_dq_fs_clr_fp())
                  retval = 1;
              #endif
1363   1      #ifdef __LOCK_RFID_CARD_SUPPORT__
1364   1        if (RET_SUCESS != mmi_dq_fs_clr_rfid())
1365   1          retval = 1;
1366   1      #endif
1367   1      
1368   1        if (retval == 0)
1369   1      #ifdef __LOCK_AUDIO_SUPPORT__
1370   1          mmi_dq_aud_play_with_id(AUD_ID_RESTORE_SUCESS)
1371   1      #endif
1372   1            ;
1373   1        else
1374   1      #ifdef __LOCK_AUDIO_SUPPORT__
1375   1          mmi_dq_aud_play_with_id(AUD_ID_RESTORE_FAIL)
1376   1      #endif
1377   1            ;
1378   1      
1379   1        mmi_dq_ms_set_sys_state(SYS_STATUS_IDLE);
1380   1        return;
1381   1      }
1382          
1383          /*
1384          parameter: 
1385            none
1386          return :
1387            none
1388          */
1389          static void mmi_dq_sys_restore_lock_con(void)
1390          {
1391   1      #ifdef __LOCK_AUDIO_SUPPORT__
1392   1        mmi_dq_aud_play_with_id(AUD_ID_RESTORE_LOCK_CONTINUE_CONFIRM);
1393   1      #endif
1394   1        mmi_dq_ms_set_sys_state(SYS_STATUS_RESTORE_LOCK_CON);
1395   1      }
1396          
1397          #ifdef __LOCK_WIFI_SUPPORT__
1398          
1399          /**
1400            * @brief  智能能配网
1401            * @param  none
1402            * @return none
1403            * @note   none
1404            * @see    none
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 24  

1405            */
1406          static void mmi_dq_sys_wifi_setting(void)
1407          {
1408   1        if (0 == mmi_dq_wifi_setting())
1409   1        {
1410   2      #ifdef __LOCK_AUDIO_SUPPORT__
1411   2          mmi_dq_aud_play_with_id(AUD_ID_SET_FAIL);
1412   2      #endif
1413   2          mmi_dq_sys_show_cur_menu_list();
1414   2        }
1415   1        else
1416   1        {
1417   2          mmi_dq_ms_set_sys_state(SYS_STATUS_WIFI_MODE);
1418   2      #ifdef __LOCK_AUDIO_SUPPORT__
1419   2          mmi_dq_aud_play_with_id(AUD_ID_WIFI_CONNECTING);
1420   2      #endif
1421   2        }
1422   1      }
1423          
1424          /**
1425            * @brief  AirKiss配网
1426            * @param  none
1427            * @return none
1428            * @note   none
1429            * @see    none
1430            */
1431          static void mmi_dq_sys_wifi_airkiss_setting(void)
1432          {
1433   1        if (0 == mmi_dq_wifi_arikiss_con())
1434   1        {
1435   2      #ifdef __LOCK_AUDIO_SUPPORT__
1436   2          mmi_dq_aud_play_with_id(AUD_ID_SET_FAIL);
1437   2      #endif
1438   2          mmi_dq_sys_show_cur_menu_list();
1439   2        }
1440   1        else
1441   1        {
1442   2          mmi_dq_ms_set_sys_state(SYS_STATUS_WIFI_MODE);
1443   2      #ifdef __LOCK_AUDIO_SUPPORT__
1444   2          mmi_dq_aud_play_with_id(AUD_ID_WIFI_CONNECTING);
1445   2      #endif
1446   2        }
1447   1      }
1448          
1449          /**
1450            * @brief  二维码配网
1451            * @param  none
1452            * @return none
1453            * @note   none
1454            * @see    none
1455            */
1456          static void mmi_dq_sys_wifi_code_setting(void)
1457          {
1458   1        if (0 == mmi_dq_wifi_code_con())
1459   1        {
1460   2      #ifdef __LOCK_AUDIO_SUPPORT__
1461   2          mmi_dq_aud_play_with_id(AUD_ID_SET_FAIL);
1462   2      #endif
1463   2          mmi_dq_sys_show_cur_menu_list();
1464   2        }
1465   1        else
1466   1        {
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 25  

1467   2          mmi_dq_ms_set_sys_state(SYS_STATUS_WIFI_MODE);
1468   2      #ifdef __LOCK_AUDIO_SUPPORT__
1469   2          mmi_dq_aud_play_with_id(AUD_ID_WIFI_CONNECTING);
1470   2      #endif
1471   2        }
1472   1      }
1473          #endif
1474          
1475          #ifdef __LOCK_DECODE_SUPPORT__
1476          static void mmi_dq_sys_sync_start_time(void)
1477          {
1478   1      }
1479          #endif
1480          
1481          typedef struct sys_menu_t
1482          {
1483            unsigned char menu_father_id;
1484            unsigned char menu_sub_id;
1485            void (*sys_menu_node_function)(void);
1486          } sys_menu_t;
1487          
1488          typedef struct sys_menu_list
1489          {
1490            unsigned char id;
1491            unsigned char menu_id;
1492          } sys_menu_list;
1493          
1494          const sys_menu_t sys_menu_tree[] =
1495            {
1496              {STR_ID_SYSTEM, STR_ID_PASSWORD, 0},
1497          #if defined(__LOCK_FP_SUPPORT__)
                  {STR_ID_SYSTEM, STR_ID_FINGERPRINT, 0},
              #endif
1500          #ifdef __LOCK_RFID_CARD_SUPPORT__
1501              {STR_ID_SYSTEM, STR_ID_RF_CARD, 0},
1502          #endif
1503              {STR_ID_SYSTEM, STR_ID_ADMIN, 0},
1504              {STR_ID_SYSTEM, STR_ID_SETTING, 0},
1505              {STR_ID_SYSTEM, STR_ID_RESTORE, mmi_dq_sys_restore_lock_con},
1506          #ifdef __LOCK_WIFI_SUPPORT__
1507              {STR_ID_SYSTEM, STR_ID_WIFI, mmi_dq_sys_wifi_setting},
1508              {STR_ID_SYSTEM, STR_ID_WIFI, mmi_dq_sys_wifi_airkiss_setting},
1509          #ifdef __LOCK_DECODE_SUPPORT__
1510              {STR_ID_SYSTEM, STR_ID_DECODE, mmi_dq_sys_add_decode},
1511          #endif
1512          
1513          #endif
1514          #ifdef __LOCK_110_SUPPORT__
1515              {STR_ID_SYSTEM, STR_ID_110, 0},
1516          
1517              {STR_ID_110, STR_ID_PASSWORD_110, mmi_dq_sys_add_110_pwd},
1518          #if defined(__LOCK_FP_SUPPORT__)
                  {STR_ID_110, STR_ID_FINGERPRINT_110, 0},
              #endif
1521          #endif
1522          
1523              {STR_ID_SYSTEM2, STR_ID_ADMIN, 0},
1524              {STR_ID_SYSTEM2, STR_ID_SETTING, 0},
1525              {STR_ID_SYSTEM2, STR_ID_RESTORE, mmi_dq_sys_restore_lock_con},
1526          
1527              //PWD
1528              {STR_ID_PASSWORD, STR_ID_ADD_PWD, mmi_dq_sys_add_pwd},
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 26  

1529              //{STR_ID_PASSWORD,STR_ID_CHG_PWD,mmi_dq_sys_chg_pwd},
1530              {STR_ID_PASSWORD, STR_ID_DEL_PWD, mmi_dq_sys_del_pwd},
1531              {STR_ID_PASSWORD, STR_ID_CLR_PWD, mmi_dq_sys_clear_pwd},
1532          //FP
1533          #if defined(__LOCK_FP_SUPPORT__)
                  {STR_ID_FINGERPRINT, STR_ID_ADD_FP, mmi_dq_sys_add_fp},
                  //{STR_ID_FINGERPRINT,STR_ID_CHG_FP,mmi_dq_sys_chg_fp},
                  {STR_ID_FINGERPRINT, STR_ID_DEL_FP, mmi_dq_sys_del_fp},
                  {STR_ID_FINGERPRINT, STR_ID_CLR_FP, mmi_dq_sys_clear_fp},
              #ifdef __LOCK_110_SUPPORT__
                  {STR_ID_FINGERPRINT_110, STR_ID_ADD_FP, mmi_dq_sys_add_110_fp},
                  {STR_ID_FINGERPRINT_110, STR_ID_DEL_FP, mmi_dq_sys_del_110_fp},
              #endif
              #endif
1543          #ifdef __LOCK_RFID_CARD_SUPPORT__
1544              //RF
1545              {STR_ID_RF_CARD, STR_ID_ADD_RFCARD, mmi_dq_sys_add_rf},
1546              //{STR_ID_RF_CARD,STR_ID_CHG_RFCARD,mmi_dq_sys_chg_rf},
1547              {STR_ID_RF_CARD, STR_ID_DEL_RFCARD, mmi_dq_sys_del_rf},
1548              {STR_ID_RF_CARD, STR_ID_CLR_RFCARD, mmi_dq_sys_clear_rf},
1549          #endif
1550              //admin
1551              {STR_ID_ADMIN, STR_ID_CHG_ADMIN_PWD, mmi_dq_sys_chg_admin_pwd},
1552          #if defined(__LOCK_FP_SUPPORT__)
                  {STR_ID_ADMIN, STR_ID_CHG_ADMIN_FP, 0},
                  {STR_ID_CHG_ADMIN_FP, STR_ID_NO1_ADMIN_FP, mmi_dq_sys_chg_admin_fp_No1},
                  {STR_ID_CHG_ADMIN_FP, STR_ID_NO2_ADMIN_FP, mmi_dq_sys_chg_admin_fp_No2},
              #endif
1557              //setting
1558              {STR_ID_SETTING, STR_ID_PRO_AUDIO, 0},
1559              {STR_ID_SETTING, STR_ID_OPEN_MODE, 0},
1560          
1561              {STR_ID_PRO_AUDIO, STR_ID_OPEN_PRO_AUDIO, mmi_dq_sys_open_pro_sound},
1562              {STR_ID_PRO_AUDIO, STR_ID_CLOSE_PRO_AUDIO, mmi_dq_sys_close_pro_sound},
1563              {STR_ID_OPEN_MODE, STR_ID_SIN_OPEN_MODE, mmi_dq_sys_sin_open_mode},
1564              {STR_ID_OPEN_MODE, STR_ID_DBL_OPEN_MODE, mmi_dq_sys_dbl_open_mode},
1565          };
1566          
1567          static unsigned char g_dq_menu_father_id;
1568          static sys_menu_list g_dq_menu_list_id[10];
1569          static unsigned char g_dq_menu_count;
1570          
1571          /*
1572          parameter: 
1573            none
1574          return :
1575            none
1576          */
1577          void mmi_dq_sys_set_menu_father_id(unsigned char father_id)
1578          {
1579   1        g_dq_menu_father_id = father_id;
1580   1        return;
1581   1      }
1582          
1583          /*
1584          parameter: 
1585            none
1586          return :
1587            none
1588          */
1589          unsigned char mmi_dq_sys_get_menu_count(void)
1590          {
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 27  

1591   1        return g_dq_menu_count;
1592   1      }
1593          
1594          /*
1595          parameter: 
1596            none
1597          return :
1598            none
1599          */
1600          static void mmi_dq_sys_get_menu_list(unsigned char father_id)
1601          {
1602   1        unsigned char i = 0, j = 0;
1603   1        unsigned char menu_tree_size = sizeof(sys_menu_tree) / sizeof(sys_menu_t);
1604   1      
1605   1        g_dq_menu_father_id = father_id;
1606   1      
1607   1        memset(&g_dq_menu_list_id, 0x00, sizeof(g_dq_menu_list_id));
1608   1        g_dq_menu_count = 0;
1609   1      
1610   1        for (i = 0; i < menu_tree_size; i++)
1611   1        {
1612   2          if (sys_menu_tree[i].menu_father_id == g_dq_menu_father_id)
1613   2          {
1614   3            g_dq_menu_list_id[j].id = i;
1615   3            g_dq_menu_list_id[j].menu_id = sys_menu_tree[i].menu_sub_id;
1616   3            j++;
1617   3            g_dq_menu_count++;
1618   3          }
1619   2        }
1620   1        return;
1621   1      }
1622          
1623          /*
1624          parameter: 
1625            none
1626          return :
1627            none
1628          */
1629          void mmi_dq_sys_show_cur_menu_list(void)
1630          {
1631   1        mmi_dq_sys_get_menu_list(g_dq_menu_father_id);
1632   1      
1633   1      #ifdef __LOCK_AUDIO_SUPPORT__
1634   1        mmi_dq_aud_play_with_id(mmi_dq_aud_get_audio_id(g_dq_menu_father_id));
1635   1      #endif
1636   1      #ifdef __LOCK_FP_SUPPORT__
                mmi_dq_fp_light(FP_NONE_COLOR);
              #endif
1639   1        mmi_dq_ms_set_sys_state(SYS_STATUS_SYS_MENU);
1640   1        return;
1641   1      }
1642          
1643          /*
1644          parameter: 
1645            none
1646          return :
1647            current machine status
1648          */
1649          void mmi_dq_sys_get_pre_menu_list(void)
1650          {
1651   1        if (g_dq_menu_father_id == STR_ID_SYSTEM)
1652   1        {
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 28  

1653   2          mmi_dq_ms_set_sys_state(SYS_STATUS_IDLE);
1654   2        }
1655   1        else
1656   1        {
1657   2          unsigned char i = 0;
1658   2          unsigned char menu_tree_size = sizeof(sys_menu_tree) / sizeof(sys_menu_t);
1659   2      
1660   2          for (i = 0; i < menu_tree_size; i++)
1661   2          {
1662   3            if (sys_menu_tree[i].menu_sub_id == g_dq_menu_father_id)
1663   3            {
1664   4              g_dq_menu_father_id = sys_menu_tree[i].menu_father_id;
1665   4              break;
1666   4            }
1667   3          }
1668   2          mmi_dq_sys_get_menu_list(g_dq_menu_father_id);
1669   2      #ifdef __LOCK_AUDIO_SUPPORT__
1670   2          mmi_dq_aud_play_with_id(mmi_dq_aud_get_audio_id(g_dq_menu_father_id));
1671   2      #endif
1672   2        }
1673   1        return;
1674   1      }
1675          
1676          /*
1677          parameter: 
1678            none
1679          return :
1680            none
1681          */
1682          RET_VAL mmi_dq_sys_exe_menu_fun(unsigned char menu_id)
1683          {
1684   1        unsigned char i = 0;
1685   1        unsigned char menu_tree_size = sizeof(sys_menu_tree) / sizeof(sys_menu_t);
1686   1        if (menu_id >= g_dq_menu_count)
1687   1          return RET_FAIL;
1688   1        i = g_dq_menu_list_id[menu_id].id;
1689   1        if (sys_menu_tree[i].sys_menu_node_function != 0)
1690   1        {
1691   2          sys_menu_tree[i].sys_menu_node_function();
1692   2        }
1693   1        else
1694   1        {
1695   2          mmi_dq_sys_get_menu_list(g_dq_menu_list_id[menu_id].menu_id);
1696   2      
1697   2      #ifdef __LOCK_AUDIO_SUPPORT__
1698   2          mmi_dq_aud_play_with_id(mmi_dq_aud_get_audio_id(g_dq_menu_father_id));
1699   2      #endif
1700   2        }
1701   1      
1702   1        return RET_SUCESS;
1703   1      }
1704          
1705          /************************************************************************************
1706           *                     Own function                     *
1707           ************************************************************************************/
1708          #if 0 //def __LOCK_VIRTUAL_PASSWORD__
              void mmi_dq_sys_show_message_with_id(unsigned char tile_id, unsigned char bmp_id, unsigned char text_id, u
             -int32_t time_msec, BASE_STATUS_MACHINE status)
              {
                unsigned char i = 0;
              #ifdef __LOCK_OLED_SUPPORT__
                mmi_dq_oled_show_input_dialog(tile_id, bmp_id, text_id);
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 29  

              #endif
              
              #ifdef __NBDQIOT_PROJECT_B06_SUPPORT__
                if (text_id == STR_ID_OPEN_DOOR)
                {
                  //power_off();
                  lock_inside_lock = 0;
                  lock_easy_open_mode = 0;
                  mmi_dq_aud_play_with_id(AUD_ID_DOOR_OPEN, 0);
                  // mmi_dq_entry_sleep_delay_time();
                  mmi_dq_show_msg_timer_start(10000);
                  timer_ms_status = status;
                  mmi_dq_ms_set_machine_status(BASE_STATUS_M_LOCK_OPEN);
                  mmi_dq_moto_lock_open();
                }
                else
                {
              #ifdef __LOCK_AUDIO_SUPPORT__
                  for (i = 0; msg_aud_list[i].msg_id < STR_ID_MAX_COUNT; i++)
                  {
                    if (msg_aud_list[i].msg_id == text_id)
                    {
                      break;
                    }
                  }
                  if (msg_aud_list[i].aud_id != 0xFF)
                  {
                    mmi_dq_aud_play_with_id(msg_aud_list[i].aud_id, 0);
                  }
              #endif
                  if (time_msec > 0)
                  {
                    mmi_dq_show_msg_timer_start(time_msec);
                    timer_ms_status = status;
                    mmi_dq_ms_set_machine_status(BASE_STATUS_M_INVALID);
                  }
                  else
                    mmi_dq_ms_set_machine_status(status);
                }
              #else
              
              #ifdef __LOCK_AUDIO_SUPPORT__
                for (i = 0; msg_aud_list[i].msg_id < STR_ID_MAX_COUNT; i++)
                {
                  if (msg_aud_list[i].msg_id == text_id)
                  {
                    break;
                  }
                }
                if (msg_aud_list[i].aud_id != 0xFF)
                {
              //    mmi_dq_aud_play_with_id(msg_aud_list[i].aud_id, 0);
                }
              #endif
              
              //  if (time_msec > 0)
              //  {
              //    mmi_dq_show_msg_timer_start(time_msec);
              //    timer_ms_status = status;
              //    mmi_dq_ms_set_machine_status(BASE_STATUS_M_INVALID);
              //  }
              //  else
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 30  

              //    mmi_dq_ms_set_machine_status(status);
              
                if (text_id == STR_ID_OPEN_DOOR)
                {
                  mmi_dq_moto_lock_open();
                }
              #endif
                return;
              }
              #endif
1786          #ifdef __LOCK_VIRTUAL_PASSWORD__
1787          uint8_t mmi_dq_sys_lock_error(void)
1788          {
1789   1        uint32_t time = mmi_dq_rtc_get_sys_sec_info();
1790   1        if (time - g_last_error_time > MMI_ERROR_LOCK_TIME)
1791   1        {
1792   2          g_multiple_error_times = 1;
1793   2          g_last_error_time = time;
1794   2        }
1795   1        else
1796   1        {
1797   2          g_last_error_time = time;
1798   2          g_multiple_error_times++;
1799   2          if (g_multiple_error_times >= MMI_MAX_ERROR_TIMES)
1800   2          {
1801   3            //multiple error
1802   3      #ifdef __LOCK_APP_COMM_SUPPORT__
                    if (mmi_dq_fs_app_init_sucess() == 1)
                    {
                      dq_otp_add_alarm_log(DQ_ALART_LOG_MULTIPLE_ERROR);
                    }
              #endif
1808   3            return 1;
1809   3          }
1810   2        }
1811   1        return 0;
1812   1      }
1813          
1814          void mmi_dq_sys_lock_correct(void)
1815          {
1816   1        g_last_error_time = 0;
1817   1        g_multiple_error_times = 0;
1818   1      }
1819          
1820          void mmi_dq_entry_sleep_delay_time(void)
1821          {
1822   1        //  g_enter_sleep_set_time = MMI_TIMER_ENTER_SLEEP_DELAY_COUNT;
1823   1      }
1824          
1825          void mmi_dq_show_msg_timer_start(uint32_t time_msec)
1826          {
1827   1        uint32_t time_ms = MMI_TIMER_BASE_TIME;
1828   1        uint32_t time_ticks;
1829   1      
1830   1        //  g_show_msg_time_voval_count = time_msec/MMI_TIMER_BASE_TIME;
1831   1        //  g_show_msg_time_count = 0;
1832   1        //  time_ticks = nrf_drv_timer_ms_to_ticks(&TIMER2_MMI_TIMER, time_ms);
1833   1        //  nrf_drv_timer_extended_compare(&TIMER2_MMI_TIMER, NRF_TIMER_CC_CHANNEL1, time_ticks, NRF_TIMER_SHORT_C
             -OMPARE1_CLEAR_MASK, true);
1834   1        //  nrf_drv_timer_enable(&TIMER2_MMI_TIMER);
1835   1        return;
1836   1      }
C51 COMPILER V9.59.0.0   MMI_SYS                                                           04/28/2021 17:37:43 PAGE 31  

*** WARNING C280 IN LINE 1825 OF mmi_src\mmi_sys.c: 'time_msec': unreferenced local variable
*** WARNING C280 IN LINE 1828 OF mmi_src\mmi_sys.c: 'time_ticks': unreferenced local variable
1837          
1838          uint8_t mmi_dq_lock_random_vector_generate(uint8_t * p_buff, uint8_t size)
1839          {
1840   1              uint8_t available,length;
1841   1              uint32_t err_code;
1842   1              // err_code = nrf_drv_rng_bytes_available(&available);
1843   1              // APP_ERROR_CHECK(err_code);
1844   1              length = (size<available) ? size : available;
1845   1              // err_code = nrf_drv_rng_rand(p_buff,length);
1846   1              // APP_ERROR_CHECK(err_code);
1847   1              return length;
1848   1      }
*** WARNING C280 IN LINE 1838 OF mmi_src\mmi_sys.c: 'p_buff': unreferenced local variable
*** WARNING C280 IN LINE 1841 OF mmi_src\mmi_sys.c: 'err_code': unreferenced local variable
1849          
1850          unsigned char  mmi_dq_sys_is_sleep(void)
1851          {
1852   1            return 0; //g_sleep_mode;
1853   1      }
1854          
1855          #endif //__LOCK_VIRTUAL_PASSWORD__
1856          /************************************************************************************
1857           *                     End function                     *
1858           ************************************************************************************/
1859          
1860          #endif //__MMI_SYS_C__


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2937    ----
   CONSTANT SIZE    =     51    ----
   XDATA SIZE       =    178      44
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
