C51 COMPILER V9.59.0.0   MMI_TIME                                                          04/27/2021 12:00:50 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MMI_TIME
OBJECT MODULE PLACED IN .\output\mmi_time.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE mmi_src\mmi_time.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;
                    -.\Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd_r
                    -fid;.\mmi_inc) DEBUG PRINT(.\list\mmi_time.lst) TABS(2) OBJECT(.\output\mmi_time.obj)

line level    source

   1          #ifndef __MMI_TIME_C__
   2          #define __MMI_TIME_C__
   3          #include "mmi_feature.h"
   4          #ifdef __LOCK_DECODE_SUPPORT__
   5          #include <stdio.h>
   6          #include <string.h>
   7          #include "mmi_time.h"
   8          
   9          unsigned char temp_data[10] = {0xff};
  10          
  11          const char Days[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
  12          static time_t mon_yday[2][12] =
  13              {
  14                  {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334},
  15                  {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335},
  16          };
  17          
  18          /**
  19            * @brief  时间戳除法取整
  20            * @param  data 数组
  21            * @param  x 除数
  22            * @param  len 长度
  23            * @param  dest 存入数组
  24            * @return status
  25            * @note   none
  26            * @see    none
  27            */
  28          unsigned char division_int(unsigned char *p_data, unsigned int x, unsigned char len, unsigned char *dest)
  29          {
  30   1          unsigned char i, j;
  31   1          unsigned long temp_int = 0, temp_rem = 0; //temp_int整数，temp_rem余数
  32   1          unsigned char d_data[10];
  33   1          unsigned char p_data_len = 10;
  34   1      
  35   1          /* 获取数据包长度 */
  36   1          for (i = 0; i < len; i++)
  37   1          {
  38   2              if (p_data[i] == 0xff)
  39   2              {
  40   3                  p_data_len = i;
  41   3                  break;
  42   3              }
  43   2          }
  44   1      
  45   1          memset(&d_data, 0xff, sizeof(d_data));
  46   1          /* 计算除数 */
  47   1          for (j = 0, i = 0; i < p_data_len; i++)
  48   1          {
  49   2              temp_int = (temp_rem * 10 + p_data[i]) / x;
  50   2              temp_rem = (temp_rem * 10 + p_data[i]) % x;
  51   2      
  52   2              d_data[j] = temp_int;
  53   2              j++;
C51 COMPILER V9.59.0.0   MMI_TIME                                                          04/27/2021 12:00:50 PAGE 2   

  54   2          }
  55   1      
  56   1          /* 去除开头的0 */
  57   1          for (i = 0; i < len; i++)
  58   1          {
  59   2              if (d_data[i] != 0)
  60   2                  break;
  61   2          }
  62   1      
  63   1          /* 赋值  */
  64   1          for (j = 0; j < len; j++)
  65   1          {
  66   2              if (i < len)
  67   2              {
  68   3                  dest[j] = d_data[i];
  69   3                  i++;
  70   3              }
  71   2              else
  72   2                  dest[j] = 0xff;
  73   2          }
  74   1      
  75   1          // printf("p_data_len is %d\n", (int)p_data_len);
  76   1          // for (i = 0; i < 10; i++)
  77   1          //     printf("dest is %d\n", (int)dest[i]);
  78   1          // printf("############\n");
  79   1      
  80   1          return 0;
  81   1      }
  82          
  83          /**
  84            * @brief  时间戳除法取余
  85            * @param  data 数组
  86            * @param  x 除数
  87            * @param  len 长度
  88            * @return status
  89            * @note   none
  90            * @see    none
  91            */
  92          unsigned long division_rem(unsigned char *p_data, unsigned int x, unsigned char len)
  93          {
  94   1          unsigned char i;
  95   1          unsigned long temp_int = 0, temp_rem = 0; //temp_int整数，temp_rem余数
  96   1          unsigned char p_data_len = 10;
  97   1      
  98   1          /* 获取数据包长度 */
  99   1          for (i = 0; i < len; i++)
 100   1          {
 101   2              if (p_data[i] == 0xff)
 102   2              {
 103   3                  p_data_len = i;
 104   3                  break;
 105   3              }
 106   2          }
 107   1      
 108   1          /* 计算除数 */
 109   1          for (i = 0; i < p_data_len; i++)
 110   1          {
 111   2              temp_int = (temp_rem * 10 + p_data[i]) / x;
 112   2              temp_rem = (temp_rem * 10 + p_data[i]) % x;
 113   2          }
 114   1      
 115   1          return temp_rem;
C51 COMPILER V9.59.0.0   MMI_TIME                                                          04/27/2021 12:00:50 PAGE 3   

 116   1      }
 117          
 118          /**
 119            * @brief  时间戳转换时间
 120            * @param  decode_time 时间戳
 121            * @param  t 存放地址
 122            * @return none
 123            * @note   none
 124            * @see    none
 125            */
 126          void ntp(unsigned char *decode_time, struct tm *t)
 127          {
 128   1          unsigned long time = 0;
 129   1          unsigned long Pass4year;
 130   1          int hours_per_year;
 131   1      
 132   1          //取秒时间
 133   1          t->tm_sec = division_rem(decode_time, 60, 10);
 134   1          division_int(decode_time, 60, 10, temp_data);
 135   1      
 136   1          //取分钟时间
 137   1          t->tm_min = division_rem(temp_data, 60, 10);
 138   1          division_int(temp_data, 60, 10, temp_data);
 139   1          time = CharToInt_long(temp_data, 10);
 140   1      
 141   1          //取过去多少个四年，每四年有 1461*24 小时
 142   1          Pass4year = ((unsigned int)time / (1461L * 24L));
 143   1      
 144   1          //计算年份
 145   1          t->tm_year = (Pass4year << 2) + 1970;
 146   1      
 147   1          //四年中剩下的小时数
 148   1          time %= 1461L * 24L;
 149   1      
 150   1          //校正闰年影响的年份，计算一年中剩下的小时数
 151   1          for (;;)
 152   1          {
 153   2              /* 一年的小时数 */
 154   2              hours_per_year = 365 * 24;
 155   2              /* 判断闰年 */
 156   2              if ((t->tm_year & 3) == 0)
 157   2              {
 158   3                  /* 是闰年，一年则多24小时，即一天 */
 159   3                  hours_per_year += 24;
 160   3              }
 161   2              if (time < hours_per_year)
 162   2              {
 163   3                  break;
 164   3              }
 165   2              t->tm_year++;
 166   2              time -= hours_per_year;
 167   2          }
 168   1      
 169   1          /* 小时数 */
 170   1          t->tm_hour = (int)(time % 24);
 171   1          /* 一年中剩下的天数 */
 172   1          time /= 24;
 173   1          /* 假定为闰年 */
 174   1          time++;
 175   1          /* 校正闰年的误差，计算月份，日期 */
 176   1          if ((t->tm_year & 3) == 0)
 177   1          {
C51 COMPILER V9.59.0.0   MMI_TIME                                                          04/27/2021 12:00:50 PAGE 4   

 178   2              if (time > 60)
 179   2              {
 180   3                  time--;
 181   3              }
 182   2              else
 183   2              {
 184   3                  if (time == 60)
 185   3                  {
 186   4                      t->tm_mon = 1;
 187   4                      t->tm_mday = 29;
 188   4                      return;
 189   4                  }
 190   3              }
 191   2          }
 192   1          /* 计算月日 */
 193   1          for (t->tm_mon = 0; Days[t->tm_mon] < time; t->tm_mon++)
 194   1          {
 195   2              time -= Days[t->tm_mon];
 196   2          }
 197   1      
 198   1          t->tm_mday = (int)(time);
 199   1      
 200   1          // printf("A %d-%d-%d %d:%d:%d\r\n", t->tm_year, t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, t->
             -tm_sec);
 201   1          // printf("############\n");
 202   1      
 203   1          return;
 204   1      }
 205          
 206          /**
 207            * @brief  计算秒数
 208            * @param  年
 209            * @return 秒数
 210            * @note   none
 211            * @see    none
 212            */
 213          int isleap(int year)
 214          {
 215   1          return (year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0);
 216   1      }
 217          
 218          /**
 219            * @brief  时间转化成时间戳
 220            * @param  时间
 221            * @return 时间戳
 222            * @note   none
 223            * @see    none
 224            */
 225          time_t mktime(struct tm dt)
 226          {
 227   1          time_t result;
 228   1          int i = 0;
 229   1          // 以平年时间计算的秒数
 230   1          result = (dt.tm_year - 1970) * 365 * 24 * 3600 +
 231   1                   (mon_yday[isleap(dt.tm_year)][dt.tm_mon - 1] + dt.tm_mday - 1) * 24 * 3600 +
 232   1                   dt.tm_hour * 3600 + dt.tm_min * 60 + dt.tm_sec;
 233   1          // 加上闰年的秒数
 234   1          for (i = 1970; i < dt.tm_year; i++)
 235   1          {
 236   2              if (isleap(i))
 237   2              {
 238   3                  result += 24 * 3600;
C51 COMPILER V9.59.0.0   MMI_TIME                                                          04/27/2021 12:00:50 PAGE 5   

 239   3              }
 240   2          }
 241   1          return (result);
 242   1      }
 243          
 244          // /* 使用方法 */
 245          // void main()
 246          // {
 247          //     struct tm t;
 248          //     get_decode.tim_key_10 = 1619063988;
 249          //     ntp(get_decode.tim_key_10, &t);
 250          //     printf("A %d-%d-%d %d:%d:%d\r\n", t.tm_year, t.tm_mon + 1, t.tm_mday, t.tm_hour + 8, t.tm_min, t.tm
             -_sec);
 251          //     return;
 252          // }
 253          
 254          #endif //__LOCK_DECODE_SUPPORT__
 255          #endif
 256          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2089    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     70      74
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
