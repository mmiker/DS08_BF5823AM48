C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       04/07/2021 17:03:19 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DQIOT_FP_SY
OBJECT MODULE PLACED IN .\output\dqiot_fp_sy.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE source\dqiot_fp_sy.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\includ
                    -e;.\Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd
                    -_rfid;.\mmi_inc) DEBUG PRINT(.\list\dqiot_fp_sy.lst) TABS(2) OBJECT(.\output\dqiot_fp_sy.obj)

line level    source

   1          #include "mmi_feature.h"
   2          #if defined(__LOCK_FP_SY_SUPPORT__)
   3          #include "string.h"
   4          #include "dqiot_fp_sy.h"
   5          #include "delay.h"
   6          #include "dqiot_drv.h"
   7          #include "mcu02_uart.h"
   8          // #include <stdio.h>
   9          
  10          //unsigned long fp_pin_irq_mask;
  11          
  12          //fp_irq_handle_callback fp_callback_handle;
  13          //fp_uart_handle_callback fp_uart_handle = 0;
  14          //unsigned char fp_Mode = 0;
  15          //static unsigned char fp_temp_mode = 0;
  16          
  17          static unsigned char uart_rec_buff[20];
  18          
  19          //static FP_TYPE fp_flag = FP_NONE;
  20          static FP_COLOR_E Light_Color = FP_NONE_COLOR;
  21          //static unsigned char ps_start_flag = 0;
  22          
  23          extern unsigned char uart_get_buf[];
  24          extern unsigned char uart_getbuflen;
  25          
  26          //unsigned short  ReceiveInfo( unsigned char *rec_data);
  27          //void AS608_log(void);
  28          
  29          //void fp_set_irq_handle(fp_irq_handle_callback cb)
  30          //{
  31          //  fp_callback_handle = cb;
  32          //}
  33          
  34          //void fp_set_uart_handle(fp_uart_handle_callback cb)
  35          //{
  36          //  fp_uart_handle = cb;
  37          //}
  38          
  39          ///FP_TYPE fp_get_type(void)
  40          //{
  41          //  return fp_flag;
  42          
  43          //}
  44          
  45          //--------------------------------------------------------------------------------
  46          
  47          //static unsigned char uart_len=0;
  48          //static unsigned short uart_maxlen = 0;
  49          //static unsigned char uart_buff[25]={0};
  50          
  51          //static void UART_Callback(unsigned char send_data)
  52          //{
  53          //  send_data = 0;
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       04/07/2021 17:03:19 PAGE 2   

  54          //}
  55          
  56          //unsigned char fp_GetModeState(void)
  57          //{
  58          //  return fp_Mode;
  59          //}
  60          
  61          //void fp_SetModeState(unsigned char s)
  62          //{
  63          //  fp_Mode = s;
  64          
  65          //  if(s == 0)
  66          //    Light_Color = FP_NONE_COLOR;
  67          //}
  68          
  69          //static void PS_UART_Callback(unsigned char send_data)
  70          //{
  71          //  if(send_data == 0x55 )
  72          //  {
  73          //    ps_start_flag = 1;
  74          //  }
  75          //}
  76          
  77          //void FP_PowerOn(void)
  78          //{
  79          
  80          //}
  81          
  82          /**
  83            * @brief  AS608_USARTä¸²å£å‘æŒ‡çº¹æ¨¡å—ä¼ é€’æ•°æ® 
  84            * @param  data;ä¼ è¾“çš„æ•°æ®
  85            */
  86          void AS608_SendData(unsigned char send_data)
  87          {
  88   1        uart_tx_byte(UART0, send_data);
  89   1      }
  90          
  91          /**
  92            * @brief  AS608_USARTä¸²å£å‘æŒ‡çº¹æ¨¡å—å‘½ä»¤åŒ…å¤´æ ¼å¼ 
  93            * @param  æ— 
  94            */
  95          unsigned char AS608_PackHead(void)
  96          {
  97   1      
  98   1        //unsigned char delay_times = 30;
  99   1      
 100   1        //while(ps_start_flag==0&&delay_times>0)
 101   1        //{
 102   1        //  delay_times--;
 103   1        //}
 104   1        //if(ps_start_flag == 0)
 105   1        //{
 106   1        //  return 1;
 107   1        //}
 108   1        //else if(ps_start_flag == 1)
 109   1        //{
 110   1        //  uart_init_block();
 111   1        //  ps_start_flag = 2;
 112   1        //}
 113   1      
 114   1        dqiot_drv_uart0B_init();
 115   1        uart_getbuflen = 0;
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       04/07/2021 17:03:19 PAGE 3   

 116   1      
 117   1        /*åŒ…å¤´*/
 118   1        AS608_SendData(0xEF);
 119   1        AS608_SendData(0x01);
 120   1      
 121   1        /*æŒ‡çº¹æ¨¡å—åœ°å€*/
 122   1        AS608_SendData(AS608_Addr >> 24);
 123   1        AS608_SendData(AS608_Addr >> 16);
 124   1        AS608_SendData(AS608_Addr >> 8);
 125   1        AS608_SendData(AS608_Addr);
 126   1      
 127   1        return 0;
 128   1      }
 129          
 130          unsigned char AS608_PackHead2(void)
 131          {
 132   1      
 133   1        /*åŒ…å¤´*/
 134   1        AS608_SendData(0xEF);
 135   1        AS608_SendData(0x01);
 136   1      
 137   1        /*æŒ‡çº¹æ¨¡å—åœ°å€*/
 138   1        AS608_SendData(AS608_Addr >> 24);
 139   1        AS608_SendData(AS608_Addr >> 16);
 140   1        AS608_SendData(AS608_Addr >> 8);
 141   1        AS608_SendData(AS608_Addr);
 142   1      
 143   1        return 0;
 144   1      }
 145          
 146          /**
 147            * @brief  å‘é€åŒ…æ ‡è¯†
 148            * @param  flag:åŒ…æ ‡è¯†ä½
 149            * @retval æ— 
 150            */
 151          void SendFlag(unsigned char flag)
 152          {
 153   1        AS608_SendData(flag);
 154   1      }
 155          
 156          /**
 157            * @brief  å‘é€åŒ…é•¿åº¦
 158            * @param  length:åŒ…é•¿åº¦
 159            * @retval æ— 
 160            */
 161          void SendLength(unsigned short length)
 162          {
 163   1        AS608_SendData(length >> 8);
 164   1        AS608_SendData(length);
 165   1      }
 166          
 167          /**
 168            * @brief  å‘é€æŒ‡ä»¤ç 
 169            * @param  cmd;æŒ‡ä»¤ç 
 170            * @retval æ— 
 171            */
 172          void Sendcmd(unsigned char cmd)
 173          {
 174   1        AS608_SendData(cmd);
 175   1      }
 176          
 177          /**
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       04/07/2021 17:03:19 PAGE 4   

 178            * @brief  å‘é€æ ¡éªŒå’Œ
 179            * @param  check:æ£€æŸ¥ä½
 180            * @retval æ— 
 181            */
 182          void SendCheck(unsigned short check)
 183          {
 184   1        AS608_SendData(check >> 8);
 185   1        AS608_SendData(check);
 186   1      }
 187          
 188          /**
 189            * @brief  åˆ¤æ–­ä¸­æ–­æ¥æ”¶çš„æ•°ç»„æœ‰æ²¡æœ‰åº”ç­”åŒ…
 190            * @param  
 191            * waittimeä¸ºç­‰å¾…ä¸­æ–­æ¥æ”¶æ•°æ®çš„æ—¶é—´(å•ä½1ms)
 192            * lengthä¸ºåŒ…é•¿åº¦
 193            * @return æ•°æ®åŒ…ç¡®è®¤ç 
 194            * @note   1 failed
 195            * @see    none
 196            */
 197          static u8 JudgeStr(u16 waittime, u8 length)
 198          {
 199   1        u8 i = 0, j = 0;
 200   1        //u8 str[8];
 201   1        //str[0] = 0xEF;
 202   1        //str[1] = 0x01;
 203   1        //str[2] = AS608_Addr >> 24;
 204   1        //str[3] = AS608_Addr >> 16;
 205   1        //str[4] = AS608_Addr >> 8;
 206   1        //str[5] = AS608_Addr;
 207   1        //str[6] = 0x07;
 208   1      
 209   1        memset(uart_rec_buff, 0, sizeof(uart_rec_buff));
 210   1      
 211   1        while (--waittime)
 212   1        {
 213   2          delay_ms(1);
 214   2      
 215   2          /* æ¥æ”¶åˆ°ä¸€æ¬¡æ•°æ® */
 216   2          if (uart_getbuflen >= 9 + length)
 217   2          {
 218   3            /* å¯»æ‰¾0xEFä½ç½® */
 219   3            for (i = 0; i < uart_getbuflen; i++)
 220   3            {
 221   4              if (uart_get_buf[i] == 0xEF)
 222   4                break;
 223   4            }
 224   3      
 225   3            /* åˆ¤æ–­æ˜¯å¦ä¸ºåº”ç­”åŒ… */
 226   3            if (uart_get_buf[i] == 0xEF && uart_get_buf[i + 1] == 0x01 && uart_get_buf[i + 6] == 0x07 && ((uart_get
             -_buf[i + 7] << 8) + uart_get_buf[i + 8]) == length)
 227   3            {
 228   4              for (i; i < uart_getbuflen; i++)
 229   4              {
 230   5                uart_rec_buff[j] = uart_get_buf[i];
 231   5                j++;
 232   5              }
 233   4      
 234   4              // dqiot_drv_uart0A_init();
 235   4              // for (i = 0; i < uart_getbuflen - 1; i++)
 236   4              //  printf("uart_rec_buff[%d] is %d\n", (int)i, (int)uart_rec_buff[i]);
 237   4              // dqiot_drv_uart0B_init();
 238   4      
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       04/07/2021 17:03:19 PAGE 5   

 239   4              /* æ¸…ç©ºç¼“å­˜ */
 240   4              uart_getbuflen = 0;
 241   4      
 242   4              return uart_rec_buff[9];
 243   4            }
 244   3          }
 245   2        }
 246   1      
 247   1        return 1;
 248   1      }
 249          
 250          #if 0
              /**
                * @brief  ä»ç¼“å†²åŒºè¯»å‡ºç¡®è®¤ç 
                * @param  *i:è¿”å›å€¼ï¼ˆç¡®è®¤ç ï¼‰
                * @retval æ— 
                */
              unsigned char  ReturnFlag( unsigned char *i)
              { 
                *i = ReceiveInfo(uart_rec_buff);
                return *i;
              }
              
              unsigned char  ReceiveInfo( unsigned char *rec_data)
              {
                unsigned char *temp_data;
                unsigned short rev_length = 0;
                unsigned char error = 0;
                unsigned char a = 9;
              
                memset(uart_rec_buff,0,sizeof(uart_rec_buff));
              
                do
                {
                  //error = nrf_drv_uart_rx(rec_data,1);
                  //if(error == NRF_ERROR_INTERNAL)
                  //  return 0xFF;
                  if(rec_data[0] == 0xEF)
                    break;
                  if(a==0)
                    return 0xFF;
                }while(a--);
                
              
                rev_length = (rec_data[7]<<8)+rec_data[8];
                temp_data = rec_data+9;
              
                if(rev_length!=0)
                  ;//nrf_drv_uart_rx(temp_data,rev_length);
                else
                  return 0xFF;
              
                AS608_log();
                return temp_data[0];
              }
              #endif
 295          
 296          unsigned char PS_GetEcho(void)
 297          {
 298   1        AS608_PackHead2();
 299   1        SendFlag(0x01);
 300   1        SendLength(0x03);
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       04/07/2021 17:03:19 PAGE 6   

 301   1        Sendcmd(0x53); /*ç”Ÿæˆç‰¹å¾æŒ‡ä»¤*/
 302   1        SendCheck(0x57);
 303   1      
 304   1        //sure=ReturnFlag(&p);
 305   1        return JudgeStr(1000, 0x03);
 306   1      }
 307          
 308          /**
 309            * @brief  æ£€æµ‹ä¼ æ„Ÿå™¨ PS_CheckSensor
 310            * @param  none
 311            * @return ç¡®è®¤ç (æ­£å¸¸0x00/é”™è¯¯0x29)
 312            * @note   none
 313            * @see    none
 314            */
 315          unsigned char PS_CheckSensor(void)
 316          {
 317   1        if (AS608_PackHead() == 1)
 318   1          return 0xFF;
 319   1        SendFlag(0x01);
 320   1        SendLength(0x03);
 321   1        Sendcmd(0x36);
 322   1        SendCheck(0x01 + 0x03 + 0x36);
 323   1      
 324   1        return JudgeStr(1000, 0x03);
 325   1      }
 326          
 327          /**
 328            * @brief  æ£€æµ‹æ‰‹æŒ‡çŠ¶æ€ PS_CheckFinger
 329            * @param  none
 330            * @return ç¡®è®¤ç 
 331            * @note   none
 332            * @see    none
 333            */
 334          unsigned char PS_CheckFinger(void)
 335          {
 336   1        if (AS608_PackHead() == 1)
 337   1          return 0xFF;
 338   1        SendFlag(0x01);
 339   1        SendLength(0x03);
 340   1        Sendcmd(0x2a);
 341   1        SendCheck(0x01 + 0x03 + 0x2a);
 342   1      
 343   1        return JudgeStr(1000, 0x03);
 344   1      }
 345          
 346          //å½•å…¥å›¾åƒ PS_GetImage
 347          //åŠŸèƒ½:æ¢æµ‹æ‰‹æŒ‡ï¼Œæ¢æµ‹åˆ°åå½•å…¥æŒ‡çº¹å›¾åƒå­˜äºImageBufferã€‚
 348          //æ¨¡å—è¿”å›ç¡®è®¤å­—
 349          unsigned char PS_GetImage(void)
 350          {
 351   1        //delay_ms(300);
 352   1        if (AS608_PackHead() == 1)
 353   1          return 0xFF;
 354   1        SendFlag(0x01); /*å‘½ä»¤åŒ…æ ‡è¯†*/
 355   1        SendLength(0x03);
 356   1        Sendcmd(0x01); /*å½•æŒ‡çº¹æŒ‡ä»¤*/
 357   1        SendCheck(0x01 + 0x03 + 0x01);
 358   1      
 359   1        //nrf_delay_ms(50);        /*ç­‰å¾…æŒ‡çº¹è¯†åˆ«æ¨¡å—å¤„ç†æ•°æ®*/
 360   1      
 361   1        // sure = ReturnFlag(&p);
 362   1        return JudgeStr(1000, 0x03);
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       04/07/2021 17:03:19 PAGE 7   

 363   1      }
 364          
 365          //ç”Ÿæˆç‰¹å¾ PS_GenChar
 366          //åŠŸèƒ½:å°†ImageBufferä¸­çš„åŸå§‹å›¾åƒç”ŸæˆæŒ‡çº¹ç‰¹å¾æ–‡ä»¶å­˜äºCharBuffer1æˆ–CharBuffer2
 367          //å‚æ•°:BufferID --> charBuffer1:0x01  charBuffer1:0x02
 368          //æ¨¡å—è¿”å›ç¡®è®¤å­—
 369          unsigned char PS_GenChar(unsigned char BufferID)
 370          {
 371   1        if (AS608_PackHead() == 1)
 372   1          return 0xFF;
 373   1        SendFlag(0x01);
 374   1        SendLength(0x04);
 375   1        Sendcmd(0x02); /*ç”Ÿæˆç‰¹å¾æŒ‡ä»¤*/
 376   1        AS608_SendData(BufferID);
 377   1        SendCheck(0x01 + 0x04 + 0x02 + BufferID);
 378   1        return JudgeStr(1000, 0x03);
 379   1      }
 380          
 381          //ç²¾ç¡®æ¯”å¯¹ä¸¤æšæŒ‡çº¹ç‰¹å¾ PS_Match
 382          //åŠŸèƒ½:ç²¾ç¡®æ¯”å¯¹CharBuffer1 ä¸CharBuffer2 ä¸­çš„ç‰¹å¾æ–‡ä»¶
 383          //æ¨¡å—è¿”å›ç¡®è®¤å­—
 384          unsigned char PS_Match(void)
 385          {
 386   1        if (AS608_PackHead() == 1)
 387   1          return 0xFF;
 388   1        SendFlag(0x01);
 389   1        SendLength(0x03);
 390   1        Sendcmd(0x03); /*ç²¾ç¡®æ¯”å¯¹æŒ‡ä»¤*/
 391   1        SendCheck(0x01 + 0x03 + 0x03);
 392   1      
 393   1        // sure = ReturnFlag(&p);
 394   1        return JudgeStr(1000, 0x05);
 395   1      }
 396          //æœç´¢æŒ‡çº¹ PS_Search
 397          //åŠŸèƒ½:ä»¥CharBuffer1æˆ–CharBuffer2ä¸­çš„ç‰¹å¾æ–‡ä»¶æœç´¢æ•´ä¸ªæˆ–éƒ¨åˆ†æŒ‡çº¹åº“.è‹¥æœç´¢åˆ°ï¼Œåˆ™è¿
             -”å›é¡µç ã€‚
 398          //å‚æ•°:  BufferID @ref CharBuffer1  CharBuffer2
 399          //è¯´æ˜:  æ¨¡å—è¿”å›ï¿½?è®¤å­—ï¼Œé¡µç ï¼ˆç›¸é…æŒ‡çº¹æ¨¡æ¿ï¿½?
 400          unsigned char PS_Search(unsigned char BufferID, unsigned short StartPage, unsigned short PageNum, unsigned
             - short *p)
 401          {
 402   1        unsigned char sure;
 403   1        if (AS608_PackHead() == 1)
 404   1          return 0xFF;
 405   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 406   1        SendLength(0x08);
 407   1        Sendcmd(0x04);
 408   1        AS608_SendData(BufferID);
 409   1        AS608_SendData(StartPage >> 8);
 410   1        AS608_SendData(StartPage);
 411   1        AS608_SendData(PageNum >> 8);
 412   1        AS608_SendData(PageNum);
 413   1        SendCheck(0x01 + 0x08 + 0x04 + BufferID + (StartPage >> 8) + (unsigned char)StartPage + (PageNum >> 8) + 
             -(unsigned char)PageNum);
 414   1        sure = JudgeStr(1000, 0x07);
 415   1        *p = (uart_rec_buff[10] << 8) + uart_rec_buff[11];
 416   1        return sure;
 417   1      }
 418          
 419          //åˆå¹¶ç‰¹å¾ï¼ˆç”Ÿæˆæ¨¡æ¿ï¼‰PS_RegModel
 420          //åŠŸèƒ½:å°†CharBuffer1ä¸CharBuffer2ä¸­çš„ç‰¹å¾æ–‡ä»¶åˆå¹¶ç”Ÿæˆ æ¨¡æ¿,ç»“æœå­˜äºCharBuffer1ä¸CharB
             -uffer2
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       04/07/2021 17:03:19 PAGE 8   

 421          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
 422          unsigned char PS_RegModel(void)
 423          {
 424   1        if (AS608_PackHead() == 1)
 425   1          return 0xFF;
 426   1        SendFlag(0x01);
 427   1        SendLength(0x03);
 428   1        Sendcmd(0x05); /*åˆå¹¶ç‰¹å¾æŒ‡ä»¤*/
 429   1        SendCheck(0x01 + 0x03 + 0x05);
 430   1      
 431   1        // sure = ReturnFlag(&p);
 432   1        return JudgeStr(1000, 0x03);
 433   1      }
 434          
 435          //å‚¨å­˜æ¨¡æ¿ PS_StoreChar
 436          //åŠŸèƒ½:å°† CharBuffer1 æˆ– CharBuffer2 ä¸­çš„æ¨¡æ¿æ–‡ä»¶å­˜åˆ° PageID å·flashæ•°æ®åº“ä½ç½®ã€‚
 437          //å‚æ•°:  BufferID @ref charBuffer1:0x01 charBuffer1:0x02
 438          //       PageIDï¼ˆæŒ‡çº¹åº“ä½ç½®å·ï¼‰
 439          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
 440          unsigned char PS_StoreChar(unsigned char BufferID, unsigned short PageID)
 441          {
 442   1        if (AS608_PackHead() == 1)
 443   1          return 0xFF;
 444   1        SendFlag(0x01);
 445   1        SendLength(0x06);
 446   1        Sendcmd(0x06); /*å­˜å‚¨æ¨¡æ¿æŒ‡ä»¤*/
 447   1        AS608_SendData(BufferID);
 448   1        AS608_SendData(PageID >> 8);
 449   1        AS608_SendData(PageID);
 450   1        SendCheck(0x01 + 0x06 + 0x06 + BufferID + (PageID >> 8) + (unsigned char)PageID);
 451   1      
 452   1        // sure = ReturnFlag(&p);
 453   1        return JudgeStr(1000, 0x03);
 454   1      }
 455          
 456          //åˆ é™¤æ¨¡æ¿ PS_DeletChar
 457          //åŠŸèƒ½:  åˆ é™¤flashæ•°æ®åº“ä¸­æŒ‡å®šIDå·å¼€å§‹çš„Nä¸ªæŒ‡çº¹æ¨¡æ¿
 458          //å‚æ•°:  PageID(æŒ‡çº¹åº“æ¨¡æ¿å·)ï¼ŒNåˆ é™¤çš„æ¨¡æ¿ä¸ªæ•°ã€‚
 459          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
 460          unsigned char PS_DeletChar(unsigned short PageID, unsigned short N)
 461          {
 462   1        if (AS608_PackHead() == 1)
 463   1          return 0xFF;
 464   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 465   1        SendLength(0x07);
 466   1        Sendcmd(0x0C); /*åˆ é™¤æŒ‡å®šæŒ‡çº¹æ¨¡æ¿æŒ‡ä»¤*/
 467   1        AS608_SendData(PageID >> 8);
 468   1        AS608_SendData(PageID);
 469   1        AS608_SendData(N >> 8);
 470   1        AS608_SendData(N);
 471   1        SendCheck(0x01 + 0x07 + 0x0C + (PageID >> 8) + (unsigned char)PageID + (N >> 8) + (unsigned char)N);
 472   1      
 473   1        //AS608_DELAY_MS(400);
 474   1      
 475   1        // sure = ReturnFlag(&p);
 476   1        return JudgeStr(1000, 0x03);
 477   1      }
 478          
 479          //é«˜é€Ÿæœç´¢PS_HighSpeedSearch
 480          //åŠŸèƒ½ï¼šä»¥ CharBuffer1æˆ–CharBuffer2ä¸­çš„ç‰¹å¾æ–‡ä»¶é«˜é€Ÿæœç´¢æ•´ä¸ªæˆ–éƒ¨åˆ†æŒ‡çº¹åº“ã€‚
 481          //      è‹¥æœç´¢åˆ°ï¼Œåˆ™è¿”å›é¡µç ,è¯¥æŒ‡ä»¤å¯¹äºçš„ç¡®å­˜åœ¨äºæŒ‡çº¹åº“ä¸­ ï¼Œä¸”ç™»å½•æ—¶è´¨é‡
 482          //      å¾ˆå¥½çš„æŒ‡çº¹ï¼Œä¼šå¾ˆå¿«ç»™å‡ºæœç´¢ç»“æœã€‚
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       04/07/2021 17:03:19 PAGE 9   

 483          //å‚æ•°:  BufferIDï¼Œ StartPage(èµ·å§‹é¡µ)ï¼ŒPageNumï¼ˆé¡µæ•°ï¼‰
 484          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—+é¡µç ï¼ˆç›¸é…æŒ‡çº¹æ¨¡æ¿ï¼‰
 485          unsigned char PS_HighSpeedSearch(unsigned char BufferID, unsigned short StartPage, unsigned short PageNum,
             - unsigned short *p)
 486          {
 487   1        unsigned char ensure;
 488   1      
 489   1        if (AS608_PackHead() == 1)
 490   1          return 0xFF;
 491   1        SendFlag(0x01);
 492   1        SendLength(0x08);
 493   1        Sendcmd(0x1b); /*é«˜é€Ÿæœç´¢æŒ‡çº¹åº“æŒ‡ä»¤*/
 494   1        AS608_SendData(BufferID);
 495   1        AS608_SendData(StartPage >> 8);
 496   1        AS608_SendData(StartPage);
 497   1        AS608_SendData(PageNum >> 8);
 498   1        AS608_SendData(PageNum);
 499   1        SendCheck(0x01 + 0x08 + 0x1b + BufferID + (StartPage >> 8) + (unsigned char)StartPage + (PageNum >> 8) + 
             -(unsigned char)PageNum);
 500   1      
 501   1        // ensure = ReturnFlag(&rc);
 502   1        ensure = JudgeStr(1000, 0x07);
 503   1      
 504   1        *p = (uart_rec_buff[10] << 8) + uart_rec_buff[11];
 505   1      
 506   1        return ensure;
 507   1      }
 508          
 509          //æ¸…ç©ºæŒ‡çº¹åº“ PS_Empty
 510          //åŠŸèƒ½:  åˆ é™¤flashæ•°æ®åº“ä¸­æ‰€æœ‰æŒ‡çº¹æ¨¡æ¿
 511          //å‚æ•°:  æ— 
 512          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
 513          unsigned char PS_Empty(void)
 514          {
 515   1        if (AS608_PackHead() == 1)
 516   1          return 0xFF;
 517   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 518   1        SendLength(0x03);
 519   1        Sendcmd(0x0D);
 520   1        SendCheck(0x01 + 0x03 + 0x0D);
 521   1      
 522   1        // sure = ReturnFlag(&p);
 523   1        return JudgeStr(1000, 0x03);
 524   1      }
 525          
 526          #if 0
              /**
                * @brief  æ£€æŸ¥STM32ä¸æŒ‡çº¹æ¨¡å—çš„é€šä¿¡è¿æ¥
                * @param  PS_AddræŒ‡çº¹æ¨¡å—åœ°å€
                * @retval è¿”å›å€¼0é€šè®¯æˆåŠŸ;1è¡¨ç¤ºé€šè®¯ä¸æˆåŠŸ
                */
              unsigned char PS_Connect(unsigned long *PS_Addr)
              {
                PS_Addr = 0;
                if(AS608_PackHead()==1)
                  return 0xFF;
                AS608_SendData(0X01);
                AS608_SendData(0X00);
                AS608_SendData(0X00);
                return 1;   
              }
              
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       04/07/2021 17:03:19 PAGE 10  

              //å†™ç³»ç»Ÿå¯„å­˜å™¨ PS_WriteReg
              //åŠŸèƒ½:  å†™æ¨¡å—å¯„å­˜å™¨
              //å‚æ•°:  å¯„å­˜å™¨åºå·RegNum:4\5\6
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
              unsigned char PS_WriteReg(unsigned char RegNum, unsigned char DATA)
              {
                unsigned short temp;
                unsigned short sure,p=0;
              
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//é›æˆ’æŠ¤é–å‘®çˆ£ç’‡
                SendLength(0x05);
                Sendcmd(0x0E);
                AS608_SendData(RegNum);
                AS608_SendData(DATA);
                temp = RegNum+DATA+0x01+0x05+0x0E;
                SendCheck(temp);
                sure=ReturnFlag(&p);
                return sure;
              }
              //è¯»ç³»ç»ŸåŸºæœ¬å‚æ•° PS_ReadSysPara
              //åŠŸèƒ½:  è¯»å–æ¨¡å—çš„åŸºæœ¬å‚æ•°ï¼ˆæ³¢ç‰¹ç‡ï¼ŒåŒ…å¤§å°ç­‰)
              //å‚æ•°:  æ— 
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­— + åŸºæœ¬å‚æ•°ï¼ˆ16bytesï¼‰
              unsigned char PS_ReadSysPara(void)
              {
                unsigned short temp;
                unsigned char  ensure;
                unsigned char  *send_data;
                unsigned short p=0;
                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//é›æˆ’æŠ¤é–å‘®çˆ£ç’‡
                SendLength(0x03);
                Sendcmd(0x0F);
                temp = 0x01+0x03+0x0F;
                SendCheck(temp);
                ensure=ReturnFlag(&p);
                if(send_data)
                {
              
                }   
                else
                  ensure=0xff;
                if(ensure==0x00)
                {
              
                }
                return ensure;
              }
              //è®¾ç½®æ¨¡å—åœ°å€ PS_SetAddr
              //åŠŸèƒ½:  è®¾ç½®æ¨¡å—åœ°å€
              //å‚æ•°:  PS_addr
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
              unsigned char PS_SetAddr(unsigned long PS_addr)
              {
                unsigned short temp;
                unsigned char  ensure;
              
                if(AS608_PackHead()==1)
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       04/07/2021 17:03:19 PAGE 11  

                  return 0xFF;
                SendFlag(0x01);//å‘½ä»¤åŒ…æ ‡è¯†
                SendLength(0x07);
                Sendcmd(0x15);
                AS608_SendData(PS_addr>>24);
                AS608_SendData(PS_addr>>16);
                AS608_SendData(PS_addr>>8);
                AS608_SendData(PS_addr);
                temp = 0x01+0x07+0x15
                +(unsigned char)(PS_addr>>24)+(unsigned char)(PS_addr>>16)
                +(unsigned char)(PS_addr>>8) +(unsigned char)PS_addr;       
                SendCheck(temp);
              
                return ensure;
              }
              //åŠŸèƒ½ï¼š æ¨¡å—å†…éƒ¨ä¸ºç”¨æˆ·å¼€è¾Ÿäº†256bytesçš„FLASHç©ºé—´ç”¨äºå­˜ç”¨æˆ·è®°äº‹æœ¬,
              //  è¯¥è®°äº‹æœ¬é€»è¾‘ä¸Šè¢«åˆ†æˆ 16 ä¸ªé¡µã€‚
              //å‚æ•°:  NotePageNum(0~15),Byte32(è¦å†™å…¥å†…å®¹ï¼Œ32ä¸ªå­—èŠ‚)
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
              unsigned char PS_WriteNotepad(unsigned char NotePageNum,unsigned char *Byte32)
              {
                unsigned short temp;
                unsigned char  ensure,i;
                
                *Byte32 = 0;
                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
                SendLength(36);
                Sendcmd(0x18);
                AS608_SendData(NotePageNum);
                for(i=0;i<32;i++)
                {
                  AS608_SendData(Byte32[i]);
                  temp += Byte32[i];
                }
                temp =0x01+36+0x18+NotePageNum+temp;
                SendCheck(temp);
              
                return ensure;
              }
              //è¯»è®°äº‹PS_ReadNotepad
              //åŠŸèƒ½ï¼š  è¯»å–FLASHç”¨æˆ·åŒºçš„128bytesæ•°æ®
              //å‚æ•°:  NotePageNum(0~15)
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—+ç”¨æˆ·ä¿¡æ¯
              unsigned char PS_ReadNotepad(unsigned char NotePageNum,unsigned char *Byte32)
              {
                unsigned short temp;
                unsigned char  ensure;
                
                *Byte32 = 0;
                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//å‘½ä»¤åŒ…æ ‡è¯†
                SendLength(0x04);
                Sendcmd(0x19);
                AS608_SendData(NotePageNum);
                temp = 0x01+0x04+0x19+NotePageNum;
                SendCheck(temp);
              
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       04/07/2021 17:03:19 PAGE 12  

                return ensure;
              }
              #endif
 670          
 671          //è¯»æœ‰æ•ˆæ¨¡æ¿ä¸ªæ•° PS_ValidTempleteNum
 672          //åŠŸèƒ½ï¼šè¯»æœ‰æ•ˆæ¨¡æ¿ä¸ªæ•°
 673          //å‚æ•°: æ— 
 674          //è¯´æ˜: æ¨¡å—è¿”å›ç¡®è®¤å­—+æœ‰æ•ˆæ¨¡æ¿ä¸ªæ•°ValidN
 675          unsigned char PS_ValidTempleteNum(unsigned short *ValidN)
 676          {
 677   1        unsigned char ensure;
 678   1      
 679   1        if (AS608_PackHead() == 1)
 680   1          return 0xFF;
 681   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 682   1        SendLength(0x03);
 683   1        Sendcmd(0x1d);
 684   1        SendCheck(0x01 + 0x03 + 0x1d);
 685   1      
 686   1        // ensure = ReturnFlag(&p);
 687   1        ensure = JudgeStr(1000, 0x05);
 688   1      
 689   1        *ValidN = (uart_rec_buff[10] << 8) + uart_rec_buff[11];
 690   1      
 691   1        return ensure;
 692   1      }
 693          
 694          unsigned char PS_AutoEnRoll(unsigned short id, unsigned char num, unsigned short param)
 695          {
 696   1        if (AS608_PackHead() == 1)
 697   1          return 0xFF;
 698   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 699   1        SendLength(0x08);
 700   1        Sendcmd(0x31);
 701   1        AS608_SendData(id >> 8);
 702   1        AS608_SendData(id & 0xFF);
 703   1        AS608_SendData(num);
 704   1        AS608_SendData(param >> 8);
 705   1        AS608_SendData(param & 0xFF);
 706   1        SendCheck(0x01 + 0x08 + 0x31 + (id >> 8) + (id & 0xFF) + num + (param >> 8) + (param & 0xFF));
 707   1      
 708   1        return 0;
 709   1      }
 710          
 711          //è‡ªåŠ¨éªŒè¯æŒ‡çº¹ PS_AutoIdentify
 712          //åŠŸèƒ½ï¼š
 713          //1.è‡ªåŠ¨é‡‡é›†æŒ‡çº¹ï¼Œåœ¨æŒ‡çº¹åº“ä¸­æœç´¢ç›®æ ‡æ¨¡æ¿å¹¶è¿”å›æœç´¢ç»“æœã€‚
 714          //2.å¦‚æœç›®æ ‡æ¨¡æ¿åŒå½“å‰é‡‡é›†çš„æŒ‡çº¹æ¯”å¯¹å¾—åˆ†å¤§äºæœ€é«˜é˜€å€¼ï¼Œå¹¶ä¸”ç›®æ ‡æ¨¡æ¿ä¸ºä¸å®Œ
             -æ•´ç‰¹å¾åˆ™ä»¥é‡‡é›†çš„ç‰¹å¾æ›´æ–°ç›®æ ‡æ¨¡æ¿çš„ç©ºç™½åŒºåŸŸã€‚
 715          //å‚æ•°: æ— 
 716          //è¯´æ˜: æ¨¡å—è¿”å›ç¡®è®¤å­—+é¡µç ï¼ˆç›¸é…æŒ‡çº¹æ¨¡æ¿ï¼‰
 717          unsigned char PS_AutoIdentify(unsigned short id, unsigned char level, unsigned short param)
 718          {
 719   1        if (AS608_PackHead() == 1)
 720   1          return 0xFF;
 721   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 722   1        SendLength(0x08);
 723   1        Sendcmd(0x32);
 724   1        AS608_SendData(level);
 725   1        AS608_SendData(id >> 8);
 726   1        AS608_SendData(id & 0xFF);
 727   1        AS608_SendData(param >> 8);
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       04/07/2021 17:03:19 PAGE 13  

 728   1        AS608_SendData(param & 0xFF);
 729   1        SendCheck(0x01 + 0x08 + 0x32 + (id >> 8) + (id & 0xFF) + level + (param >> 8) + (param & 0xFF));
 730   1      
 731   1        return 0;
 732   1      }
 733          
 734          //ä¸AS608æ¡æ‰‹ PS_HandShake
 735          //å‚æ•°: PS_Addråœ°å€æŒ‡é’ˆ
 736          //è¯´æ˜: æ¨¡å—è¿”æ–°åœ°å€ï¼ˆæ­£ç¡®åœ°å€ï¼‰
 737          unsigned char PS_HandShake(unsigned long *PS_Addr)
 738          {
 739   1        *PS_Addr = 0;
 740   1      
 741   1        if (AS608_PackHead() == 1)
 742   1          return 0xFF;
 743   1        SendFlag(0x01);
 744   1        SendLength(0x03);
 745   1        Sendcmd(0x53);
 746   1        SendCheck(0x57);
 747   1      
 748   1        return JudgeStr(1000, 0x03);
 749   1      }
 750          
 751          unsigned char PS_Reset(void)
 752          {
 753   1        return 0;
 754   1      }
 755          
 756          unsigned char PS_Sleep(void)
 757          {
 758   1        if (AS608_PackHead() == 1)
 759   1          return 0xFF;
 760   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 761   1        SendLength(0x03);
 762   1        Sendcmd(0x60);
 763   1        SendCheck(0x01 + 0x03 + 0x60);
 764   1        return 0;
 765   1      }
 766          
 767          //void AS608_log(void)
 768          //{
 769          //  unsigned char i =0;
 770          ////  NRF_LOG_PRINTF_DEBUG("receive :");
 771          //  for(i=0;i<25;i++)
 772          //  {
 773          //    NRF_LOG_PRINTF_DEBUG("%2x ",as608_rec_buff[i]);
 774          //  }
 775          //  NRF_LOG_PRINTF_DEBUG("\n");
 776          //}
 777          
 778          void FP_Light(FP_COLOR_E light_id)
 779          {
 780   1        //  if(fp_flag == FP_LT5X)
 781   1        //  {
 782   1        //#ifdef __FP_LT5X_LIGHT_SUPPORT__
 783   1        unsigned short temp;
 784   1        unsigned char sure = 0; //,p=0;
 785   1      
 786   1        if (light_id == Light_Color)
 787   1          return;
 788   1      
 789   1        if (AS608_PackHead() == 1)
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       04/07/2021 17:03:19 PAGE 14  

 790   1          return;
 791   1        SendFlag(0x01);
 792   1        SendLength(0x07);
 793   1        Sendcmd(0x41);
 794   1        switch (light_id)
 795   1        {
 796   2        case FP_BLUE:
 797   2          AS608_SendData(0x01);
 798   2          AS608_SendData(0x01);
 799   2          AS608_SendData(0x00);
 800   2          AS608_SendData(0x50);
 801   2          temp = 0x01 + 0x07 + 0x41 + 0x02 + 0x50;
 802   2          break;
 803   2        case FP_GREEN:
 804   2          AS608_SendData(0x01);
 805   2          AS608_SendData(0x02);
 806   2          AS608_SendData(0x02);
 807   2          AS608_SendData(0);
 808   2          temp = 0x01 + 0x07 + 0x41 + 0x05 + 0;
 809   2          break;
 810   2        case FP_RED:
 811   2          AS608_SendData(0x01);
 812   2          AS608_SendData(0x04);
 813   2          AS608_SendData(0x04);
 814   2          AS608_SendData(0);
 815   2          temp = 0x01 + 0x07 + 0x41 + 0x09 + 0;
 816   2          break;
 817   2        case FP_NONE_COLOR:
 818   2          AS608_SendData(0x04);
 819   2          AS608_SendData(0x00);
 820   2          AS608_SendData(0x00);
 821   2          AS608_SendData(0xC8);
 822   2          temp = 0x01 + 0x07 + 0x41 + 0x04 + 0xC8;
 823   2          break;
 824   2        }
 825   1        SendCheck(temp);
 826   1      
 827   1        // sure=ReturnFlag(&p);
 828   1        sure = JudgeStr(1000, 0x03);
 829   1        //#endif
 830   1        Light_Color = light_id;
 831   1      
 832   1        //  }
 833   1      }
 834          
 835          FP_COLOR_E FP_Get_Light(void)
 836          {
 837   1        return Light_Color;
 838   1      }
 839          
 840          unsigned char FP_Get_Start_Flag(void)
 841          {
 842   1        if (uart_getbuflen > 0)
 843   1        {
 844   2          unsigned char i;
 845   2      
 846   2          for (i = 0; i < uart_getbuflen; i++)
 847   2          {
 848   3            if (uart_get_buf[i] == 0x55)
 849   3            {
 850   4              uart_getbuflen = 0;
 851   4              return 1;
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       04/07/2021 17:03:19 PAGE 15  

 852   4            }
 853   3          }
 854   2        }
 855   1        return 0;
 856   1      }
 857          
 858          #endif //__PREIPHERAL_FP_LT5X_SUPPORT__


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2038    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     25      54
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
