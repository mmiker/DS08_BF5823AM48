C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       02/19/2021 17:40:22 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DQIOT_FP_SY
OBJECT MODULE PLACED IN .\output\dqiot_fp_sy.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE source\dqiot_fp_sy.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\includ
                    -e;.\Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd
                    -_rfid;.\mmi_inc) DEBUG PRINT(.\list\dqiot_fp_sy.lst) TABS(2) OBJECT(.\output\dqiot_fp_sy.obj)

line level    source

   1          
   2          //#if defined (__PREIPHERAL_FP_SY_SUPPORT__)
   3          //#include "string.h"
   4          #include "dqiot_fp_sy.h"
   5          #include "delay.h"
   6          #include "dqiot_drv.h"
   7          #include "mcu02_uart.h"
   8          
   9          //unsigned long fp_pin_irq_mask;
  10          
  11          //fp_irq_handle_callback fp_callback_handle;
  12          //fp_uart_handle_callback fp_uart_handle = 0;
  13          //unsigned char fp_Mode = 0;
  14          //static unsigned char fp_temp_mode = 0;
  15          
  16          static unsigned char uart_rec_buff[20];
  17          
  18          //static FP_TYPE fp_flag = FP_NONE;
  19          static FP_COLOR_E Light_Color = FP_NONE_COLOR;
  20          //static unsigned char ps_start_flag = 0;
  21          
  22          extern unsigned char uart_get_buf[];
  23          extern unsigned char uart_getbuflen;
  24          
  25          //unsigned short  ReceiveInfo( unsigned char *rec_data);
  26          //void AS608_log(void);
  27          
  28          //void fp_set_irq_handle(fp_irq_handle_callback cb)
  29          //{
  30          //  fp_callback_handle = cb;
  31          //}
  32          
  33          //void fp_set_uart_handle(fp_uart_handle_callback cb)
  34          //{
  35          //  fp_uart_handle = cb;
  36          //}
  37          
  38          ///FP_TYPE fp_get_type(void)
  39          //{
  40          //  return fp_flag;
  41          
  42          //}
  43          
  44          //--------------------------------------------------------------------------------
  45          
  46          //static unsigned char uart_len=0;
  47          //static unsigned short uart_maxlen = 0;
  48          //static unsigned char uart_buff[25]={0};
  49          
  50          //static void UART_Callback(unsigned char send_data)
  51          //{
  52          //  send_data = 0;
  53          //}
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       02/19/2021 17:40:22 PAGE 2   

  54          
  55          //unsigned char fp_GetModeState(void)
  56          //{
  57          //  return fp_Mode;
  58          //}
  59          
  60          //void fp_SetModeState(unsigned char s)
  61          //{
  62          //  fp_Mode = s;
  63          
  64          //  if(s == 0)
  65          //    Light_Color = FP_NONE_COLOR;
  66          //}
  67          
  68          //static void PS_UART_Callback(unsigned char send_data)
  69          //{
  70          //  if(send_data == 0x55 )
  71          //  {
  72          //    ps_start_flag = 1;
  73          //  }
  74          //}
  75          
  76          //void FP_PowerOn(void)
  77          //{
  78          
  79          //}
  80          
  81          /**
  82            * @brief  AS608_USART串口向指纹模块传递数据 
  83            * @param  data;传输的数据
  84            */
  85          void AS608_SendData(unsigned char send_data)
  86          {
  87   1        uart_tx_byte(UART0, send_data);
  88   1      }
  89          
  90          /**
  91            * @brief  AS608_USART串口向指纹模块命令包头格式 
  92            * @param  无
  93            */
  94          unsigned char AS608_PackHead(void)
  95          {
  96   1      
  97   1        //unsigned char delay_times = 30;
  98   1      
  99   1        //while(ps_start_flag==0&&delay_times>0)
 100   1        //{
 101   1        //  delay_times--;
 102   1        //}
 103   1        //if(ps_start_flag == 0)
 104   1        //{
 105   1        //  return 1;
 106   1        //}
 107   1        //else if(ps_start_flag == 1)
 108   1        //{
 109   1        //  uart_init_block();
 110   1        //  ps_start_flag = 2;
 111   1        //}
 112   1      
 113   1        /*包头 SendHead*/
 114   1        AS608_SendData(0xEF);
 115   1        AS608_SendData(0x01);
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       02/19/2021 17:40:22 PAGE 3   

 116   1      
 117   1        /*指纹模块地址 SendAddr*/
 118   1        AS608_SendData(AS608_Addr >> 24);
 119   1        AS608_SendData(AS608_Addr >> 16);
 120   1        AS608_SendData(AS608_Addr >> 8);
 121   1        AS608_SendData(AS608_Addr);
 122   1      
 123   1        return 0;
 124   1      }
 125          
 126          unsigned char AS608_PackHead2(void)
 127          {
 128   1      
 129   1        /*包头 SendHead*/
 130   1        AS608_SendData(0xEF);
 131   1        AS608_SendData(0x01);
 132   1      
 133   1        /*指纹模块地址*/
 134   1        AS608_SendData(AS608_Addr >> 24);
 135   1        AS608_SendData(AS608_Addr >> 16);
 136   1        AS608_SendData(AS608_Addr >> 8);
 137   1        AS608_SendData(AS608_Addr);
 138   1      
 139   1        return 0;
 140   1      }
 141          
 142          /**
 143            * @brief  发送包标识
 144            * @param  flag:包标标志
 145            * @retval 无
 146            */
 147          void SendFlag(unsigned char flag)
 148          {
 149   1        AS608_SendData(flag);
 150   1      }
 151          
 152          /**
 153            * @brief  发送包长度
 154            * @param  length:包长度
 155            * @retval 无
 156            */
 157          void SendLength(unsigned short length)
 158          {
 159   1        AS608_SendData(length >> 8);
 160   1        AS608_SendData(length);
 161   1      }
 162          
 163          /**
 164            * @brief  发送指令码
 165            * @param  cmd;指令码
 166            * @retval 无
 167            */
 168          void Sendcmd(unsigned char cmd)
 169          {
 170   1        AS608_SendData(cmd);
 171   1      }
 172          
 173          /**
 174            * @brief  发送校验和
 175            * @param  check:检查位
 176            * @retval 无
 177            */
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       02/19/2021 17:40:22 PAGE 4   

 178          void SendCheck(unsigned short check)
 179          {
 180   1        AS608_SendData(check >> 8);
 181   1        AS608_SendData(check);
 182   1      }
 183          
 184          /**
 185            * @brief  判断中断接收的数组有没有应答包
 186            * @param  
 187            * waittime为等待中断接收数据的时间(单位1ms)
 188            * length为包长度
 189            * @return 数据包确认码
 190            * @note   1 failed
 191            * @see    none
 192            */
 193          static u8 JudgeStr(u16 waittime, u8 length)
 194          {
 195   1        u8 getdata;
 196   1        u8 i = 0, j = 0;
 197   1        //u8 str[8];
 198   1        //str[0] = 0xEF;
 199   1        //str[1] = 0x01;
 200   1        //str[2] = AS608_Addr >> 24;
 201   1        //str[3] = AS608_Addr >> 16;
 202   1        //str[4] = AS608_Addr >> 8;
 203   1        //str[5] = AS608_Addr;
 204   1        //str[6] = 0x07;
 205   1      
 206   1        while (--waittime)
 207   1        {
 208   2          delay_ms(1);
 209   2      
 210   2          /* 接收到一次数据 */
 211   2          if (uart_getbuflen >= 9 + length)
 212   2          {
 213   3            /* 寻找0xEF位置 */
 214   3            for (i = 0; i < uart_getbuflen; i++)
 215   3            {
 216   4              if (uart_get_buf[i] == 0xEF)
 217   4                break;
 218   4            }
 219   3      
 220   3            /* 判断是否为应答包 */
 221   3            if (uart_get_buf[i] == 0xEF && uart_get_buf[i + 1] == 0x01 && uart_get_buf[i + 6] == 0x07 && ((uart_get
             -_buf[i + 7] << 8) + uart_get_buf[i + 8]) == length)
 222   3            {
 223   4              for (i; i < uart_getbuflen; i++)
 224   4              {
 225   5                uart_rec_buff[j] = uart_get_buf[i];
 226   5                j++;
 227   5              }
 228   4              getdata = uart_rec_buff[9]; //确认码
 229   4      
 230   4              /* 清空缓存 */
 231   4              uart_getbuflen = 0;
 232   4      
 233   4              return getdata;
 234   4            }
 235   3          }
 236   2        }
 237   1      
 238   1        return 1;
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       02/19/2021 17:40:22 PAGE 5   

 239   1      }
 240          
 241          #if 0
              /**
                * @brief  从缓冲区读出确认码
                * @param  *i:返回值（确认码）
                * @retval 无
                */
              unsigned char  ReturnFlag( unsigned char *i)
              { 
                *i = ReceiveInfo(uart_rec_buff);
                return *i;
              }
              
              unsigned char  ReceiveInfo( unsigned char *rec_data)
              {
                unsigned char *temp_data;
                unsigned short rev_length = 0;
                unsigned char error = 0;
                unsigned char a = 9;
              
                memset(uart_rec_buff,0,sizeof(uart_rec_buff));
              
                do
                {
                  //error = nrf_drv_uart_rx(rec_data,1);
                  //if(error == NRF_ERROR_INTERNAL)
                  //  return 0xFF;
                  if(rec_data[0] == 0xEF)
                    break;
                  if(a==0)
                    return 0xFF;
                }while(a--);
                
              
                rev_length = (rec_data[7]<<8)+rec_data[8];
                temp_data = rec_data+9;
              
                if(rev_length!=0)
                  ;//nrf_drv_uart_rx(temp_data,rev_length);
                else
                  return 0xFF;
              
                AS608_log();
                return temp_data[0];
              }
              #endif
 286          
 287          unsigned char PS_GetEcho(void)
 288          {
 289   1        unsigned char sure; //,p=0;
 290   1      
 291   1        AS608_PackHead2();
 292   1        SendFlag(0x01);
 293   1        SendLength(0x03);
 294   1        Sendcmd(0x53); /*生成特征指令*/
 295   1        SendCheck(0x57);
 296   1      
 297   1        //sure=ReturnFlag(&p);
 298   1        sure = JudgeStr(1000, 0x03);
 299   1      
 300   1        return sure;
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       02/19/2021 17:40:22 PAGE 6   

 301   1      }
 302          
 303          //录入图像 PS_GetImage
 304          //功能:探测手指，探测到后录入指纹图像存于ImageBuffer。
 305          //模块返回确认字
 306          unsigned char PS_GetImage(void)
 307          {
 308   1        unsigned short temp;
 309   1        unsigned char sure; //,p=0;
 310   1        /* 清空缓存 */
 311   1        uart_getbuflen = 0;
 312   1      
 313   1        //delay_ms(300);
 314   1        if (AS608_PackHead() == 1)
 315   1          return 0xFF;
 316   1        SendFlag(0x01); /*命令包标识*/
 317   1        SendLength(0x03);
 318   1        Sendcmd(0x01); /*录指纹指令*/
 319   1        temp = 0x01 + 0x03 + 0x01;
 320   1        SendCheck(temp);
 321   1      
 322   1        // nrf_delay_ms(50); /*等待指纹识别模块处理数据*/
 323   1      
 324   1        // sure = ReturnFlag(&p);
 325   1        sure = JudgeStr(1000, 0x03);
 326   1      
 327   1        return sure;
 328   1      }
 329          
 330          //生成特征 PS_GenChar
 331          //功能:将ImageBuffer中的原始图像生成指纹特征文件存于CharBuffer1或CharBuffer2
 332          //参数:BufferID --> charBuffer1:0x01  charBuffer1:0x02
 333          //模块返回确认字
 334          unsigned char PS_GenChar(unsigned char BufferID)
 335          {
 336   1        unsigned short temp;
 337   1        unsigned char sure; //,p=0;
 338   1      
 339   1        if (AS608_PackHead() == 1)
 340   1          return 0xFF;
 341   1        SendFlag(0x01);
 342   1        SendLength(0x04);
 343   1        Sendcmd(0x02); /*生成特征指令*/
 344   1        AS608_SendData(BufferID);
 345   1        temp = 0x01 + 0x04 + 0x02 + BufferID;
 346   1        SendCheck(temp);
 347   1        //  mmi_dq_log_wakeup_count();
 348   1        // sure = ReturnFlag(&p);
 349   1        sure = JudgeStr(1000, 0x03);
 350   1      
 351   1        return sure;
 352   1      }
 353          
 354          //精确比对两枚指纹特征 PS_Match
 355          //功能:精确比对CharBuffer1 与CharBuffer2 中的特征文件
 356          //模块返回确认字
 357          unsigned char PS_Match(void)
 358          {
 359   1        unsigned short temp;
 360   1        unsigned char sure; //,p=0;
 361   1      
 362   1        if (AS608_PackHead() == 1)
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       02/19/2021 17:40:22 PAGE 7   

 363   1          return 0xFF;
 364   1        SendFlag(0x01);
 365   1        SendLength(0x03);
 366   1        Sendcmd(0x03); /*精确比对指令*/
 367   1        temp = 0x01 + 0x03 + 0x03;
 368   1        SendCheck(temp);
 369   1      
 370   1        // sure = ReturnFlag(&p);
 371   1        sure = JudgeStr(1000, 0x05);
 372   1      
 373   1        return sure;
 374   1      }
 375          //搜索指纹 PS_Search
 376          //功能:以CharBuffer1或CharBuffer2中的特征文件搜索整个或部分指纹库.若搜索到，则返回页码。
 377          //参数:  BufferID @ref CharBuffer1  CharBuffer2
 378          //说明:  模块返回确认字，页码（相配指纹模板）
 379          unsigned char PS_Search(unsigned char BufferID, unsigned short StartPage, unsigned short PageNum, void *p)
 380          {
 381   1        unsigned short temp;
 382   1        unsigned char ensure;
 383   1        //  QUEUE_DATA_TYPE   *rx_data;
 384   1      
 385   1        p = 0;
 386   1      
 387   1        if (AS608_PackHead() == 1)
 388   1          return 0xFF;
 389   1        SendFlag(0x01); //命令包标识
 390   1        SendLength(0x08);
 391   1        Sendcmd(0x04);
 392   1        AS608_SendData(BufferID);
 393   1        AS608_SendData(StartPage >> 8);
 394   1        AS608_SendData(StartPage);
 395   1        AS608_SendData(PageNum >> 8);
 396   1        AS608_SendData(PageNum);
 397   1        temp = 0x01 + 0x08 + 0x04 + BufferID + (StartPage >> 8) + (unsigned char)StartPage + (PageNum >> 8) + (un
             -signed char)PageNum;
 398   1        SendCheck(temp);
 399   1        return ensure;
 400   1      }
 401          
 402          //合并特征（生成模板）PS_RegModel
 403          //功能:将CharBuffer1与CharBuffer2中的特征文件合并生成 模板,结果存于CharBuffer1与CharBuffer2
 404          //说明:  模块返回确认字
 405          unsigned char PS_RegModel(void)
 406          {
 407   1        unsigned short temp;
 408   1        unsigned char sure; //,p=0;
 409   1      
 410   1        if (AS608_PackHead() == 1)
 411   1          return 0xFF;
 412   1        SendFlag(0x01);
 413   1        SendLength(0x03);
 414   1        Sendcmd(0x05); /*合并特征指令*/
 415   1        temp = 0x01 + 0x03 + 0x05;
 416   1        SendCheck(temp);
 417   1      
 418   1        // sure = ReturnFlag(&p);
 419   1        sure = JudgeStr(1000, 0x03);
 420   1      
 421   1        return sure;
 422   1      }
 423          
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       02/19/2021 17:40:22 PAGE 8   

 424          //储存模板 PS_StoreChar
 425          //功能:将 CharBuffer1 或 CharBuffer2 中的模板文件存到 PageID 号flash数据库位置。
 426          //参数:  BufferID @ref charBuffer1:0x01 charBuffer1:0x02
 427          //       PageID（指纹库位置号）
 428          //说明:  模块返回确认字
 429          unsigned char PS_StoreChar(unsigned char BufferID, unsigned short PageID)
 430          {
 431   1        unsigned short temp;
 432   1        unsigned char sure; //,p=0;
 433   1      
 434   1        if (AS608_PackHead() == 1)
 435   1          return 0xFF;
 436   1        SendFlag(0x01);
 437   1        SendLength(0x06);
 438   1        Sendcmd(0x06); /*存储模板指令*/
 439   1        AS608_SendData(BufferID);
 440   1        AS608_SendData(PageID >> 8);
 441   1        AS608_SendData(PageID);
 442   1        temp = 0x01 + 0x06 + 0x06 + BufferID + (PageID >> 8) + (unsigned char)PageID;
 443   1        SendCheck(temp);
 444   1      
 445   1        // sure = ReturnFlag(&p);
 446   1        sure = JudgeStr(1000, 0x03);
 447   1      
 448   1        return sure;
 449   1      }
 450          
 451          //删除模板 PS_DeletChar
 452          //功能:  删除flash数据库中指定ID号开始的N个指纹模板
 453          //参数:  PageID(指纹库模板号)，N删除的模板个数。
 454          //说明:  模块返回确认字
 455          unsigned char PS_DeletChar(unsigned short PageID, unsigned short N)
 456          {
 457   1        unsigned short temp;
 458   1        unsigned char sure; //,p=0;
 459   1      
 460   1        if (AS608_PackHead() == 1)
 461   1          return 0xFF;
 462   1        SendFlag(0x01); //命令包标识
 463   1        SendLength(0x07);
 464   1        Sendcmd(0x0C); /*删除指定指纹模板指令*/
 465   1        AS608_SendData(PageID >> 8);
 466   1        AS608_SendData(PageID);
 467   1        AS608_SendData(N >> 8);
 468   1        AS608_SendData(N);
 469   1        temp = 0x01 + 0x07 + 0x0C + (PageID >> 8) + (unsigned char)PageID + (N >> 8) + (unsigned char)N;
 470   1        SendCheck(temp);
 471   1      
 472   1        //AS608_DELAY_MS(400);
 473   1      
 474   1        // sure = ReturnFlag(&p);
 475   1        sure = JudgeStr(1000, 0x03);
 476   1      
 477   1        return sure;
 478   1      }
 479          
 480          //高速搜索PS_HighSpeedSearch
 481          //功能：以 CharBuffer1或CharBuffer2中的特征文件高速搜索整个或部分指纹库。
 482          //      若搜索到，则返回页码,该指令对于的确存在于指纹库中 ，且登录时质量
 483          //      很好的指纹，会很快给出搜索结果。
 484          //参数:  BufferID， StartPage(起始页)，PageNum（页数）
 485          //说明:  模块返回确认字+页码（相配指纹模板）
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       02/19/2021 17:40:22 PAGE 9   

 486          unsigned char PS_HighSpeedSearch(unsigned char BufferID, unsigned short StartPage, unsigned short PageNum,
             - unsigned short *p)
 487          {
 488   1        unsigned short temp;
 489   1        unsigned char ensure;
 490   1        //unsigned short rc;
 491   1      
 492   1        if (AS608_PackHead() == 1)
 493   1          return 0xFF;
 494   1        SendFlag(0x01);
 495   1        SendLength(0x08);
 496   1        Sendcmd(0x1b); /*高速搜索指纹库指令*/
 497   1        AS608_SendData(BufferID);
 498   1        AS608_SendData(StartPage >> 8);
 499   1        AS608_SendData(StartPage);
 500   1        AS608_SendData(PageNum >> 8);
 501   1        AS608_SendData(PageNum);
 502   1        temp = 0x01 + 0x08 + 0x1b + BufferID + (StartPage >> 8) + (unsigned char)StartPage + (PageNum >> 8) + (un
             -signed char)PageNum;
 503   1        SendCheck(temp);
 504   1      
 505   1        // ensure = ReturnFlag(&rc);
 506   1        ensure = JudgeStr(1000, 0x07);
 507   1      
 508   1        *p = (uart_rec_buff[10] << 8) + uart_rec_buff[11]; //模板号
 509   1      
 510   1        return ensure;
 511   1      }
 512          
 513          //清空指纹库 PS_Empty
 514          //功能:  删除flash数据库中所有指纹模板
 515          //参数:  无
 516          //说明:  模块返回确认字
 517          unsigned char PS_Empty(void)
 518          {
 519   1        unsigned short temp;
 520   1        unsigned char sure; //,p=0;
 521   1      
 522   1        if (AS608_PackHead() == 1)
 523   1          return 0xFF;
 524   1        SendFlag(0x01); //命令包标识
 525   1        SendLength(0x03);
 526   1        Sendcmd(0x0D);
 527   1        temp = 0x01 + 0x03 + 0x0D;
 528   1        SendCheck(temp);
 529   1      
 530   1        // sure = ReturnFlag(&p);
 531   1        sure = JudgeStr(1000, 0x03);
 532   1      
 533   1        return sure;
 534   1      }
 535          
 536          #if 0
              /**
                * @brief  检查STM32与指纹模块的通信连接
                * @param  PS_Addr指纹模块地址
                * @retval 返回值0通讯成功;1表示通讯不成功
                */
              unsigned char PS_Connect(unsigned long *PS_Addr)
              {
                PS_Addr = 0;
                if(AS608_PackHead()==1)
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       02/19/2021 17:40:22 PAGE 10  

                  return 0xFF;
                AS608_SendData(0X01);
                AS608_SendData(0X00);
                AS608_SendData(0X00);
                return 1;   
              }
              
              //写系统寄存器 PS_WriteReg
              //功能:  写模块寄存器
              //参数:  寄存器序号RegNum:4\5\6
              //说明:  模块返回确认字
              unsigned char PS_WriteReg(unsigned char RegNum, unsigned char DATA)
              {
                unsigned short temp;
                unsigned short sure,p=0;
              
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//命令包标识
                SendLength(0x05);
                Sendcmd(0x0E);
                AS608_SendData(RegNum);
                AS608_SendData(DATA);
                temp = RegNum+DATA+0x01+0x05+0x0E;
                SendCheck(temp);
                sure=ReturnFlag(&p);
                return sure;
              }
              /**
                * @brief  读系统基本参数 PS_ReadSysPara
                * @param  无
                * @return 模块返回确认字 + 基本参数（16bytes）
                * @note   读取模块的基本参数（波特率，包大小等)
                * @see    none
                */
              unsigned char PS_ReadSysPara(void)
              {
                unsigned short temp;
                unsigned char  ensure;
                unsigned char  *send_data;
                unsigned short p=0;
                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//命令包标识
                SendLength(0x03);
                Sendcmd(0x0F);
                temp = 0x01+0x03+0x0F;
                SendCheck(temp);
                ensure=ReturnFlag(&p);
                if(send_data)
                {
              
                }   
                else
                  ensure=0xff;
                if(ensure==0x00)
                {
              
                }
                return ensure;
              }
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       02/19/2021 17:40:22 PAGE 11  

              //设置模块地址 PS_SetAddr
              //功能:  设置模块地址
              //参数:  PS_addr
              //说明:  模块返回确认字
              unsigned char PS_SetAddr(unsigned long PS_addr)
              {
                unsigned short temp;
                unsigned char  ensure;
              
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//命令包标识
                SendLength(0x07);
                Sendcmd(0x15);
                AS608_SendData(PS_addr>>24);
                AS608_SendData(PS_addr>>16);
                AS608_SendData(PS_addr>>8);
                AS608_SendData(PS_addr);
                temp = 0x01+0x07+0x15
                +(unsigned char)(PS_addr>>24)+(unsigned char)(PS_addr>>16)
                +(unsigned char)(PS_addr>>8) +(unsigned char)PS_addr;       
                SendCheck(temp);
              
                return ensure;
              }
              //功能： 模块内部为用户开辟了256bytes的FLASH空间用于存用户记事本,
              //  该记事本逻辑上被分成 16 个页。
              //参数:  NotePageNum(0~15),Byte32(要写入内容，32个字节)
              //说明:  模块返回确认字
              unsigned char PS_WriteNotepad(unsigned char NotePageNum,unsigned char *Byte32)
              {
                unsigned short temp;
                unsigned char  ensure,i;
                
                *Byte32 = 0;
                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01); //命令包标识
                SendLength(36);
                Sendcmd(0x18);
                AS608_SendData(NotePageNum);
                for(i=0;i<32;i++)
                {
                  AS608_SendData(Byte32[i]);
                  temp += Byte32[i];
                }
                temp =0x01+36+0x18+NotePageNum+temp;
                SendCheck(temp);
              
                return ensure;
              }
              //读记事PS_ReadNotepad
              //功能：  读取FLASH用户区的128bytes数据
              //参数:  NotePageNum(0~15)
              //说明:  模块返回确认字+用户信息
              unsigned char PS_ReadNotepad(unsigned char NotePageNum,unsigned char *Byte32)
              {
                unsigned short temp;
                unsigned char  ensure;
                
                *Byte32 = 0;
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       02/19/2021 17:40:22 PAGE 12  

                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//命令包标识
                SendLength(0x04);
                Sendcmd(0x19);
                AS608_SendData(NotePageNum);
                temp = 0x01+0x04+0x19+NotePageNum;
                SendCheck(temp);
              
                return ensure;
              }
              #endif
 683          
 684          //读有效模板个数 PS_ValidTempleteNum
 685          //功能：读有效模板个数
 686          //参数: 无
 687          //说明: 模块返回确认字+有效模板个数ValidN
 688          unsigned char PS_ValidTempleteNum(unsigned short *ValidN)
 689          {
 690   1        unsigned short temp;
 691   1        unsigned char ensure;
 692   1        unsigned short p = 0;
 693   1      
 694   1        if (AS608_PackHead() == 1)
 695   1          return 0xFF;
 696   1        SendFlag(0x01); //命令包标识
 697   1        SendLength(0x03);
 698   1        Sendcmd(0x1d);
 699   1        temp = 0x01 + 0x03 + 0x1d;
 700   1        SendCheck(temp);
 701   1      
 702   1        // ensure = ReturnFlag(&p);
 703   1        ensure = JudgeStr(1000, 0x05);
 704   1      
 705   1        *ValidN = (uart_rec_buff[10] << 8) + uart_rec_buff[11];
 706   1      
 707   1        return ensure;
 708   1      }
 709          
 710          //自动注册模板 PS_AutoEnRoll
 711          //功能：采集一次指纹注册模板，在指纹库中搜索空位并存储，返回存储ID
 712          //参数: 无
 713          //说明: 模块返回确认字+页码（相配指纹模板）
 714          unsigned char PS_AutoEnRoll(unsigned short id, unsigned char num, unsigned short param)
 715          {
 716   1        unsigned short sum;
 717   1      
 718   1        if (AS608_PackHead() == 1)
 719   1          return 0xFF;
 720   1        SendFlag(0x01); //命令包标识
 721   1        SendLength(0x08);
 722   1        Sendcmd(0x31);
 723   1        AS608_SendData(id >> 8);
 724   1        AS608_SendData(id & 0xFF);
 725   1        AS608_SendData(num);
 726   1        AS608_SendData(param >> 8);
 727   1        AS608_SendData(param & 0xFF);
 728   1        sum = 0x01 + 0x08 + 0x31 + (id >> 8) + (id & 0xFF) + num + (param >> 8) + (param & 0xFF);
 729   1        SendCheck(sum);
 730   1      
 731   1        return 0;
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       02/19/2021 17:40:22 PAGE 13  

 732   1      }
 733          
 734          //自动验证指纹 PS_AutoIdentify
 735          //功能：
 736          //1.自动采集指纹，在指纹库中搜索目标模板并返回搜索结果。
 737          //2.如果目标模板同当前采集的指纹比对得分大于最高阀值，并且目标模板为不完整特征则以采集的特征更新目标模板的
             -空白区域。
 738          //参数: 无
 739          //说明: 模块返回确认字+页码（相配指纹模板）
 740          unsigned char PS_AutoIdentify(unsigned short id, unsigned char level, unsigned short param)
 741          {
 742   1        unsigned short sum;
 743   1      
 744   1        if (AS608_PackHead() == 1)
 745   1          return 0xFF;
 746   1        SendFlag(0x01); //命令包标识
 747   1        SendLength(0x08);
 748   1        Sendcmd(0x32);
 749   1        AS608_SendData(level);
 750   1        AS608_SendData(id >> 8);
 751   1        AS608_SendData(id & 0xFF);
 752   1        AS608_SendData(param >> 8);
 753   1        AS608_SendData(param & 0xFF);
 754   1        sum = 0x01 + 0x08 + 0x32 + (id >> 8) + (id & 0xFF) + level + (param >> 8) + (param & 0xFF);
 755   1        SendCheck(sum);
 756   1      
 757   1        return 0;
 758   1      }
 759          
 760          //与AS608握手 PS_HandShake
 761          //参数: PS_Addr地址指针
 762          //说明: 模块返新地址（正确地址） 返回确认码
 763          unsigned char PS_HandShake(unsigned long *PS_Addr)
 764          {
 765   1        *PS_Addr = 0;
 766   1      
 767   1        if (AS608_PackHead() == 1)
 768   1          return 0xFF;
 769   1      
 770   1        SendFlag(0x01);
 771   1        SendLength(0x07);
 772   1        Sendcmd(0x13);
 773   1        AS608_SendData(0x00);
 774   1        AS608_SendData(0x00);
 775   1        AS608_SendData(0x00);
 776   1        AS608_SendData(0x00);
 777   1        SendCheck(0x1B);
 778   1      
 779   1        return 0;
 780   1      }
 781          
 782          unsigned char PS_Reset(void)
 783          {
 784   1        return 0;
 785   1      }
 786          
 787          unsigned char PS_Sleep(void)
 788          {
 789   1        unsigned short temp;
 790   1        unsigned char ensure;
 791   1      
 792   1        if (AS608_PackHead() == 1)
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       02/19/2021 17:40:22 PAGE 14  

 793   1          return 0xFF;
 794   1        SendFlag(0x01); //命令包标识
 795   1        SendLength(0x03);
 796   1        Sendcmd(0x60);
 797   1        temp = 0x01 + 0x03 + 0x60;
 798   1        SendCheck(temp);
 799   1        return ensure;
 800   1      }
 801          
 802          //void AS608_log(void)
 803          //{
 804          //  unsigned char i =0;
 805          ////  NRF_LOG_PRINTF_DEBUG("receive :");
 806          //  for(i=0;i<25;i++)
 807          //  {
 808          //    NRF_LOG_PRINTF_DEBUG("%2x ",as608_rec_buff[i]);
 809          //  }
 810          //  NRF_LOG_PRINTF_DEBUG("\n");
 811          //}
 812          
 813          void FP_Light(FP_COLOR_E light_id)
 814          {
 815   1        //  if(fp_flag == FP_LT5X)
 816   1        //  {
 817   1        //#ifdef __FP_LT5X_LIGHT_SUPPORT__
 818   1        unsigned short temp;
 819   1      
 820   1        unsigned char sure = 0; //,p=0;
 821   1        if (light_id == Light_Color)
 822   1          return;
 823   1      
 824   1        if (AS608_PackHead() == 1)
 825   1          return;
 826   1        SendFlag(0x01);
 827   1        SendLength(0x07);
 828   1        Sendcmd(0x41);
 829   1        switch (light_id)
 830   1        {
 831   2        case FP_BLUE:
 832   2          AS608_SendData(0x01);
 833   2          AS608_SendData(0x01);
 834   2          AS608_SendData(0x00);
 835   2          AS608_SendData(0x50);
 836   2          temp = 0x01 + 0x07 + 0x41 + 0x02 + 0x50;
 837   2          break;
 838   2        case FP_GREEN:
 839   2          AS608_SendData(0x01);
 840   2          AS608_SendData(0x02);
 841   2          AS608_SendData(0x02);
 842   2          AS608_SendData(0);
 843   2          temp = 0x01 + 0x07 + 0x41 + 0x05 + 0;
 844   2          break;
 845   2        case FP_RED:
 846   2          AS608_SendData(0x01);
 847   2          AS608_SendData(0x04);
 848   2          AS608_SendData(0x04);
 849   2          AS608_SendData(0);
 850   2          temp = 0x01 + 0x07 + 0x41 + 0x09 + 0;
 851   2          break;
 852   2        case FP_NONE_COLOR:
 853   2          AS608_SendData(0x04);
 854   2          AS608_SendData(0x00);
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       02/19/2021 17:40:22 PAGE 15  

 855   2          AS608_SendData(0x00);
 856   2          AS608_SendData(0xC8);
 857   2          temp = 0x01 + 0x07 + 0x41 + 0x04 + 0xC8;
 858   2          break;
 859   2        }
 860   1        SendCheck(temp);
 861   1      
 862   1        //sure=ReturnFlag(&p);
 863   1        sure = JudgeStr(1000, 0x03);
 864   1        //#endif
 865   1        Light_Color = light_id;
 866   1      
 867   1        //  }
 868   1      }
 869          
 870          FP_COLOR_E FP_Get_Light(void)
 871          {
 872   1        return Light_Color;
 873   1      }
 874          
 875          //#endif//__PREIPHERAL_FP_LT5X_SUPPORT__


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1896    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     25      56
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
