C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/01/2021 18:11:24 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DQIOT_FP_SY
OBJECT MODULE PLACED IN .\output\dqiot_fp_sy.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE source\dqiot_fp_sy.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\includ
                    -e;.\Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd
                    -_rfid;.\mmi_inc) DEBUG PRINT(.\list\dqiot_fp_sy.lst) TABS(2) OBJECT(.\output\dqiot_fp_sy.obj)

line level    source

   1          
   2          //#if defined (__PREIPHERAL_FP_SY_SUPPORT__)
   3          //#include "string.h"
   4          #include "dqiot_fp_sy.h"
   5          #include "delay.h"
   6          #include "dqiot_drv.h"
   7          #include "mcu02_uart.h"
   8          
   9          //unsigned long fp_pin_irq_mask;
  10          
  11          //fp_irq_handle_callback fp_callback_handle;
  12          //fp_uart_handle_callback fp_uart_handle = 0;
  13          //unsigned char fp_Mode = 0;
  14          //static unsigned char fp_temp_mode = 0;
  15          
  16          static unsigned char uart_rec_buff[20];
  17          
  18          //static FP_TYPE fp_flag = FP_NONE;
  19          static FP_COLOR_E Light_Color = FP_NONE_COLOR;
  20          //static unsigned char ps_start_flag = 0;
  21          
  22          extern unsigned char uart_get_buf[];
  23          extern unsigned char uart_getbuflen;
  24          
  25          //unsigned short  ReceiveInfo( unsigned char *rec_data);
  26          //void AS608_log(void);
  27          
  28          //void fp_set_irq_handle(fp_irq_handle_callback cb)
  29          //{
  30          //  fp_callback_handle = cb;
  31          //}
  32          
  33          //void fp_set_uart_handle(fp_uart_handle_callback cb)
  34          //{
  35          //  fp_uart_handle = cb;
  36          //}
  37          
  38          ///FP_TYPE fp_get_type(void)
  39          //{
  40          //  return fp_flag;
  41          
  42          //}
  43          
  44          //--------------------------------------------------------------------------------
  45          
  46          //static unsigned char uart_len=0;
  47          //static unsigned short uart_maxlen = 0;
  48          //static unsigned char uart_buff[25]={0};
  49          
  50          //static void UART_Callback(unsigned char send_data)
  51          //{
  52          //  send_data = 0;
  53          //}
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/01/2021 18:11:24 PAGE 2   

  54          
  55          //unsigned char fp_GetModeState(void)
  56          //{
  57          //  return fp_Mode;
  58          //}
  59          
  60          //void fp_SetModeState(unsigned char s)
  61          //{
  62          //  fp_Mode = s;
  63          
  64          //  if(s == 0)
  65          //    Light_Color = FP_NONE_COLOR;
  66          //}
  67          
  68          //static void PS_UART_Callback(unsigned char send_data)
  69          //{
  70          //  if(send_data == 0x55 )
  71          //  {
  72          //    ps_start_flag = 1;
  73          //  }
  74          //}
  75          
  76          //void FP_PowerOn(void)
  77          //{
  78          
  79          //}
  80          
  81          /**
  82            * @brief  AS608_USARTä¸²å£å‘æŒ‡çº¹æ¨¡å—ä¼ é€’æ•°æ? 
  83            * @param  data;ä¼ è¾“çš„æ•°æ?
  84            */
  85          void AS608_SendData(unsigned char send_data)
  86          {
  87   1        uart_tx_byte(UART0, send_data);
  88   1      }
  89          
  90          /**
  91            * @brief  AS608_USARTä¸²å£å‘æŒ‡çº¹æ¨¡å—å‘½ä»¤åŒ…å¤´æ ¼å¼? 
  92            * @param  æ—?
  93            */
  94          unsigned char AS608_PackHead(void)
  95          {
  96   1      
  97   1        //unsigned char delay_times = 30;
  98   1      
  99   1        //while(ps_start_flag==0&&delay_times>0)
 100   1        //{
 101   1        //  delay_times--;
 102   1        //}
 103   1        //if(ps_start_flag == 0)
 104   1        //{
 105   1        //  return 1;
 106   1        //}
 107   1        //else if(ps_start_flag == 1)
 108   1        //{
 109   1        //  uart_init_block();
 110   1        //  ps_start_flag = 2;
 111   1        //}
 112   1      
 113   1        /*åŒ…å¤´*/
 114   1        AS608_SendData(0xEF);
 115   1        AS608_SendData(0x01);
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/01/2021 18:11:24 PAGE 3   

 116   1      
 117   1        /*æŒ‡çº¹æ¨¡å—åœ°å€*/
 118   1        AS608_SendData(AS608_Addr >> 24);
 119   1        AS608_SendData(AS608_Addr >> 16);
 120   1        AS608_SendData(AS608_Addr >> 8);
 121   1        AS608_SendData(AS608_Addr);
 122   1      
 123   1        return 0;
 124   1      }
 125          
 126          unsigned char AS608_PackHead2(void)
 127          {
 128   1      
 129   1        /*åŒ…å¤´*/
 130   1        AS608_SendData(0xEF);
 131   1        AS608_SendData(0x01);
 132   1      
 133   1        /*æŒ‡çº¹æ¨¡å—åœ°å€*/
 134   1        AS608_SendData(AS608_Addr >> 24);
 135   1        AS608_SendData(AS608_Addr >> 16);
 136   1        AS608_SendData(AS608_Addr >> 8);
 137   1        AS608_SendData(AS608_Addr);
 138   1      
 139   1        return 0;
 140   1      }
 141          
 142          /**
 143            * @brief  å‘é€åŒ…æ ‡è¯†
 144            * @param  flag:åŒ…æ ‡è¯†ä½
 145            * @retval æ—?
 146            */
 147          void SendFlag(unsigned char flag)
 148          {
 149   1        AS608_SendData(flag);
 150   1      }
 151          
 152          /**
 153            * @brief  å‘é€åŒ…é•¿åº¦
 154            * @param  length:åŒ…é•¿åº?
 155            * @retval æ—?
 156            */
 157          void SendLength(unsigned short length)
 158          {
 159   1        AS608_SendData(length >> 8);
 160   1        AS608_SendData(length);
 161   1      }
 162          
 163          /**
 164            * @brief  å‘é€æŒ‡ä»¤ç 
 165            * @param  cmd;æŒ‡ä»¤ç ?
 166            * @retval æ—?
 167            */
 168          void Sendcmd(unsigned char cmd)
 169          {
 170   1        AS608_SendData(cmd);
 171   1      }
 172          
 173          /**
 174            * @brief  å‘é€æ ¡éªŒå’Œ
 175            * @param  check:æ£€æŸ¥ä½
 176            * @retval æ—?
 177            */
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/01/2021 18:11:24 PAGE 4   

 178          void SendCheck(unsigned short check)
 179          {
 180   1        AS608_SendData(check >> 8);
 181   1        AS608_SendData(check);
 182   1      }
 183          
 184          /**
 185            * @brief  åˆ¤æ–­ä¸?æ–?æ¥æ”¶çš„æ•°ç»„æœ‰æ²¡æœ‰åº”ç­”åŒ?
 186            * @param  
 187            * waittimeä¸ºç­‰å¾…ä¸­æ–?æ¥æ”¶æ•°æ®çš„æ—¶é—?(å•ä½1ms)
 188            * lengthä¸ºåŒ…é•¿åº¦
 189            * @return æ•°æ®åŒ…ç¡®è®¤ç 
 190            * @note   1 failed
 191            * @see    none
 192            */
 193          static u8 JudgeStr(u16 waittime, u8 length)
 194          {
 195   1        u8 getdata;
 196   1        u8 i = 0, j = 0;
 197   1        //u8 str[8];
 198   1        //str[0] = 0xEF;
 199   1        //str[1] = 0x01;
 200   1        //str[2] = AS608_Addr >> 24;
 201   1        //str[3] = AS608_Addr >> 16;
 202   1        //str[4] = AS608_Addr >> 8;
 203   1        //str[5] = AS608_Addr;
 204   1        //str[6] = 0x07;
 205   1      
 206   1        while (--waittime)
 207   1        {
 208   2          delay_ms(1);
 209   2      
 210   2          /* æ¥æ”¶åˆ°ä¸€æ¬¡æ•°æ? */
 211   2          if (uart_getbuflen >= 9 + length)
 212   2          {
 213   3            /* å¯»æ‰¾0xEFä½ç½® */
 214   3            for (i = 0; i < uart_getbuflen; i++)
 215   3            {
 216   4              if (uart_get_buf[i] == 0xEF)
 217   4                break;
 218   4            }
 219   3      
 220   3            /* åˆ¤æ–­æ˜?å¦ä¸ºåº”ç­”åŒ? */
 221   3            if (uart_get_buf[i] == 0xEF && uart_get_buf[i + 1] == 0x01 && uart_get_buf[i + 6] == 0x07 && ((uart_get
             -_buf[i + 7] << 8) + uart_get_buf[i + 8]) == length)
 222   3            {
 223   4              for (i; i < uart_getbuflen; i++)
 224   4              {
 225   5                uart_rec_buff[j] = uart_get_buf[i];
 226   5                j++;
 227   5              }
 228   4              getdata = uart_rec_buff[9]; //ç¡?è®¤ç 
 229   4      
 230   4              /* æ¸…ç©ºç¼“å­˜ */
 231   4              uart_getbuflen = 0;
 232   4      
 233   4              return getdata;
 234   4            }
 235   3          }
 236   2        }
 237   1      
 238   1        return 1;
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/01/2021 18:11:24 PAGE 5   

 239   1      }
 240          
 241          #if 0
              /**
                * @brief  ä»ç¼“å†²åŒºè¯»å‡ºç¡?è®¤ç 
                * @param  *i:è¿”å›å€¼ï¼ˆç¡?è®¤ç ï¼?
                * @retval æ—?
                */
              unsigned char  ReturnFlag( unsigned char *i)
              { 
                *i = ReceiveInfo(uart_rec_buff);
                return *i;
              }
              
              unsigned char  ReceiveInfo( unsigned char *rec_data)
              {
                unsigned char *temp_data;
                unsigned short rev_length = 0;
                unsigned char error = 0;
                unsigned char a = 9;
              
                memset(uart_rec_buff,0,sizeof(uart_rec_buff));
              
                do
                {
                  //error = nrf_drv_uart_rx(rec_data,1);
                  //if(error == NRF_ERROR_INTERNAL)
                  //  return 0xFF;
                  if(rec_data[0] == 0xEF)
                    break;
                  if(a==0)
                    return 0xFF;
                }while(a--);
                
              
                rev_length = (rec_data[7]<<8)+rec_data[8];
                temp_data = rec_data+9;
              
                if(rev_length!=0)
                  ;//nrf_drv_uart_rx(temp_data,rev_length);
                else
                  return 0xFF;
              
                AS608_log();
                return temp_data[0];
              }
              #endif
 286          
 287          unsigned char PS_GetEcho(void)
 288          {
 289   1        AS608_PackHead2();
 290   1        SendFlag(0x01);
 291   1        SendLength(0x03);
 292   1        Sendcmd(0x53); /*ç”Ÿæˆç‰¹å¾æŒ‡ä»¤*/
 293   1        SendCheck(0x57);
 294   1      
 295   1        //sure=ReturnFlag(&p);
 296   1        return JudgeStr(1000, 0x03);
 297   1      }
 298          
 299          //å½•å…¥å›¾åƒ PS_GetImage
 300          //åŠŸèƒ½:æ¢æµ‹æ‰‹æŒ‡ï¼Œæ¢æµ‹åˆ°åå½•å…¥æŒ‡çº¹å›¾åƒå­˜äºImageBufferã€?
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/01/2021 18:11:24 PAGE 6   

 301          //æ¨¡å—è¿”å›ç¡?è®¤å­—
 302          unsigned char PS_GetImage(void)
 303          {
 304   1        uart_getbuflen = 0;
 305   1        //delay_ms(300);
 306   1        if (AS608_PackHead() == 1)
 307   1          return 0xFF;
 308   1        SendFlag(0x01); /*å‘½ä»¤åŒ…æ ‡è¯?*/
 309   1        SendLength(0x03);
 310   1        Sendcmd(0x01); /*å½•æŒ‡çº¹æŒ‡ä»?*/
 311   1        SendCheck(0x01 + 0x03 + 0x01);
 312   1      
 313   1        //nrf_delay_ms(50);        /*ç­‰å¾…æŒ‡çº¹è¯†åˆ«æ¨¡å—å¤„ç†æ•°æ®*/
 314   1      
 315   1        // sure = ReturnFlag(&p);
 316   1        return JudgeStr(1000, 0x03);
 317   1      }
 318          
 319          //ç”Ÿæˆç‰¹å¾ PS_GenChar
 320          //åŠŸèƒ½:å°†ImageBufferä¸?çš„åŸå§‹å›¾åƒç”ŸæˆæŒ‡çº¹ç‰¹å¾æ–‡ä»¶å­˜äºCharBuffer1æˆ–CharBuffer2
 321          //å‚æ•°:BufferID --> charBuffer1:0x01  charBuffer1:0x02
 322          //æ¨¡å—è¿”å›ç¡?è®¤å­—
 323          unsigned char PS_GenChar(unsigned char BufferID)
 324          {
 325   1        if (AS608_PackHead() == 1)
 326   1          return 0xFF;
 327   1        SendFlag(0x01);
 328   1        SendLength(0x04);
 329   1        Sendcmd(0x02); /*ç”Ÿæˆç‰¹å¾æŒ‡ä»¤*/
 330   1        AS608_SendData(BufferID);
 331   1        SendCheck(0x01 + 0x04 + 0x02 + BufferID);
 332   1        return JudgeStr(1000, 0x03);
 333   1      }
 334          
 335          //ç²¾ç¡®æ¯”å?¹ä¸¤æšæŒ‡çº¹ç‰¹å¾? PS_Match
 336          //åŠŸèƒ½:ç²¾ç¡®æ¯”å?¹CharBuffer1 ä¸CharBuffer2 ä¸?çš„ç‰¹å¾æ–‡ä»?
 337          //æ¨¡å—è¿”å›ç¡?è®¤å­—
 338          unsigned char PS_Match(void)
 339          {
 340   1        if (AS608_PackHead() == 1)
 341   1          return 0xFF;
 342   1        SendFlag(0x01);
 343   1        SendLength(0x03);
 344   1        Sendcmd(0x03); /*ç²¾ç¡®æ¯”å?¹æŒ‡ä»?*/
 345   1        SendCheck(0x01 + 0x03 + 0x03);
 346   1      
 347   1        // sure = ReturnFlag(&p);
 348   1        return JudgeStr(1000, 0x05);
 349   1      }
 350          //æœç´¢æŒ‡çº¹ PS_Search
 351          //åŠŸèƒ½:ä»?CharBuffer1æˆ–CharBuffer2ä¸?çš„ç‰¹å¾æ–‡ä»¶æœç´¢æ•´ä¸?æˆ–éƒ¨åˆ†æŒ‡çº¹åº“.è‹¥æœç´¢åˆ°ï¼Œåˆ™è¿
             -”å›é¡µç ã€?
 352          //å‚æ•°:  BufferID @ref CharBuffer1  CharBuffer2
 353          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡?è®¤å­—ï¼Œé¡µç ï¼ˆç›¸é…æŒ‡çº¹æ¨¡æ¿ï¼?
 354          unsigned char PS_Search(unsigned char BufferID, unsigned short StartPage, unsigned short PageNum, unsigned
             - short *p)
 355          {
 356   1      
 357   1        unsigned char sure;
 358   1        if (AS608_PackHead() == 1)
 359   1          return 0xFF;
 360   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯?
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/01/2021 18:11:24 PAGE 7   

 361   1        SendLength(0x08);
 362   1        Sendcmd(0x04);
 363   1        AS608_SendData(BufferID);
 364   1        AS608_SendData(StartPage >> 8);
 365   1        AS608_SendData(StartPage);
 366   1        AS608_SendData(PageNum >> 8);
 367   1        AS608_SendData(PageNum);
 368   1        SendCheck(0x01 + 0x08 + 0x04 + BufferID + (StartPage >> 8) + (unsigned char)StartPage + (PageNum >> 8) + 
             -(unsigned char)PageNum);
 369   1        *p = (uart_rec_buff[10] << 8) + uart_rec_buff[11];
 370   1        return sure;
 371   1      }
 372          
 373          //åˆå¹¶ç‰¹å¾ï¼ˆç”Ÿæˆæ¨¡æ¿ï¼‰PS_RegModel
 374          //åŠŸèƒ½:å°†CharBuffer1ä¸CharBuffer2ä¸?çš„ç‰¹å¾æ–‡ä»¶åˆå¹¶ç”Ÿæˆ? æ¨¡æ¿,ç»“æœå­˜äºCharBuffer1ä¸CharB
             -uffer2
 375          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡?è®¤å­—
 376          unsigned char PS_RegModel(void)
 377          {
 378   1        if (AS608_PackHead() == 1)
 379   1          return 0xFF;
 380   1        SendFlag(0x01);
 381   1        SendLength(0x03);
 382   1        Sendcmd(0x05); /*åˆå¹¶ç‰¹å¾æŒ‡ä»¤*/
 383   1        SendCheck(0x01 + 0x03 + 0x05);
 384   1      
 385   1        // sure = ReturnFlag(&p);
 386   1        return JudgeStr(1000, 0x03);
 387   1      }
 388          
 389          //å‚¨å­˜æ¨¡æ¿ PS_StoreChar
 390          //åŠŸèƒ½:å°? CharBuffer1 æˆ? CharBuffer2 ä¸?çš„æ¨¡æ¿æ–‡ä»¶å­˜åˆ? PageID å·flashæ•°æ®åº“ä½ç½?ã€?
 391          //å‚æ•°:  BufferID @ref charBuffer1:0x01 charBuffer1:0x02
 392          //       PageIDï¼ˆæŒ‡çº¹åº“ä½ç½®å·ï¼‰
 393          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡?è®¤å­—
 394          unsigned char PS_StoreChar(unsigned char BufferID, unsigned short PageID)
 395          {
 396   1        unsigned short;
 397   1      
 398   1        if (AS608_PackHead() == 1)
 399   1          return 0xFF;
 400   1        SendFlag(0x01);
 401   1        SendLength(0x06);
 402   1        Sendcmd(0x06); /*å­˜å‚¨æ¨¡æ¿æŒ‡ä»¤*/
 403   1        AS608_SendData(BufferID);
 404   1        AS608_SendData(PageID >> 8);
 405   1        AS608_SendData(PageID);
 406   1        SendCheck(0x01 + 0x06 + 0x06 + BufferID + (PageID >> 8) + (unsigned char)PageID);
 407   1      
 408   1        // sure = ReturnFlag(&p);
 409   1        return JudgeStr(1000, 0x03);
 410   1      }
 411          
 412          //åˆ é™¤æ¨¡æ¿ PS_DeletChar
 413          //åŠŸèƒ½:  åˆ é™¤flashæ•°æ®åº“ä¸­æŒ‡å®šIDå·å¼€å§‹çš„Nä¸?æŒ‡çº¹æ¨¡æ¿
 414          //å‚æ•°:  PageID(æŒ‡çº¹åº“æ¨¡æ¿å·)ï¼ŒNåˆ é™¤çš„æ¨¡æ¿ä¸ªæ•°ã€?
 415          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡?è®¤å­—
 416          unsigned char PS_DeletChar(unsigned short PageID, unsigned short N)
 417          {
 418   1        unsigned char sure; //,p=0;
 419   1      
 420   1        if (AS608_PackHead() == 1)
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/01/2021 18:11:24 PAGE 8   

 421   1          return 0xFF;
 422   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯?
 423   1        SendLength(0x07);
 424   1        Sendcmd(0x0C); /*åˆ é™¤æŒ‡å®šæŒ‡çº¹æ¨¡æ¿æŒ‡ä»¤*/
 425   1        AS608_SendData(PageID >> 8);
 426   1        AS608_SendData(PageID);
 427   1        AS608_SendData(N >> 8);
 428   1        AS608_SendData(N);
 429   1        SendCheck(0x01 + 0x07 + 0x0C + (PageID >> 8) + (unsigned char)PageID + (N >> 8) + (unsigned char)N);
 430   1      
 431   1        //AS608_DELAY_MS(400);
 432   1      
 433   1        // sure = ReturnFlag(&p);
 434   1        return JudgeStr(1000, 0x03);
 435   1      }
*** WARNING C280 IN LINE 418 OF source\dqiot_fp_sy.c: 'sure': unreferenced local variable
 436          
 437          //é«˜é€Ÿæœç´?PS_HighSpeedSearch
 438          //åŠŸèƒ½ï¼šä»¥ CharBuffer1æˆ–CharBuffer2ä¸?çš„ç‰¹å¾æ–‡ä»¶é«˜é€Ÿæœç´¢æ•´ä¸?æˆ–éƒ¨åˆ†æŒ‡çº¹åº“ã€?
 439          //      è‹¥æœç´¢åˆ°ï¼Œåˆ™è¿”å›é¡µç ,è¯¥æŒ‡ä»¤å?¹äºçš„ç¡®å­˜åœ¨äºæŒ‡çº¹åº“ä¸? ï¼Œä¸”ç™»å½•æ—¶è´¨é‡?
 440          //      å¾ˆå¥½çš„æŒ‡çº¹ï¼Œä¼šå¾ˆå¿?ç»™å‡ºæœç´¢ç»“æœã€?
 441          //å‚æ•°:  BufferIDï¼? StartPage(èµ·å?‹é¡µ)ï¼ŒPageNumï¼ˆé¡µæ•°ï¼‰
 442          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡?è®¤å­—+é¡µç ï¼ˆç›¸é…æŒ‡çº¹æ¨¡æ¿ï¼‰
 443          unsigned char PS_HighSpeedSearch(unsigned char BufferID, unsigned short StartPage, unsigned short PageNum,
             - unsigned short *p)
 444          {
 445   1        unsigned char ensure;
 446   1      
 447   1        if (AS608_PackHead() == 1)
 448   1          return 0xFF;
 449   1        SendFlag(0x01);
 450   1        SendLength(0x08);
 451   1        Sendcmd(0x1b); /*é«˜é€Ÿæœç´¢æŒ‡çº¹åº“æŒ‡ä»¤*/
 452   1        AS608_SendData(BufferID);
 453   1        AS608_SendData(StartPage >> 8);
 454   1        AS608_SendData(StartPage);
 455   1        AS608_SendData(PageNum >> 8);
 456   1        AS608_SendData(PageNum);
 457   1        SendCheck(0x01 + 0x08 + 0x1b + BufferID + (StartPage >> 8) + (unsigned char)StartPage + (PageNum >> 8) + 
             -(unsigned char)PageNum);
 458   1      
 459   1        // ensure = ReturnFlag(&rc);
 460   1        ensure = JudgeStr(1000, 0x07);
 461   1      
 462   1        *p = (uart_rec_buff[10] << 8) + uart_rec_buff[11];
 463   1      
 464   1        return ensure;
 465   1      }
 466          
 467          //æ¸…ç©ºæŒ‡çº¹åº? PS_Empty
 468          //åŠŸèƒ½:  åˆ é™¤flashæ•°æ®åº“ä¸­æ‰€æœ‰æŒ‡çº¹æ¨¡æ?
 469          //å‚æ•°:  æ—?
 470          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡?è®¤å­—
 471          unsigned char PS_Empty(void)
 472          {
 473   1        if (AS608_PackHead() == 1)
 474   1          return 0xFF;
 475   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯?
 476   1        SendLength(0x03);
 477   1        Sendcmd(0x0D);
 478   1        SendCheck(0x01 + 0x03 + 0x0D);
 479   1      
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/01/2021 18:11:24 PAGE 9   

 480   1        // sure = ReturnFlag(&p);
 481   1        return JudgeStr(1000, 0x03);
 482   1      }
 483          
 484          #if 0
              /**
                * @brief  æ£€æŸ?STM32ä¸æŒ‡çº¹æ¨¡å—çš„é€šä¿¡è¿æ¥
                * @param  PS_AddræŒ‡çº¹æ¨¡å—åœ°å€
                * @retval è¿”å›å€?0é€šè??æˆåŠŸ;1è¡¨ç¤ºé€šè??ä¸æˆåŠ?
                */
              unsigned char PS_Connect(unsigned long *PS_Addr)
              {
                PS_Addr = 0;
                if(AS608_PackHead()==1)
                  return 0xFF;
                AS608_SendData(0X01);
                AS608_SendData(0X00);
                AS608_SendData(0X00);
                return 1;   
              }
              
              //å†™ç³»ç»Ÿå¯„å­˜å™¨ PS_WriteReg
              //åŠŸèƒ½:  å†™æ¨¡å—å¯„å­˜å™¨
              //å‚æ•°:  å¯„å­˜å™¨åºå·RegNum:4\5\6
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡?è®¤å­—
              unsigned char PS_WriteReg(unsigned char RegNum, unsigned char DATA)
              {
                unsigned short temp;
                unsigned short sure,p=0;
              
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//é›æˆ’æŠ¤é–å‘?çˆ£ç’‡
                SendLength(0x05);
                Sendcmd(0x0E);
                AS608_SendData(RegNum);
                AS608_SendData(DATA);
                temp = RegNum+DATA+0x01+0x05+0x0E;
                SendCheck(temp);
                sure=ReturnFlag(&p);
                return sure;
              }
              //è¯»ç³»ç»ŸåŸºæœ?å‚æ•° PS_ReadSysPara
              //åŠŸèƒ½:  è¯»å–æ¨¡å—çš„åŸºæœ?å‚æ•°ï¼ˆæ³¢ç‰¹ç‡ï¼ŒåŒ…å¤§å°ç­?)
              //å‚æ•°:  æ—?
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡?è®¤å­— + åŸºæœ¬å‚æ•°ï¼?16bytesï¼?
              unsigned char PS_ReadSysPara(void)
              {
                unsigned short temp;
                unsigned char  ensure;
                unsigned char  *send_data;
                unsigned short p=0;
                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//é›æˆ’æŠ¤é–å‘?çˆ£ç’‡
                SendLength(0x03);
                Sendcmd(0x0F);
                temp = 0x01+0x03+0x0F;
                SendCheck(temp);
                ensure=ReturnFlag(&p);
                if(send_data)
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/01/2021 18:11:24 PAGE 10  

                {
              
                }   
                else
                  ensure=0xff;
                if(ensure==0x00)
                {
              
                }
                return ensure;
              }
              //è®¾ç½®æ¨¡å—åœ°å€ PS_SetAddr
              //åŠŸèƒ½:  è®¾ç½®æ¨¡å—åœ°å€
              //å‚æ•°:  PS_addr
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡?è®¤å­—
              unsigned char PS_SetAddr(unsigned long PS_addr)
              {
                unsigned short temp;
                unsigned char  ensure;
              
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//å‘½ä»¤åŒ…æ ‡è¯?
                SendLength(0x07);
                Sendcmd(0x15);
                AS608_SendData(PS_addr>>24);
                AS608_SendData(PS_addr>>16);
                AS608_SendData(PS_addr>>8);
                AS608_SendData(PS_addr);
                temp = 0x01+0x07+0x15
                +(unsigned char)(PS_addr>>24)+(unsigned char)(PS_addr>>16)
                +(unsigned char)(PS_addr>>8) +(unsigned char)PS_addr;       
                SendCheck(temp);
              
                return ensure;
              }
              //åŠŸèƒ½ï¼? æ¨¡å—å†…éƒ¨ä¸ºç”¨æˆ·å¼€è¾Ÿäº†256bytesçš„FLASHç©ºé—´ç”¨äºå­˜ç”¨æˆ·è?°äº‹æœ?,
              //  è¯¥è?°äº‹æœ?é€»è¾‘ä¸Šè??åˆ†æˆ 16 ä¸?é¡µã€?
              //å‚æ•°:  NotePageNum(0~15),Byte32(è¦å†™å…¥å†…å®¹ï¼Œ32ä¸?å­—èŠ‚)
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡?è®¤å­—
              unsigned char PS_WriteNotepad(unsigned char NotePageNum,unsigned char *Byte32)
              {
                unsigned short temp;
                unsigned char  ensure,i;
                
                *Byte32 = 0;
                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯?
                SendLength(36);
                Sendcmd(0x18);
                AS608_SendData(NotePageNum);
                for(i=0;i<32;i++)
                {
                  AS608_SendData(Byte32[i]);
                  temp += Byte32[i];
                }
                temp =0x01+36+0x18+NotePageNum+temp;
                SendCheck(temp);
              
                return ensure;
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/01/2021 18:11:24 PAGE 11  

              }
              //è¯»è?°äº‹PS_ReadNotepad
              //åŠŸèƒ½ï¼?  è¯»å–FLASHç”¨æˆ·åŒºçš„128bytesæ•°æ®
              //å‚æ•°:  NotePageNum(0~15)
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡?è®¤å­—+ç”¨æˆ·ä¿¡æ¯
              unsigned char PS_ReadNotepad(unsigned char NotePageNum,unsigned char *Byte32)
              {
                unsigned short temp;
                unsigned char  ensure;
                
                *Byte32 = 0;
                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//å‘½ä»¤åŒ…æ ‡è¯?
                SendLength(0x04);
                Sendcmd(0x19);
                AS608_SendData(NotePageNum);
                temp = 0x01+0x04+0x19+NotePageNum;
                SendCheck(temp);
              
                return ensure;
              }
              #endif
 628          
 629          //è¯»æœ‰æ•ˆæ¨¡æ¿ä¸ªæ•? PS_ValidTempleteNum
 630          //åŠŸèƒ½ï¼šè?»æœ‰æ•ˆæ¨¡æ¿ä¸ªæ•?
 631          //å‚æ•°: æ—?
 632          //è¯´æ˜: æ¨¡å—è¿”å›ç¡?è®¤å­—+æœ‰æ•ˆæ¨¡æ¿ä¸?æ•°ValidN
 633          unsigned char PS_ValidTempleteNum(unsigned short *ValidN)
 634          {
 635   1        unsigned char ensure;
 636   1      
 637   1        if (AS608_PackHead() == 1)
 638   1          return 0xFF;
 639   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯?
 640   1        SendLength(0x03);
 641   1        Sendcmd(0x1d);
 642   1        SendCheck(0x01 + 0x03 + 0x1d);
 643   1      
 644   1        // ensure = ReturnFlag(&p);
 645   1        ensure = JudgeStr(1000, 0x05);
 646   1      
 647   1        *ValidN = (uart_rec_buff[10] << 8) + uart_rec_buff[11];
 648   1      
 649   1        return ensure;
 650   1      }
 651          
 652          unsigned char PS_AutoEnRoll(unsigned short id, unsigned char num, unsigned short param)
 653          {
 654   1        if (AS608_PackHead() == 1)
 655   1          return 0xFF;
 656   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯?
 657   1        SendLength(0x08);
 658   1        Sendcmd(0x31);
 659   1        AS608_SendData(id >> 8);
 660   1        AS608_SendData(id & 0xFF);
 661   1        AS608_SendData(num);
 662   1        AS608_SendData(param >> 8);
 663   1        AS608_SendData(param & 0xFF);
 664   1        SendCheck(0x01 + 0x08 + 0x31 + (id >> 8) + (id & 0xFF) + num + (param >> 8) + (param & 0xFF));
 665   1      
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/01/2021 18:11:24 PAGE 12  

 666   1        return 0;
 667   1      }
 668          
 669          //è‡?åŠ¨éªŒè¯æŒ‡çº? PS_AutoIdentify
 670          //åŠŸèƒ½ï¼?
 671          //1.è‡?åŠ¨é‡‡é›†æŒ‡çº¹ï¼Œåœ¨æŒ‡çº¹åº“ä¸?æœç´¢ç›?æ ‡æ¨¡æ¿å¹¶è¿”å›æœç´¢ç»“æœã€?
 672          //2.å¦‚æœç›?æ ‡æ¨¡æ¿åŒå½“å‰é‡‡é›†çš„æŒ‡çº¹æ¯”å¯¹å¾—åˆ†å¤§äºæœ€é«˜é˜€å€¼ï¼Œå¹¶ä¸”ç›?æ ‡æ¨¡æ¿ä¸ºä¸å®Œ
             -æ•´ç‰¹å¾åˆ™ä»¥é‡‡é›†çš„ç‰¹å¾æ›´æ–°ç›?æ ‡æ¨¡æ¿çš„ç©ºç™½åŒºåŸŸã€?
 673          //å‚æ•°: æ—?
 674          //è¯´æ˜: æ¨¡å—è¿”å›ç¡?è®¤å­—+é¡µç ï¼ˆç›¸é…æŒ‡çº¹æ¨¡æ¿ï¼‰
 675          unsigned char PS_AutoIdentify(unsigned short id, unsigned char level, unsigned short param)
 676          {
 677   1        if (AS608_PackHead() == 1)
 678   1          return 0xFF;
 679   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯?
 680   1        SendLength(0x08);
 681   1        Sendcmd(0x32);
 682   1        AS608_SendData(level);
 683   1        AS608_SendData(id >> 8);
 684   1        AS608_SendData(id & 0xFF);
 685   1        AS608_SendData(param >> 8);
 686   1        AS608_SendData(param & 0xFF);
 687   1        SendCheck(0x01 + 0x08 + 0x32 + (id >> 8) + (id & 0xFF) + level + (param >> 8) + (param & 0xFF));
 688   1      
 689   1        return 0;
 690   1      }
 691          
 692          //ä¸AS608æ¡æ‰‹ PS_HandShake
 693          //å‚æ•°: PS_Addråœ°å€æŒ‡é’ˆ
 694          //è¯´æ˜: æ¨¡å—è¿”æ–°åœ°å€ï¼ˆæ?£ç¡®åœ°å€ï¼?
 695          unsigned char PS_HandShake(unsigned long *PS_Addr)
 696          {
 697   1        *PS_Addr = 0;
 698   1      
 699   1        if (AS608_PackHead() == 1)
 700   1          return 0xFF;
 701   1        SendFlag(0x01);
 702   1        SendLength(0x03);
 703   1        Sendcmd(0x53);
 704   1        SendCheck(0x57);
 705   1      
 706   1        return JudgeStr(1000, 0x03);
 707   1      }
 708          
 709          unsigned char PS_Reset(void)
 710          {
 711   1        return 0;
 712   1      }
 713          
 714          unsigned char PS_Sleep(void)
 715          {
 716   1        if (AS608_PackHead() == 1)
 717   1          return 0xFF;
 718   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯?
 719   1        SendLength(0x03);
 720   1        Sendcmd(0x60);
 721   1        SendCheck(0x01 + 0x03 + 0x60);
 722   1        return 0;
 723   1      }
 724          
 725          //void AS608_log(void)
 726          //{
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/01/2021 18:11:24 PAGE 13  

 727          //  unsigned char i =0;
 728          ////  NRF_LOG_PRINTF_DEBUG("receive :");
 729          //  for(i=0;i<25;i++)
 730          //  {
 731          //    NRF_LOG_PRINTF_DEBUG("%2x ",as608_rec_buff[i]);
 732          //  }
 733          //  NRF_LOG_PRINTF_DEBUG("\n");
 734          //}
 735          
 736          void FP_Light(FP_COLOR_E light_id)
 737          {
 738   1        //  if(fp_flag == FP_LT5X)
 739   1        //  {
 740   1        //#ifdef __FP_LT5X_LIGHT_SUPPORT__
 741   1        unsigned short temp;
 742   1      
 743   1        unsigned char sure = 0; //,p=0;
 744   1        if (light_id == Light_Color)
 745   1          return;
 746   1      
 747   1        if (AS608_PackHead() == 1)
 748   1          return;
 749   1        SendFlag(0x01);
 750   1        SendLength(0x07);
 751   1        Sendcmd(0x41);
 752   1        switch (light_id)
 753   1        {
 754   2        case FP_BLUE:
 755   2          AS608_SendData(0x01);
 756   2          AS608_SendData(0x01);
 757   2          AS608_SendData(0x00);
 758   2          AS608_SendData(0x50);
 759   2          temp = 0x01 + 0x07 + 0x41 + 0x02 + 0x50;
 760   2          break;
 761   2        case FP_GREEN:
 762   2          AS608_SendData(0x01);
 763   2          AS608_SendData(0x02);
 764   2          AS608_SendData(0x02);
 765   2          AS608_SendData(0);
 766   2          temp = 0x01 + 0x07 + 0x41 + 0x05 + 0;
 767   2          break;
 768   2        case FP_RED:
 769   2          AS608_SendData(0x01);
 770   2          AS608_SendData(0x04);
 771   2          AS608_SendData(0x04);
 772   2          AS608_SendData(0);
 773   2          temp = 0x01 + 0x07 + 0x41 + 0x09 + 0;
 774   2          break;
 775   2        case FP_NONE_COLOR:
 776   2          AS608_SendData(0x04);
 777   2          AS608_SendData(0x00);
 778   2          AS608_SendData(0x00);
 779   2          AS608_SendData(0xC8);
 780   2          temp = 0x01 + 0x07 + 0x41 + 0x04 + 0xC8;
 781   2          break;
 782   2        }
 783   1        SendCheck(temp);
 784   1      
 785   1        //sure=ReturnFlag(&p);
 786   1        sure = JudgeStr(1000, 0x03);
 787   1      
 788   1        // if (sure == 0)
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/01/2021 18:11:24 PAGE 14  

 789   1        Light_Color = light_id;
 790   1      
 791   1        //#endif
 792   1      
 793   1        //  }
 794   1      }
 795          
 796          FP_COLOR_E FP_Get_Light(void)
 797          {
 798   1        return Light_Color;
 799   1      }
 800          
 801          FP_COLOR_E FP_Set_Light(FP_COLOR_E light_id)
 802          {
 803   1        Light_Color = light_id;
 804   1        return Light_Color;
 805   1      }
 806          
 807          unsigned char FP_Get_Start_Flag(void)
 808          {
 809   1        if (uart_getbuflen > 0)
 810   1        {
 811   2          unsigned char i;
 812   2      
 813   2          for (i = 0; i < uart_getbuflen; i++)
 814   2          {
 815   3            if (uart_get_buf[i] == 0x55)
 816   3            {
 817   4              uart_getbuflen = 0;
 818   4              return 1;
 819   4            }
 820   3          }
 821   2        }
 822   1        return 0;
 823   1      }
 824          
 825          //#endif//__PREIPHERAL_FP_LT5X_SUPPORT__


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1948    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     25      55
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
