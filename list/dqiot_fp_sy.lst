C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/10/2021 16:15:00 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DQIOT_FP_SY
OBJECT MODULE PLACED IN .\output\dqiot_fp_sy.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE source\dqiot_fp_sy.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\includ
                    -e;.\Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd
                    -_rfid;.\mmi_inc) DEBUG PRINT(.\list\dqiot_fp_sy.lst) TABS(2) OBJECT(.\output\dqiot_fp_sy.obj)

line level    source

   1          #include "mmi_feature.h"
   2          #if defined(__LOCK_FP_SY_SUPPORT__)
   3          #include "string.h"
   4          #include "dqiot_fp_sy.h"
   5          #include "delay.h"
   6          #include "dqiot_drv.h"
   7          #include "mcu02_uart.h"
   8          // #include <stdio.h>
   9          
  10          //unsigned long fp_pin_irq_mask;
  11          
  12          //fp_irq_handle_callback fp_callback_handle;
  13          //fp_uart_handle_callback fp_uart_handle = 0;
  14          //unsigned char fp_Mode = 0;
  15          //static unsigned char fp_temp_mode = 0;
  16          
  17          static unsigned char uart_rec_buff[20];
  18          
  19          //static FP_TYPE fp_flag = FP_NONE;
  20          static FP_COLOR_E Light_Color = FP_NONE_COLOR;
  21          //static unsigned char ps_start_flag = 0;
  22          
  23          extern unsigned char uart_get_buf[];
  24          extern unsigned char uart_getbuflen;
  25          
  26          //unsigned short  ReceiveInfo( unsigned char *rec_data);
  27          //void AS608_log(void);
  28          
  29          //void fp_set_irq_handle(fp_irq_handle_callback cb)
  30          //{
  31          //  fp_callback_handle = cb;
  32          //}
  33          
  34          //void fp_set_uart_handle(fp_uart_handle_callback cb)
  35          //{
  36          //  fp_uart_handle = cb;
  37          //}
  38          
  39          ///FP_TYPE fp_get_type(void)
  40          //{
  41          //  return fp_flag;
  42          
  43          //}
  44          
  45          //--------------------------------------------------------------------------------
  46          
  47          //static unsigned char uart_len=0;
  48          //static unsigned short uart_maxlen = 0;
  49          //static unsigned char uart_buff[25]={0};
  50          
  51          //static void UART_Callback(unsigned char send_data)
  52          //{
  53          //  send_data = 0;
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/10/2021 16:15:00 PAGE 2   

  54          //}
  55          
  56          //unsigned char fp_GetModeState(void)
  57          //{
  58          //  return fp_Mode;
  59          //}
  60          
  61          //void fp_SetModeState(unsigned char s)
  62          //{
  63          //  fp_Mode = s;
  64          
  65          //  if(s == 0)
  66          //    Light_Color = FP_NONE_COLOR;
  67          //}
  68          
  69          //static void PS_UART_Callback(unsigned char send_data)
  70          //{
  71          //  if(send_data == 0x55 )
  72          //  {
  73          //    ps_start_flag = 1;
  74          //  }
  75          //}
  76          
  77          //void FP_PowerOn(void)
  78          //{
  79          
  80          //}
  81          
  82          /**
  83            * @brief  AS608_USARTä¸²å£å‘æŒ‡çº¹æ¨¡å—ä¼ é€’æ•°æ® 
  84            * @param  data;ä¼ è¾“çš„æ•°æ®
  85            */
  86          void AS608_SendData(unsigned char send_data)
  87          {
  88   1        uart_tx_byte(UART0, send_data);
  89   1      }
  90          
  91          /**
  92            * @brief  AS608_USARTä¸²å£å‘æŒ‡çº¹æ¨¡å—å‘½ä»¤åŒ…å¤´æ ¼å¼ 
  93            * @param  æ— 
  94            */
  95          unsigned char AS608_PackHead(void)
  96          {
  97   1      
  98   1        //unsigned char delay_times = 30;
  99   1      
 100   1        //while(ps_start_flag==0&&delay_times>0)
 101   1        //{
 102   1        //  delay_times--;
 103   1        //}
 104   1        //if(ps_start_flag == 0)
 105   1        //{
 106   1        //  return 1;
 107   1        //}
 108   1        //else if(ps_start_flag == 1)
 109   1        //{
 110   1        //  uart_init_block();
 111   1        //  ps_start_flag = 2;
 112   1        //}
 113   1      
 114   1        // dqiot_drv_uart0B_init();
 115   1        uart_getbuflen = 0;
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/10/2021 16:15:00 PAGE 3   

 116   1      
 117   1        /*åŒ…å¤´*/
 118   1        AS608_SendData(0xEF);
 119   1        AS608_SendData(0x01);
 120   1      
 121   1        /*æŒ‡çº¹æ¨¡å—åœ°å€*/
 122   1        AS608_SendData(AS608_Addr >> 24);
 123   1        AS608_SendData(AS608_Addr >> 16);
 124   1        AS608_SendData(AS608_Addr >> 8);
 125   1        AS608_SendData(AS608_Addr);
 126   1      
 127   1        return 0;
 128   1      }
 129          
 130          unsigned char AS608_PackHead2(void)
 131          {
 132   1      
 133   1        /*åŒ…å¤´*/
 134   1        AS608_SendData(0xEF);
 135   1        AS608_SendData(0x01);
 136   1      
 137   1        /*æŒ‡çº¹æ¨¡å—åœ°å€*/
 138   1        AS608_SendData(AS608_Addr >> 24);
 139   1        AS608_SendData(AS608_Addr >> 16);
 140   1        AS608_SendData(AS608_Addr >> 8);
 141   1        AS608_SendData(AS608_Addr);
 142   1      
 143   1        return 0;
 144   1      }
 145          
 146          /**
 147            * @brief  å‘é€åŒ…æ ‡è¯†
 148            * @param  flag:åŒ…æ ‡è¯†ä½
 149            * @retval æ— 
 150            */
 151          void SendFlag(unsigned char flag)
 152          {
 153   1        AS608_SendData(flag);
 154   1      }
 155          
 156          /**
 157            * @brief  å‘é€åŒ…é•¿åº¦
 158            * @param  length:åŒ…é•¿åº¦
 159            * @retval æ— 
 160            */
 161          void SendLength(unsigned short length)
 162          {
 163   1        AS608_SendData(length >> 8);
 164   1        AS608_SendData(length);
 165   1      }
 166          
 167          /**
 168            * @brief  å‘é€æŒ‡ä»¤ç 
 169            * @param  cmd;æŒ‡ä»¤ç 
 170            * @retval æ— 
 171            */
 172          void Sendcmd(unsigned char cmd)
 173          {
 174   1        AS608_SendData(cmd);
 175   1      }
 176          
 177          /**
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/10/2021 16:15:00 PAGE 4   

 178            * @brief  å‘é€æ ¡éªŒå’Œ
 179            * @param  check:æ£€æŸ¥ä½
 180            * @retval æ— 
 181            */
 182          void SendCheck(unsigned short check)
 183          {
 184   1        AS608_SendData(check >> 8);
 185   1        AS608_SendData(check);
 186   1      }
 187          
 188          /**
 189            * @brief  åˆ¤æ–­ä¸­æ–­æ¥æ”¶çš„æ•°ç»„æœ‰æ²¡æœ‰åº”ç­”åŒ…
 190            * @param  
 191            * waittimeä¸ºç­‰å¾…ä¸­æ–­æ¥æ”¶æ•°æ®çš„æ—¶é—´(å•ä½1ms)
 192            * lengthä¸ºåŒ…é•¿åº¦
 193            * @return æ•°æ®åŒ…ç¡®è®¤ç 
 194            * @note   1 failed
 195            * @see    none
 196            */
 197          static u8 JudgeStr(u16 waittime, u8 length)
 198          {
 199   1        u8 i = 0, j = 0;
 200   1        //u8 str[8];
 201   1        //str[0] = 0xEF;
 202   1        //str[1] = 0x01;
 203   1        //str[2] = AS608_Addr >> 24;
 204   1        //str[3] = AS608_Addr >> 16;
 205   1        //str[4] = AS608_Addr >> 8;
 206   1        //str[5] = AS608_Addr;
 207   1        //str[6] = 0x07;
 208   1      
 209   1        memset(uart_rec_buff, 0, sizeof(uart_rec_buff));
 210   1      
 211   1        while (--waittime)
 212   1        {
 213   2          delay_ms(1);
 214   2      
 215   2          /* æ¥æ”¶åˆ°ä¸€æ¬¡æ•°æ® */
 216   2          if (uart_getbuflen >= 9 + length)
 217   2          {
 218   3            /* å¯»æ‰¾0xEFä½ç½® */
 219   3            for (i = 0; i < uart_getbuflen; i++)
 220   3            {
 221   4              if (uart_get_buf[i] == 0xEF)
 222   4                break;
 223   4            }
 224   3      
 225   3            /* åˆ¤æ–­æ˜¯å¦ä¸ºåº”ç­”åŒ… */
 226   3            if (uart_get_buf[i] == 0xEF && uart_get_buf[i + 1] == 0x01 && uart_get_buf[i + 6] == 0x07 && ((uart_get
             -_buf[i + 7] << 8) + uart_get_buf[i + 8]) == length)
 227   3            {
 228   4              for (i; i < uart_getbuflen; i++)
 229   4              {
 230   5                uart_rec_buff[j] = uart_get_buf[i];
 231   5                j++;
 232   5              }
 233   4      
 234   4              /* æ¸…ç©ºç¼“å­˜ */
 235   4              uart_getbuflen = 0;
 236   4      
 237   4              return uart_rec_buff[9];
 238   4            }
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/10/2021 16:15:00 PAGE 5   

 239   3          }
 240   2        }
 241   1      
 242   1        return 1;
 243   1      }
 244          
 245          #if 0
              /**
                * @brief  ä»ç¼“å†²åŒºè¯»å‡ºç¡®è®¤ç 
                * @param  *i:è¿”å›å€¼ï¼ˆç¡®è®¤ç ï¼‰
                * @retval æ— 
                */
              unsigned char  ReturnFlag( unsigned char *i)
              { 
                *i = ReceiveInfo(uart_rec_buff);
                return *i;
              }
              
              unsigned char  ReceiveInfo( unsigned char *rec_data)
              {
                unsigned char *temp_data;
                unsigned short rev_length = 0;
                unsigned char error = 0;
                unsigned char a = 9;
              
                memset(uart_rec_buff,0,sizeof(uart_rec_buff));
              
                do
                {
                  //error = nrf_drv_uart_rx(rec_data,1);
                  //if(error == NRF_ERROR_INTERNAL)
                  //  return 0xFF;
                  if(rec_data[0] == 0xEF)
                    break;
                  if(a==0)
                    return 0xFF;
                }while(a--);
                
              
                rev_length = (rec_data[7]<<8)+rec_data[8];
                temp_data = rec_data+9;
              
                if(rev_length!=0)
                  ;//nrf_drv_uart_rx(temp_data,rev_length);
                else
                  return 0xFF;
              
                AS608_log();
                return temp_data[0];
              }
              #endif
 290          
 291          unsigned char PS_GetEcho(void)
 292          {
 293   1        AS608_PackHead2();
 294   1        SendFlag(0x01);
 295   1        SendLength(0x03);
 296   1        Sendcmd(0x53); /*ç”Ÿæˆç‰¹å¾æŒ‡ä»¤*/
 297   1        SendCheck(0x57);
 298   1      
 299   1        //sure=ReturnFlag(&p);
 300   1        return JudgeStr(1000, 0x03);
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/10/2021 16:15:00 PAGE 6   

 301   1      }
 302          
 303          //å½•å…¥å›¾åƒ PS_GetImage
 304          //åŠŸèƒ½:æ¢æµ‹æ‰‹æŒ‡ï¼Œæ¢æµ‹åˆ°åå½•å…¥æŒ‡çº¹å›¾åƒå­˜äºImageBufferã€‚
 305          //æ¨¡å—è¿”å›ç¡®è®¤å­—
 306          unsigned char PS_GetImage(void)
 307          {
 308   1        //delay_ms(300);
 309   1        if (AS608_PackHead() == 1)
 310   1          return 0xFF;
 311   1        SendFlag(0x01); /*å‘½ä»¤åŒ…æ ‡è¯†*/
 312   1        SendLength(0x03);
 313   1        Sendcmd(0x01); /*å½•æŒ‡çº¹æŒ‡ä»¤*/
 314   1        SendCheck(0x01 + 0x03 + 0x01);
 315   1      
 316   1        //nrf_delay_ms(50);        /*ç­‰å¾…æŒ‡çº¹è¯†åˆ«æ¨¡å—å¤„ç†æ•°æ®*/
 317   1      
 318   1        // sure = ReturnFlag(&p);
 319   1        return JudgeStr(1000, 0x03);
 320   1      }
 321          
 322          //ç”Ÿæˆç‰¹å¾ PS_GenChar
 323          //åŠŸèƒ½:å°†ImageBufferä¸­çš„åŸå§‹å›¾åƒç”ŸæˆæŒ‡çº¹ç‰¹å¾æ–‡ä»¶å­˜äºCharBuffer1æˆ–CharBuffer2
 324          //å‚æ•°:BufferID --> charBuffer1:0x01  charBuffer1:0x02
 325          //æ¨¡å—è¿”å›ç¡®è®¤å­—
 326          unsigned char PS_GenChar(unsigned char BufferID)
 327          {
 328   1        if (AS608_PackHead() == 1)
 329   1          return 0xFF;
 330   1        SendFlag(0x01);
 331   1        SendLength(0x04);
 332   1        Sendcmd(0x02); /*ç”Ÿæˆç‰¹å¾æŒ‡ä»¤*/
 333   1        AS608_SendData(BufferID);
 334   1        SendCheck(0x01 + 0x04 + 0x02 + BufferID);
 335   1        return JudgeStr(1000, 0x03);
 336   1      }
 337          
 338          //ç²¾ç¡®æ¯”å¯¹ä¸¤æšæŒ‡çº¹ç‰¹å¾ PS_Match
 339          //åŠŸèƒ½:ç²¾ç¡®æ¯”å¯¹CharBuffer1 ä¸CharBuffer2 ä¸­çš„ç‰¹å¾æ–‡ä»¶
 340          //æ¨¡å—è¿”å›ç¡®è®¤å­—
 341          unsigned char PS_Match(void)
 342          {
 343   1        if (AS608_PackHead() == 1)
 344   1          return 0xFF;
 345   1        SendFlag(0x01);
 346   1        SendLength(0x03);
 347   1        Sendcmd(0x03); /*ç²¾ç¡®æ¯”å¯¹æŒ‡ä»¤*/
 348   1        SendCheck(0x01 + 0x03 + 0x03);
 349   1      
 350   1        // sure = ReturnFlag(&p);
 351   1        return JudgeStr(1000, 0x05);
 352   1      }
 353          //æœç´¢æŒ‡çº¹ PS_Search
 354          //åŠŸèƒ½:ä»¥CharBuffer1æˆ–CharBuffer2ä¸­çš„ç‰¹å¾æ–‡ä»¶æœç´¢æ•´ä¸ªæˆ–éƒ¨åˆ†æŒ‡çº¹åº“.è‹¥æœç´¢åˆ°ï¼Œåˆ™è¿
             -”å›é¡µç ã€‚
 355          //å‚æ•°:  BufferID @ref CharBuffer1  CharBuffer2
 356          //è¯´æ˜:  æ¨¡å—è¿”å›ï¿½?è®¤å­—ï¼Œé¡µç ï¼ˆç›¸é…æŒ‡çº¹æ¨¡æ¿ï¿½?
 357          unsigned char PS_Search(unsigned char BufferID, unsigned short StartPage, unsigned short PageNum, unsigned
             - short *p)
 358          {
 359   1        unsigned char sure;
 360   1        if (AS608_PackHead() == 1)
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/10/2021 16:15:00 PAGE 7   

 361   1          return 0xFF;
 362   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 363   1        SendLength(0x08);
 364   1        Sendcmd(0x04);
 365   1        AS608_SendData(BufferID);
 366   1        AS608_SendData(StartPage >> 8);
 367   1        AS608_SendData(StartPage);
 368   1        AS608_SendData(PageNum >> 8);
 369   1        AS608_SendData(PageNum);
 370   1        SendCheck(0x01 + 0x08 + 0x04 + BufferID + (StartPage >> 8) + (unsigned char)StartPage + (PageNum >> 8) + 
             -(unsigned char)PageNum);
 371   1        sure = JudgeStr(1000, 0x07);
 372   1        *p = (uart_rec_buff[10] << 8) + uart_rec_buff[11];
 373   1        return sure;
 374   1      }
 375          
 376          //åˆå¹¶ç‰¹å¾ï¼ˆç”Ÿæˆæ¨¡æ¿ï¼‰PS_RegModel
 377          //åŠŸèƒ½:å°†CharBuffer1ä¸CharBuffer2ä¸­çš„ç‰¹å¾æ–‡ä»¶åˆå¹¶ç”Ÿæˆ æ¨¡æ¿,ç»“æœå­˜äºCharBuffer1ä¸CharB
             -uffer2
 378          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
 379          unsigned char PS_RegModel(void)
 380          {
 381   1        if (AS608_PackHead() == 1)
 382   1          return 0xFF;
 383   1        SendFlag(0x01);
 384   1        SendLength(0x03);
 385   1        Sendcmd(0x05); /*åˆå¹¶ç‰¹å¾æŒ‡ä»¤*/
 386   1        SendCheck(0x01 + 0x03 + 0x05);
 387   1      
 388   1        // sure = ReturnFlag(&p);
 389   1        return JudgeStr(1000, 0x03);
 390   1      }
 391          
 392          //å‚¨å­˜æ¨¡æ¿ PS_StoreChar
 393          //åŠŸèƒ½:å°† CharBuffer1 æˆ– CharBuffer2 ä¸­çš„æ¨¡æ¿æ–‡ä»¶å­˜åˆ° PageID å·flashæ•°æ®åº“ä½ç½®ã€‚
 394          //å‚æ•°:  BufferID @ref charBuffer1:0x01 charBuffer1:0x02
 395          //       PageIDï¼ˆæŒ‡çº¹åº“ä½ç½®å·ï¼‰
 396          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
 397          unsigned char PS_StoreChar(unsigned char BufferID, unsigned short PageID)
 398          {
 399   1        if (AS608_PackHead() == 1)
 400   1          return 0xFF;
 401   1        SendFlag(0x01);
 402   1        SendLength(0x06);
 403   1        Sendcmd(0x06); /*å­˜å‚¨æ¨¡æ¿æŒ‡ä»¤*/
 404   1        AS608_SendData(BufferID);
 405   1        AS608_SendData(PageID >> 8);
 406   1        AS608_SendData(PageID);
 407   1        SendCheck(0x01 + 0x06 + 0x06 + BufferID + (PageID >> 8) + (unsigned char)PageID);
 408   1      
 409   1        // sure = ReturnFlag(&p);
 410   1        return JudgeStr(1000, 0x03);
 411   1      }
 412          
 413          //åˆ é™¤æ¨¡æ¿ PS_DeletChar
 414          //åŠŸèƒ½:  åˆ é™¤flashæ•°æ®åº“ä¸­æŒ‡å®šIDå·å¼€å§‹çš„Nä¸ªæŒ‡çº¹æ¨¡æ¿
 415          //å‚æ•°:  PageID(æŒ‡çº¹åº“æ¨¡æ¿å·)ï¼ŒNåˆ é™¤çš„æ¨¡æ¿ä¸ªæ•°ã€‚
 416          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
 417          unsigned char PS_DeletChar(unsigned short PageID, unsigned short N)
 418          {
 419   1        if (AS608_PackHead() == 1)
 420   1          return 0xFF;
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/10/2021 16:15:00 PAGE 8   

 421   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 422   1        SendLength(0x07);
 423   1        Sendcmd(0x0C); /*åˆ é™¤æŒ‡å®šæŒ‡çº¹æ¨¡æ¿æŒ‡ä»¤*/
 424   1        AS608_SendData(PageID >> 8);
 425   1        AS608_SendData(PageID);
 426   1        AS608_SendData(N >> 8);
 427   1        AS608_SendData(N);
 428   1        SendCheck(0x01 + 0x07 + 0x0C + (PageID >> 8) + (unsigned char)PageID + (N >> 8) + (unsigned char)N);
 429   1      
 430   1        //AS608_DELAY_MS(400);
 431   1      
 432   1        // sure = ReturnFlag(&p);
 433   1        return JudgeStr(1000, 0x03);
 434   1      }
 435          
 436          //é«˜é€Ÿæœç´¢PS_HighSpeedSearch
 437          //åŠŸèƒ½ï¼šä»¥ CharBuffer1æˆ–CharBuffer2ä¸­çš„ç‰¹å¾æ–‡ä»¶é«˜é€Ÿæœç´¢æ•´ä¸ªæˆ–éƒ¨åˆ†æŒ‡çº¹åº“ã€‚
 438          //      è‹¥æœç´¢åˆ°ï¼Œåˆ™è¿”å›é¡µç ,è¯¥æŒ‡ä»¤å¯¹äºçš„ç¡®å­˜åœ¨äºæŒ‡çº¹åº“ä¸­ ï¼Œä¸”ç™»å½•æ—¶è´¨é‡
 439          //      å¾ˆå¥½çš„æŒ‡çº¹ï¼Œä¼šå¾ˆå¿«ç»™å‡ºæœç´¢ç»“æœã€‚
 440          //å‚æ•°:  BufferIDï¼Œ StartPage(èµ·å§‹é¡µ)ï¼ŒPageNumï¼ˆé¡µæ•°ï¼‰
 441          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—+é¡µç ï¼ˆç›¸é…æŒ‡çº¹æ¨¡æ¿ï¼‰
 442          unsigned char PS_HighSpeedSearch(unsigned char BufferID, unsigned short StartPage, unsigned short PageNum,
             - unsigned short *p)
 443          {
 444   1        unsigned char ensure;
 445   1      
 446   1        if (AS608_PackHead() == 1)
 447   1          return 0xFF;
 448   1        SendFlag(0x01);
 449   1        SendLength(0x08);
 450   1        Sendcmd(0x1b); /*é«˜é€Ÿæœç´¢æŒ‡çº¹åº“æŒ‡ä»¤*/
 451   1        AS608_SendData(BufferID);
 452   1        AS608_SendData(StartPage >> 8);
 453   1        AS608_SendData(StartPage);
 454   1        AS608_SendData(PageNum >> 8);
 455   1        AS608_SendData(PageNum);
 456   1        SendCheck(0x01 + 0x08 + 0x1b + BufferID + (StartPage >> 8) + (unsigned char)StartPage + (PageNum >> 8) + 
             -(unsigned char)PageNum);
 457   1      
 458   1        // ensure = ReturnFlag(&rc);
 459   1        ensure = JudgeStr(1000, 0x07);
 460   1      
 461   1        *p = (uart_rec_buff[10] << 8) + uart_rec_buff[11];
 462   1      
 463   1        return ensure;
 464   1      }
 465          
 466          //æ¸…ç©ºæŒ‡çº¹åº“ PS_Empty
 467          //åŠŸèƒ½:  åˆ é™¤flashæ•°æ®åº“ä¸­æ‰€æœ‰æŒ‡çº¹æ¨¡æ¿
 468          //å‚æ•°:  æ— 
 469          //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
 470          unsigned char PS_Empty(void)
 471          {
 472   1        if (AS608_PackHead() == 1)
 473   1          return 0xFF;
 474   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 475   1        SendLength(0x03);
 476   1        Sendcmd(0x0D);
 477   1        SendCheck(0x01 + 0x03 + 0x0D);
 478   1      
 479   1        // sure = ReturnFlag(&p);
 480   1        return JudgeStr(1000, 0x03);
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/10/2021 16:15:00 PAGE 9   

 481   1      }
 482          
 483          #if 0
              /**
                * @brief  æ£€æŸ¥STM32ä¸æŒ‡çº¹æ¨¡å—çš„é€šä¿¡è¿æ¥
                * @param  PS_AddræŒ‡çº¹æ¨¡å—åœ°å€
                * @retval è¿”å›å€¼0é€šè®¯æˆåŠŸ;1è¡¨ç¤ºé€šè®¯ä¸æˆåŠŸ
                */
              unsigned char PS_Connect(unsigned long *PS_Addr)
              {
                PS_Addr = 0;
                if(AS608_PackHead()==1)
                  return 0xFF;
                AS608_SendData(0X01);
                AS608_SendData(0X00);
                AS608_SendData(0X00);
                return 1;   
              }
              
              //å†™ç³»ç»Ÿå¯„å­˜å™¨ PS_WriteReg
              //åŠŸèƒ½:  å†™æ¨¡å—å¯„å­˜å™¨
              //å‚æ•°:  å¯„å­˜å™¨åºå·RegNum:4\5\6
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
              unsigned char PS_WriteReg(unsigned char RegNum, unsigned char DATA)
              {
                unsigned short temp;
                unsigned short sure,p=0;
              
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//é›æˆ’æŠ¤é–å‘®çˆ£ç’‡
                SendLength(0x05);
                Sendcmd(0x0E);
                AS608_SendData(RegNum);
                AS608_SendData(DATA);
                temp = RegNum+DATA+0x01+0x05+0x0E;
                SendCheck(temp);
                sure=ReturnFlag(&p);
                return sure;
              }
              //è¯»ç³»ç»ŸåŸºæœ¬å‚æ•° PS_ReadSysPara
              //åŠŸèƒ½:  è¯»å–æ¨¡å—çš„åŸºæœ¬å‚æ•°ï¼ˆæ³¢ç‰¹ç‡ï¼ŒåŒ…å¤§å°ç­‰)
              //å‚æ•°:  æ— 
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­— + åŸºæœ¬å‚æ•°ï¼ˆ16bytesï¼‰
              unsigned char PS_ReadSysPara(void)
              {
                unsigned short temp;
                unsigned char  ensure;
                unsigned char  *send_data;
                unsigned short p=0;
                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//é›æˆ’æŠ¤é–å‘®çˆ£ç’‡
                SendLength(0x03);
                Sendcmd(0x0F);
                temp = 0x01+0x03+0x0F;
                SendCheck(temp);
                ensure=ReturnFlag(&p);
                if(send_data)
                {
              
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/10/2021 16:15:00 PAGE 10  

                }   
                else
                  ensure=0xff;
                if(ensure==0x00)
                {
              
                }
                return ensure;
              }
              //è®¾ç½®æ¨¡å—åœ°å€ PS_SetAddr
              //åŠŸèƒ½:  è®¾ç½®æ¨¡å—åœ°å€
              //å‚æ•°:  PS_addr
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
              unsigned char PS_SetAddr(unsigned long PS_addr)
              {
                unsigned short temp;
                unsigned char  ensure;
              
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//å‘½ä»¤åŒ…æ ‡è¯†
                SendLength(0x07);
                Sendcmd(0x15);
                AS608_SendData(PS_addr>>24);
                AS608_SendData(PS_addr>>16);
                AS608_SendData(PS_addr>>8);
                AS608_SendData(PS_addr);
                temp = 0x01+0x07+0x15
                +(unsigned char)(PS_addr>>24)+(unsigned char)(PS_addr>>16)
                +(unsigned char)(PS_addr>>8) +(unsigned char)PS_addr;       
                SendCheck(temp);
              
                return ensure;
              }
              //åŠŸèƒ½ï¼š æ¨¡å—å†…éƒ¨ä¸ºç”¨æˆ·å¼€è¾Ÿäº†256bytesçš„FLASHç©ºé—´ç”¨äºå­˜ç”¨æˆ·è®°äº‹æœ¬,
              //  è¯¥è®°äº‹æœ¬é€»è¾‘ä¸Šè¢«åˆ†æˆ 16 ä¸ªé¡µã€‚
              //å‚æ•°:  NotePageNum(0~15),Byte32(è¦å†™å…¥å†…å®¹ï¼Œ32ä¸ªå­—èŠ‚)
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—
              unsigned char PS_WriteNotepad(unsigned char NotePageNum,unsigned char *Byte32)
              {
                unsigned short temp;
                unsigned char  ensure,i;
                
                *Byte32 = 0;
                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
                SendLength(36);
                Sendcmd(0x18);
                AS608_SendData(NotePageNum);
                for(i=0;i<32;i++)
                {
                  AS608_SendData(Byte32[i]);
                  temp += Byte32[i];
                }
                temp =0x01+36+0x18+NotePageNum+temp;
                SendCheck(temp);
              
                return ensure;
              }
              //è¯»è®°äº‹PS_ReadNotepad
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/10/2021 16:15:00 PAGE 11  

              //åŠŸèƒ½ï¼š  è¯»å–FLASHç”¨æˆ·åŒºçš„128bytesæ•°æ®
              //å‚æ•°:  NotePageNum(0~15)
              //è¯´æ˜:  æ¨¡å—è¿”å›ç¡®è®¤å­—+ç”¨æˆ·ä¿¡æ¯
              unsigned char PS_ReadNotepad(unsigned char NotePageNum,unsigned char *Byte32)
              {
                unsigned short temp;
                unsigned char  ensure;
                
                *Byte32 = 0;
                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//å‘½ä»¤åŒ…æ ‡è¯†
                SendLength(0x04);
                Sendcmd(0x19);
                AS608_SendData(NotePageNum);
                temp = 0x01+0x04+0x19+NotePageNum;
                SendCheck(temp);
              
                return ensure;
              }
              #endif
 627          
 628          //è¯»æœ‰æ•ˆæ¨¡æ¿ä¸ªæ•° PS_ValidTempleteNum
 629          //åŠŸèƒ½ï¼šè¯»æœ‰æ•ˆæ¨¡æ¿ä¸ªæ•°
 630          //å‚æ•°: æ— 
 631          //è¯´æ˜: æ¨¡å—è¿”å›ç¡®è®¤å­—+æœ‰æ•ˆæ¨¡æ¿ä¸ªæ•°ValidN
 632          unsigned char PS_ValidTempleteNum(unsigned short *ValidN)
 633          {
 634   1        unsigned char ensure;
 635   1      
 636   1        if (AS608_PackHead() == 1)
 637   1          return 0xFF;
 638   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 639   1        SendLength(0x03);
 640   1        Sendcmd(0x1d);
 641   1        SendCheck(0x01 + 0x03 + 0x1d);
 642   1      
 643   1        // ensure = ReturnFlag(&p);
 644   1        ensure = JudgeStr(1000, 0x05);
 645   1      
 646   1        *ValidN = (uart_rec_buff[10] << 8) + uart_rec_buff[11];
 647   1      
 648   1        return ensure;
 649   1      }
 650          
 651          unsigned char PS_AutoEnRoll(unsigned short id, unsigned char num, unsigned short param)
 652          {
 653   1        if (AS608_PackHead() == 1)
 654   1          return 0xFF;
 655   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 656   1        SendLength(0x08);
 657   1        Sendcmd(0x31);
 658   1        AS608_SendData(id >> 8);
 659   1        AS608_SendData(id & 0xFF);
 660   1        AS608_SendData(num);
 661   1        AS608_SendData(param >> 8);
 662   1        AS608_SendData(param & 0xFF);
 663   1        SendCheck(0x01 + 0x08 + 0x31 + (id >> 8) + (id & 0xFF) + num + (param >> 8) + (param & 0xFF));
 664   1      
 665   1        return 0;
 666   1      }
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/10/2021 16:15:00 PAGE 12  

 667          
 668          //è‡ªåŠ¨éªŒè¯æŒ‡çº¹ PS_AutoIdentify
 669          //åŠŸèƒ½ï¼š
 670          //1.è‡ªåŠ¨é‡‡é›†æŒ‡çº¹ï¼Œåœ¨æŒ‡çº¹åº“ä¸­æœç´¢ç›®æ ‡æ¨¡æ¿å¹¶è¿”å›æœç´¢ç»“æœã€‚
 671          //2.å¦‚æœç›®æ ‡æ¨¡æ¿åŒå½“å‰é‡‡é›†çš„æŒ‡çº¹æ¯”å¯¹å¾—åˆ†å¤§äºæœ€é«˜é˜€å€¼ï¼Œå¹¶ä¸”ç›®æ ‡æ¨¡æ¿ä¸ºä¸å®Œ
             -æ•´ç‰¹å¾åˆ™ä»¥é‡‡é›†çš„ç‰¹å¾æ›´æ–°ç›®æ ‡æ¨¡æ¿çš„ç©ºç™½åŒºåŸŸã€‚
 672          //å‚æ•°: æ— 
 673          //è¯´æ˜: æ¨¡å—è¿”å›ç¡®è®¤å­—+é¡µç ï¼ˆç›¸é…æŒ‡çº¹æ¨¡æ¿ï¼‰
 674          unsigned char PS_AutoIdentify(unsigned short id, unsigned char level, unsigned short param)
 675          {
 676   1        if (AS608_PackHead() == 1)
 677   1          return 0xFF;
 678   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 679   1        SendLength(0x08);
 680   1        Sendcmd(0x32);
 681   1        AS608_SendData(level);
 682   1        AS608_SendData(id >> 8);
 683   1        AS608_SendData(id & 0xFF);
 684   1        AS608_SendData(param >> 8);
 685   1        AS608_SendData(param & 0xFF);
 686   1        SendCheck(0x01 + 0x08 + 0x32 + (id >> 8) + (id & 0xFF) + level + (param >> 8) + (param & 0xFF));
 687   1      
 688   1        return 0;
 689   1      }
 690          
 691          //ä¸AS608æ¡æ‰‹ PS_HandShake
 692          //å‚æ•°: PS_Addråœ°å€æŒ‡é’ˆ
 693          //è¯´æ˜: æ¨¡å—è¿”æ–°åœ°å€ï¼ˆæ­£ç¡®åœ°å€ï¼‰
 694          unsigned char PS_HandShake(unsigned long *PS_Addr)
 695          {
 696   1        *PS_Addr = 0;
 697   1      
 698   1        if (AS608_PackHead() == 1)
 699   1          return 0xFF;
 700   1        SendFlag(0x01);
 701   1        SendLength(0x03);
 702   1        Sendcmd(0x53);
 703   1        SendCheck(0x57);
 704   1      
 705   1        return JudgeStr(1000, 0x03);
 706   1      }
 707          
 708          unsigned char PS_Reset(void)
 709          {
 710   1        return 0;
 711   1      }
 712          
 713          unsigned char PS_Sleep(void)
 714          {
 715   1        if (AS608_PackHead() == 1)
 716   1          return 0xFF;
 717   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡è¯†
 718   1        SendLength(0x03);
 719   1        Sendcmd(0x60);
 720   1        SendCheck(0x01 + 0x03 + 0x60);
 721   1        return 0;
 722   1      }
 723          
 724          //void AS608_log(void)
 725          //{
 726          //  unsigned char i =0;
 727          ////  NRF_LOG_PRINTF_DEBUG("receive :");
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/10/2021 16:15:00 PAGE 13  

 728          //  for(i=0;i<25;i++)
 729          //  {
 730          //    NRF_LOG_PRINTF_DEBUG("%2x ",as608_rec_buff[i]);
 731          //  }
 732          //  NRF_LOG_PRINTF_DEBUG("\n");
 733          //}
 734          
 735          void FP_Light(FP_COLOR_E light_id)
 736          {
 737   1        //  if(fp_flag == FP_LT5X)
 738   1        //  {
 739   1        //#ifdef __FP_LT5X_LIGHT_SUPPORT__
 740   1        unsigned short temp;
 741   1        unsigned char sure = 0; //,p=0;
 742   1      
 743   1        if (light_id == Light_Color)
 744   1          return;
 745   1      
 746   1        if (AS608_PackHead() == 1)
 747   1          return;
 748   1        SendFlag(0x01);
 749   1        SendLength(0x07);
 750   1        Sendcmd(0x41);
 751   1        switch (light_id)
 752   1        {
 753   2        case FP_BLUE:
 754   2          AS608_SendData(0x01);
 755   2          AS608_SendData(0x01);
 756   2          AS608_SendData(0x00);
 757   2          AS608_SendData(0x50);
 758   2          temp = 0x01 + 0x07 + 0x41 + 0x02 + 0x50;
 759   2          break;
 760   2        case FP_GREEN:
 761   2          AS608_SendData(0x01);
 762   2          AS608_SendData(0x02);
 763   2          AS608_SendData(0x02);
 764   2          AS608_SendData(0);
 765   2          temp = 0x01 + 0x07 + 0x41 + 0x05 + 0;
 766   2          break;
 767   2        case FP_RED:
 768   2          AS608_SendData(0x01);
 769   2          AS608_SendData(0x04);
 770   2          AS608_SendData(0x04);
 771   2          AS608_SendData(0);
 772   2          temp = 0x01 + 0x07 + 0x41 + 0x09 + 0;
 773   2          break;
 774   2        case FP_NONE_COLOR:
 775   2          AS608_SendData(0x04);
 776   2          AS608_SendData(0x00);
 777   2          AS608_SendData(0x00);
 778   2          AS608_SendData(0xC8);
 779   2          temp = 0x01 + 0x07 + 0x41 + 0x04 + 0xC8;
 780   2          break;
 781   2        }
 782   1        SendCheck(temp);
 783   1      
 784   1        // sure=ReturnFlag(&p);
 785   1        sure = JudgeStr(1000, 0x03);
 786   1        //#endif
 787   1        Light_Color = light_id;
 788   1      
 789   1        //  }
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/10/2021 16:15:00 PAGE 14  

 790   1      }
 791          
 792          FP_COLOR_E FP_Get_Light(void)
 793          {
 794   1        return Light_Color;
 795   1      }
 796          
 797          unsigned char FP_Get_Start_Flag(void)
 798          {
 799   1        if (uart_getbuflen > 0)
 800   1        {
 801   2          unsigned char i;
 802   2      
 803   2          for (i = 0; i < uart_getbuflen; i++)
 804   2          {
 805   3            if (uart_get_buf[i] == 0x55)
 806   3            {
 807   4              uart_getbuflen = 0;
 808   4              return 1;
 809   4            }
 810   3          }
 811   2        }
 812   1        return 0;
 813   1      }
 814          
 815          #endif //__PREIPHERAL_FP_LT5X_SUPPORT__


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1965    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     25      54
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
