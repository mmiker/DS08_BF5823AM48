C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/06/2021 16:17:11 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DQIOT_FP_SY
OBJECT MODULE PLACED IN .\output\dqiot_fp_sy.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE source\dqiot_fp_sy.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\includ
                    -e;.\Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd
                    -_rfid;.\mmi_inc) DEBUG PRINT(.\list\dqiot_fp_sy.lst) TABS(2) OBJECT(.\output\dqiot_fp_sy.obj)

line level    source

   1          
   2          //#if defined (__PREIPHERAL_FP_SY_SUPPORT__)
   3          //#include "string.h"
   4          #include "dqiot_fp_sy.h"
   5          #include "delay.h"
   6          #include "dqiot_drv.h"
   7          #include "mcu02_uart.h"
   8          
   9          //unsigned long fp_pin_irq_mask;
  10          
  11          //fp_irq_handle_callback fp_callback_handle;
  12          //fp_uart_handle_callback fp_uart_handle = 0;
  13          //unsigned char fp_Mode = 0;
  14          //static unsigned char fp_temp_mode = 0;
  15          
  16          static unsigned char uart_rec_buff[20];
  17          
  18          //static FP_TYPE fp_flag = FP_NONE;
  19          static FP_COLOR_E Light_Color = FP_NONE_COLOR;
  20          //static unsigned char ps_start_flag = 0;
  21          
  22          extern unsigned char uart_get_buf[];
  23          extern unsigned char uart_getbuflen;
  24          
  25          //unsigned short  ReceiveInfo( unsigned char *rec_data);
  26          //void AS608_log(void);
  27          
  28          //void fp_set_irq_handle(fp_irq_handle_callback cb)
  29          //{
  30          //  fp_callback_handle = cb;
  31          //}
  32          
  33          //void fp_set_uart_handle(fp_uart_handle_callback cb)
  34          //{
  35          //  fp_uart_handle = cb;
  36          //}
  37          
  38          ///FP_TYPE fp_get_type(void)
  39          //{
  40          //  return fp_flag;
  41          
  42          //}
  43          
  44          //--------------------------------------------------------------------------------
  45          
  46          //static unsigned char uart_len=0;
  47          //static unsigned short uart_maxlen = 0;
  48          //static unsigned char uart_buff[25]={0};
  49          
  50          //static void UART_Callback(unsigned char send_data)
  51          //{
  52          //  send_data = 0;
  53          //}
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/06/2021 16:17:11 PAGE 2   

  54          
  55          //unsigned char fp_GetModeState(void)
  56          //{
  57          //  return fp_Mode;
  58          //}
  59          
  60          //void fp_SetModeState(unsigned char s)
  61          //{
  62          //  fp_Mode = s;
  63          
  64          //  if(s == 0)
  65          //    Light_Color = FP_NONE_COLOR;
  66          //}
  67          
  68          //static void PS_UART_Callback(unsigned char send_data)
  69          //{
  70          //  if(send_data == 0x55 )
  71          //  {
  72          //    ps_start_flag = 1;
  73          //  }
  74          //}
  75          
  76          //void FP_PowerOn(void)
  77          //{
  78          
  79          //}
  80          
  81          /**
  82            * @brief  AS608_USARTä¸²å£å‘æŒ‡çº¹æ¨¡å—ä¼ é€’æ•°ï¿½? 
  83            * @param  data;ä¼ è¾“çš„æ•°ï¿½?
  84            */
  85          void AS608_SendData(unsigned char send_data)
  86          {
  87   1        uart_tx_byte(UART0, send_data);
  88   1      }
  89          
  90          /**
  91            * @brief  AS608_USARTä¸²å£å‘æŒ‡çº¹æ¨¡å—å‘½ä»¤åŒ…å¤´æ ¼ï¿½? 
  92            * @param  ï¿½?
  93            */
  94          unsigned char AS608_PackHead(void)
  95          {
  96   1      
  97   1        //unsigned char delay_times = 30;
  98   1      
  99   1        //while(ps_start_flag==0&&delay_times>0)
 100   1        //{
 101   1        //  delay_times--;
 102   1        //}
 103   1        //if(ps_start_flag == 0)
 104   1        //{
 105   1        //  return 1;
 106   1        //}
 107   1        //else if(ps_start_flag == 1)
 108   1        //{
 109   1        //  uart_init_block();
 110   1        //  ps_start_flag = 2;
 111   1        //}
 112   1      
 113   1        uart_getbuflen = 0;
 114   1      
 115   1        /*åŒ…å¤´*/
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/06/2021 16:17:11 PAGE 3   

 116   1        AS608_SendData(0xEF);
 117   1        AS608_SendData(0x01);
 118   1      
 119   1        /*æŒ‡çº¹æ¨¡å—åœ°å€*/
 120   1        AS608_SendData(AS608_Addr >> 24);
 121   1        AS608_SendData(AS608_Addr >> 16);
 122   1        AS608_SendData(AS608_Addr >> 8);
 123   1        AS608_SendData(AS608_Addr);
 124   1      
 125   1        return 0;
 126   1      }
 127          
 128          unsigned char AS608_PackHead2(void)
 129          {
 130   1      
 131   1        /*åŒ…å¤´*/
 132   1        AS608_SendData(0xEF);
 133   1        AS608_SendData(0x01);
 134   1      
 135   1        /*æŒ‡çº¹æ¨¡å—åœ°å€*/
 136   1        AS608_SendData(AS608_Addr >> 24);
 137   1        AS608_SendData(AS608_Addr >> 16);
 138   1        AS608_SendData(AS608_Addr >> 8);
 139   1        AS608_SendData(AS608_Addr);
 140   1      
 141   1        return 0;
 142   1      }
 143          
 144          /**
 145            * @brief  å‘é€åŒ…æ ‡è¯†
 146            * @param  flag:åŒ…æ ‡è¯†ä½
 147            * @retval ï¿½?
 148            */
 149          void SendFlag(unsigned char flag)
 150          {
 151   1        AS608_SendData(flag);
 152   1      }
 153          
 154          /**
 155            * @brief  å‘é€åŒ…é•¿åº¦
 156            * @param  length:åŒ…é•¿ï¿½?
 157            * @retval ï¿½?
 158            */
 159          void SendLength(unsigned short length)
 160          {
 161   1        AS608_SendData(length >> 8);
 162   1        AS608_SendData(length);
 163   1      }
 164          
 165          /**
 166            * @brief  å‘é€æŒ‡ä»¤ç 
 167            * @param  cmd;æŒ‡ä»¤ï¿½?
 168            * @retval ï¿½?
 169            */
 170          void Sendcmd(unsigned char cmd)
 171          {
 172   1        AS608_SendData(cmd);
 173   1      }
 174          
 175          /**
 176            * @brief  å‘é€æ ¡éªŒå’Œ
 177            * @param  check:æ£€æŸ¥ä½
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/06/2021 16:17:11 PAGE 4   

 178            * @retval ï¿½?
 179            */
 180          void SendCheck(unsigned short check)
 181          {
 182   1        AS608_SendData(check >> 8);
 183   1        AS608_SendData(check);
 184   1      }
 185          
 186          /**
 187            * @brief  åˆ¤æ–­ï¿½?ï¿½?æ¥æ”¶çš„æ•°ç»„æœ‰æ²¡æœ‰åº”ç­”ï¿½?
 188            * @param  
 189            * waittimeä¸ºç­‰å¾…ä¸­ï¿½?æ¥æ”¶æ•°æ®çš„æ—¶ï¿½?(å•ä½1ms)
 190            * lengthä¸ºåŒ…é•¿åº¦
 191            * @return æ•°æ®åŒ…ç¡®è®¤ç 
 192            * @note   1 failed
 193            * @see    none
 194            */
 195          static u8 JudgeStr(u16 waittime, u8 length)
 196          {
 197   1        u8 getdata;
 198   1        u8 i = 0, j = 0;
 199   1        //u8 str[8];
 200   1        //str[0] = 0xEF;
 201   1        //str[1] = 0x01;
 202   1        //str[2] = AS608_Addr >> 24;
 203   1        //str[3] = AS608_Addr >> 16;
 204   1        //str[4] = AS608_Addr >> 8;
 205   1        //str[5] = AS608_Addr;
 206   1        //str[6] = 0x07;
 207   1      
 208   1        while (--waittime)
 209   1        {
 210   2          delay_ms(1);
 211   2      
 212   2          /* æ¥æ”¶åˆ°ä¸€æ¬¡æ•°ï¿½? */
 213   2          if (uart_getbuflen >= 9 + length)
 214   2          {
 215   3            /* å¯»æ‰¾0xEFä½ç½® */
 216   3            for (i = 0; i < uart_getbuflen; i++)
 217   3            {
 218   4              if (uart_get_buf[i] == 0xEF)
 219   4                break;
 220   4            }
 221   3      
 222   3            /* åˆ¤æ–­ï¿½?å¦ä¸ºåº”ç­”ï¿½? */
 223   3            if (uart_get_buf[i] == 0xEF && uart_get_buf[i + 1] == 0x01 && uart_get_buf[i + 6] == 0x07 && ((uart_get
             -_buf[i + 7] << 8) + uart_get_buf[i + 8]) == length)
 224   3            {
 225   4              for (i; i < uart_getbuflen; i++)
 226   4              {
 227   5                uart_rec_buff[j] = uart_get_buf[i];
 228   5                j++;
 229   5              }
 230   4              getdata = uart_rec_buff[9]; //ï¿½?è®¤ç 
 231   4      
 232   4              /* æ¸…ç©ºç¼“å­˜ */
 233   4              uart_getbuflen = 0;
 234   4      
 235   4              return getdata;
 236   4            }
 237   3          }
 238   2        }
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/06/2021 16:17:11 PAGE 5   

 239   1      
 240   1        return 1;
 241   1      }
 242          
 243          #if 0
              /**
                * @brief  ä»ç¼“å†²åŒºè¯»å‡ºï¿½?è®¤ç 
                * @param  *i:è¿”å›å€¼ï¼ˆï¿½?è®¤ç ï¿½?
                * @retval ï¿½?
                */
              unsigned char  ReturnFlag( unsigned char *i)
              { 
                *i = ReceiveInfo(uart_rec_buff);
                return *i;
              }
              
              unsigned char  ReceiveInfo( unsigned char *rec_data)
              {
                unsigned char *temp_data;
                unsigned short rev_length = 0;
                unsigned char error = 0;
                unsigned char a = 9;
              
                memset(uart_rec_buff,0,sizeof(uart_rec_buff));
              
                do
                {
                  //error = nrf_drv_uart_rx(rec_data,1);
                  //if(error == NRF_ERROR_INTERNAL)
                  //  return 0xFF;
                  if(rec_data[0] == 0xEF)
                    break;
                  if(a==0)
                    return 0xFF;
                }while(a--);
                
              
                rev_length = (rec_data[7]<<8)+rec_data[8];
                temp_data = rec_data+9;
              
                if(rev_length!=0)
                  ;//nrf_drv_uart_rx(temp_data,rev_length);
                else
                  return 0xFF;
              
                AS608_log();
                return temp_data[0];
              }
              #endif
 288          
 289          unsigned char PS_GetEcho(void)
 290          {
 291   1        AS608_PackHead2();
 292   1        SendFlag(0x01);
 293   1        SendLength(0x03);
 294   1        Sendcmd(0x53); /*ç”Ÿæˆç‰¹å¾æŒ‡ä»¤*/
 295   1        SendCheck(0x57);
 296   1      
 297   1        //sure=ReturnFlag(&p);
 298   1        return JudgeStr(1000, 0x03);
 299   1      }
 300          
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/06/2021 16:17:11 PAGE 6   

 301          //å½•å…¥å›¾åƒ PS_GetImage
 302          //åŠŸèƒ½:æ¢æµ‹æ‰‹æŒ‡ï¼Œæ¢æµ‹åˆ°åå½•å…¥æŒ‡çº¹å›¾åƒå­˜äºImageBufferï¿½?
 303          //æ¨¡å—è¿”å›ï¿½?è®¤å­—
 304          unsigned char PS_GetImage(void)
 305          {
 306   1        //delay_ms(300);
 307   1        if (AS608_PackHead() == 1)
 308   1          return 0xFF;
 309   1        SendFlag(0x01); /*å‘½ä»¤åŒ…æ ‡ï¿½?*/
 310   1        SendLength(0x03);
 311   1        Sendcmd(0x01); /*å½•æŒ‡çº¹æŒ‡ï¿½?*/
 312   1        SendCheck(0x01 + 0x03 + 0x01);
 313   1      
 314   1        //nrf_delay_ms(50);        /*ç­‰å¾…æŒ‡çº¹è¯†åˆ«æ¨¡å—å¤„ç†æ•°æ®*/
 315   1      
 316   1        // sure = ReturnFlag(&p);
 317   1        return JudgeStr(1000, 0x03);
 318   1      }
 319          
 320          //ç”Ÿæˆç‰¹å¾ PS_GenChar
 321          //åŠŸèƒ½:å°†ImageBufferï¿½?çš„åŸå§‹å›¾åƒç”ŸæˆæŒ‡çº¹ç‰¹å¾æ–‡ä»¶å­˜äºCharBuffer1æˆ–CharBuffer2
 322          //å‚æ•°:BufferID --> charBuffer1:0x01  charBuffer1:0x02
 323          //æ¨¡å—è¿”å›ï¿½?è®¤å­—
 324          unsigned char PS_GenChar(unsigned char BufferID)
 325          {
 326   1        if (AS608_PackHead() == 1)
 327   1          return 0xFF;
 328   1        SendFlag(0x01);
 329   1        SendLength(0x04);
 330   1        Sendcmd(0x02); /*ç”Ÿæˆç‰¹å¾æŒ‡ä»¤*/
 331   1        AS608_SendData(BufferID);
 332   1        SendCheck(0x01 + 0x04 + 0x02 + BufferID);
 333   1        return JudgeStr(1000, 0x03);
 334   1      }
 335          
 336          //ç²¾ç¡®æ¯”ï¿½?ï¿½ä¸¤æšæŒ‡çº¹ç‰¹ï¿½? PS_Match
 337          //åŠŸèƒ½:ç²¾ç¡®æ¯”ï¿½?ï¿½CharBuffer1 ä¸CharBuffer2 ï¿½?çš„ç‰¹å¾æ–‡ï¿½?
 338          //æ¨¡å—è¿”å›ï¿½?è®¤å­—
 339          unsigned char PS_Match(void)
 340          {
 341   1        if (AS608_PackHead() == 1)
 342   1          return 0xFF;
 343   1        SendFlag(0x01);
 344   1        SendLength(0x03);
 345   1        Sendcmd(0x03); /*ç²¾ç¡®æ¯”ï¿½?ï¿½æŒ‡ï¿½?*/
 346   1        SendCheck(0x01 + 0x03 + 0x03);
 347   1      
 348   1        // sure = ReturnFlag(&p);
 349   1        return JudgeStr(1000, 0x05);
 350   1      }
 351          //æœç´¢æŒ‡çº¹ PS_Search
 352          //åŠŸèƒ½:ï¿½?CharBuffer1æˆ–CharBuffer2ï¿½?çš„ç‰¹å¾æ–‡ä»¶æœç´¢æ•´ï¿½?æˆ–éƒ¨åˆ†æŒ‡çº¹åº“.è‹¥æœç´¢åˆ°ï¼Œåˆ
             -™è¿”å›é¡µç ï¿½?
 353          //å‚æ•°:  BufferID @ref CharBuffer1  CharBuffer2
 354          //è¯´æ˜:  æ¨¡å—è¿”å›ï¿½?è®¤å­—ï¼Œé¡µç ï¼ˆç›¸é…æŒ‡çº¹æ¨¡æ¿ï¿½?
 355          unsigned char PS_Search(unsigned char BufferID, unsigned short StartPage, unsigned short PageNum, unsigned
             - short *p)
 356          {
 357   1      
 358   1        unsigned char sure;
 359   1        if (AS608_PackHead() == 1)
 360   1          return 0xFF;
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/06/2021 16:17:11 PAGE 7   

 361   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡ï¿½?
 362   1        SendLength(0x08);
 363   1        Sendcmd(0x04);
 364   1        AS608_SendData(BufferID);
 365   1        AS608_SendData(StartPage >> 8);
 366   1        AS608_SendData(StartPage);
 367   1        AS608_SendData(PageNum >> 8);
 368   1        AS608_SendData(PageNum);
 369   1        SendCheck(0x01 + 0x08 + 0x04 + BufferID + (StartPage >> 8) + (unsigned char)StartPage + (PageNum >> 8) + 
             -(unsigned char)PageNum);
 370   1        *p = (uart_rec_buff[10] << 8) + uart_rec_buff[11];
 371   1        return sure;
 372   1      }
 373          
 374          //åˆå¹¶ç‰¹å¾ï¼ˆç”Ÿæˆæ¨¡æ¿ï¼‰PS_RegModel
 375          //åŠŸèƒ½:å°†CharBuffer1ä¸CharBuffer2ï¿½?çš„ç‰¹å¾æ–‡ä»¶åˆå¹¶ç”Ÿï¿½? æ¨¡æ¿,ç»“æœå­˜äºCharBuffer1ä¸Cha
             -rBuffer2
 376          //è¯´æ˜:  æ¨¡å—è¿”å›ï¿½?è®¤å­—
 377          unsigned char PS_RegModel(void)
 378          {
 379   1        if (AS608_PackHead() == 1)
 380   1          return 0xFF;
 381   1        SendFlag(0x01);
 382   1        SendLength(0x03);
 383   1        Sendcmd(0x05); /*åˆå¹¶ç‰¹å¾æŒ‡ä»¤*/
 384   1        SendCheck(0x01 + 0x03 + 0x05);
 385   1      
 386   1        // sure = ReturnFlag(&p);
 387   1        return JudgeStr(1000, 0x03);
 388   1      }
 389          
 390          //å‚¨å­˜æ¨¡æ¿ PS_StoreChar
 391          //åŠŸèƒ½:ï¿½? CharBuffer1 ï¿½? CharBuffer2 ï¿½?çš„æ¨¡æ¿æ–‡ä»¶å­˜ï¿½? PageID å·flashæ•°æ®åº“ä½ï¿½?ï¿½?
 392          //å‚æ•°:  BufferID @ref charBuffer1:0x01 charBuffer1:0x02
 393          //       PageIDï¼ˆæŒ‡çº¹åº“ä½ç½®å·ï¼‰
 394          //è¯´æ˜:  æ¨¡å—è¿”å›ï¿½?è®¤å­—
 395          unsigned char PS_StoreChar(unsigned char BufferID, unsigned short PageID)
 396          {
 397   1        unsigned short;
 398   1      
 399   1        if (AS608_PackHead() == 1)
 400   1          return 0xFF;
 401   1        SendFlag(0x01);
 402   1        SendLength(0x06);
 403   1        Sendcmd(0x06); /*å­˜å‚¨æ¨¡æ¿æŒ‡ä»¤*/
 404   1        AS608_SendData(BufferID);
 405   1        AS608_SendData(PageID >> 8);
 406   1        AS608_SendData(PageID);
 407   1        SendCheck(0x01 + 0x06 + 0x06 + BufferID + (PageID >> 8) + (unsigned char)PageID);
 408   1      
 409   1        // sure = ReturnFlag(&p);
 410   1        return JudgeStr(1000, 0x03);
 411   1      }
 412          
 413          //åˆ é™¤æ¨¡æ¿ PS_DeletChar
 414          //åŠŸèƒ½:  åˆ é™¤flashæ•°æ®åº“ä¸­æŒ‡å®šIDå·å¼€å§‹çš„Nï¿½?æŒ‡çº¹æ¨¡æ¿
 415          //å‚æ•°:  PageID(æŒ‡çº¹åº“æ¨¡æ¿å·)ï¼ŒNåˆ é™¤çš„æ¨¡æ¿ä¸ªæ•°ï¿½?
 416          //è¯´æ˜:  æ¨¡å—è¿”å›ï¿½?è®¤å­—
 417          unsigned char PS_DeletChar(unsigned short PageID, unsigned short N)
 418          {
 419   1        unsigned char sure; //,p=0;
 420   1      
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/06/2021 16:17:11 PAGE 8   

 421   1        if (AS608_PackHead() == 1)
 422   1          return 0xFF;
 423   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡ï¿½?
 424   1        SendLength(0x07);
 425   1        Sendcmd(0x0C); /*åˆ é™¤æŒ‡å®šæŒ‡çº¹æ¨¡æ¿æŒ‡ä»¤*/
 426   1        AS608_SendData(PageID >> 8);
 427   1        AS608_SendData(PageID);
 428   1        AS608_SendData(N >> 8);
 429   1        AS608_SendData(N);
 430   1        SendCheck(0x01 + 0x07 + 0x0C + (PageID >> 8) + (unsigned char)PageID + (N >> 8) + (unsigned char)N);
 431   1      
 432   1        //AS608_DELAY_MS(400);
 433   1      
 434   1        // sure = ReturnFlag(&p);
 435   1        return JudgeStr(1000, 0x03);
 436   1      }
*** WARNING C280 IN LINE 419 OF source\dqiot_fp_sy.c: 'sure': unreferenced local variable
 437          
 438          //é«˜é€Ÿæœï¿½?PS_HighSpeedSearch
 439          //åŠŸèƒ½ï¼šä»¥ CharBuffer1æˆ–CharBuffer2ï¿½?çš„ç‰¹å¾æ–‡ä»¶é«˜é€Ÿæœç´¢æ•´ï¿½?æˆ–éƒ¨åˆ†æŒ‡çº¹åº“ï¿½?
 440          //      è‹¥æœç´¢åˆ°ï¼Œåˆ™è¿”å›é¡µç ,è¯¥æŒ‡ä»¤ï¿½?ï¿½äºçš„ç¡®å­˜åœ¨äºæŒ‡çº¹åº“ï¿½? ï¼Œä¸”ç™»å½•æ—¶è´¨ï¿½
             -?
 441          //      å¾ˆå¥½çš„æŒ‡çº¹ï¼Œä¼šå¾ˆï¿½?ç»™å‡ºæœç´¢ç»“æœï¿½?
 442          //å‚æ•°:  BufferIDï¿½? StartPage(èµ·ï¿½?ï¿½é¡µ)ï¼ŒPageNumï¼ˆé¡µæ•°ï¼‰
 443          //è¯´æ˜:  æ¨¡å—è¿”å›ï¿½?è®¤å­—+é¡µç ï¼ˆç›¸é…æŒ‡çº¹æ¨¡æ¿ï¼‰
 444          unsigned char PS_HighSpeedSearch(unsigned char BufferID, unsigned short StartPage, unsigned short PageNum,
             - unsigned short *p)
 445          {
 446   1        unsigned char ensure;
 447   1      
 448   1        if (AS608_PackHead() == 1)
 449   1          return 0xFF;
 450   1        SendFlag(0x01);
 451   1        SendLength(0x08);
 452   1        Sendcmd(0x1b); /*é«˜é€Ÿæœç´¢æŒ‡çº¹åº“æŒ‡ä»¤*/
 453   1        AS608_SendData(BufferID);
 454   1        AS608_SendData(StartPage >> 8);
 455   1        AS608_SendData(StartPage);
 456   1        AS608_SendData(PageNum >> 8);
 457   1        AS608_SendData(PageNum);
 458   1        SendCheck(0x01 + 0x08 + 0x1b + BufferID + (StartPage >> 8) + (unsigned char)StartPage + (PageNum >> 8) + 
             -(unsigned char)PageNum);
 459   1      
 460   1        // ensure = ReturnFlag(&rc);
 461   1        ensure = JudgeStr(1000, 0x07);
 462   1      
 463   1        *p = (uart_rec_buff[10] << 8) + uart_rec_buff[11];
 464   1      
 465   1        return ensure;
 466   1      }
 467          
 468          //æ¸…ç©ºæŒ‡çº¹ï¿½? PS_Empty
 469          //åŠŸèƒ½:  åˆ é™¤flashæ•°æ®åº“ä¸­æ‰€æœ‰æŒ‡çº¹æ¨¡ï¿½?
 470          //å‚æ•°:  ï¿½?
 471          //è¯´æ˜:  æ¨¡å—è¿”å›ï¿½?è®¤å­—
 472          unsigned char PS_Empty(void)
 473          {
 474   1        if (AS608_PackHead() == 1)
 475   1          return 0xFF;
 476   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡ï¿½?
 477   1        SendLength(0x03);
 478   1        Sendcmd(0x0D);
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/06/2021 16:17:11 PAGE 9   

 479   1        SendCheck(0x01 + 0x03 + 0x0D);
 480   1      
 481   1        // sure = ReturnFlag(&p);
 482   1        return JudgeStr(1000, 0x03);
 483   1      }
 484          
 485          #if 0
              /**
                * @brief  æ£€ï¿½?STM32ä¸æŒ‡çº¹æ¨¡å—çš„é€šä¿¡è¿æ¥
                * @param  PS_AddræŒ‡çº¹æ¨¡å—åœ°å€
                * @retval è¿”å›ï¿½?0é€šï¿½??æˆåŠŸ;1è¡¨ç¤ºé€šï¿½??ä¸æˆï¿½?
                */
              unsigned char PS_Connect(unsigned long *PS_Addr)
              {
                PS_Addr = 0;
                if(AS608_PackHead()==1)
                  return 0xFF;
                AS608_SendData(0X01);
                AS608_SendData(0X00);
                AS608_SendData(0X00);
                return 1;   
              }
              
              //å†™ç³»ç»Ÿå¯„å­˜å™¨ PS_WriteReg
              //åŠŸèƒ½:  å†™æ¨¡å—å¯„å­˜å™¨
              //å‚æ•°:  å¯„å­˜å™¨åºå·RegNum:4\5\6
              //è¯´æ˜:  æ¨¡å—è¿”å›ï¿½?è®¤å­—
              unsigned char PS_WriteReg(unsigned char RegNum, unsigned char DATA)
              {
                unsigned short temp;
                unsigned short sure,p=0;
              
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//é›æˆ’æŠ¤é–ï¿½?çˆ£ç’‡
                SendLength(0x05);
                Sendcmd(0x0E);
                AS608_SendData(RegNum);
                AS608_SendData(DATA);
                temp = RegNum+DATA+0x01+0x05+0x0E;
                SendCheck(temp);
                sure=ReturnFlag(&p);
                return sure;
              }
              //è¯»ç³»ç»ŸåŸºï¿½?å‚æ•° PS_ReadSysPara
              //åŠŸèƒ½:  è¯»å–æ¨¡å—çš„åŸºï¿½?å‚æ•°ï¼ˆæ³¢ç‰¹ç‡ï¼ŒåŒ…å¤§å°ï¿½?)
              //å‚æ•°:  ï¿½?
              //è¯´æ˜:  æ¨¡å—è¿”å›ï¿½?è®¤å­— + åŸºæœ¬å‚æ•°ï¿½?16bytesï¿½?
              unsigned char PS_ReadSysPara(void)
              {
                unsigned short temp;
                unsigned char  ensure;
                unsigned char  *send_data;
                unsigned short p=0;
                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//é›æˆ’æŠ¤é–ï¿½?çˆ£ç’‡
                SendLength(0x03);
                Sendcmd(0x0F);
                temp = 0x01+0x03+0x0F;
                SendCheck(temp);
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/06/2021 16:17:11 PAGE 10  

                ensure=ReturnFlag(&p);
                if(send_data)
                {
              
                }   
                else
                  ensure=0xff;
                if(ensure==0x00)
                {
              
                }
                return ensure;
              }
              //è®¾ç½®æ¨¡å—åœ°å€ PS_SetAddr
              //åŠŸèƒ½:  è®¾ç½®æ¨¡å—åœ°å€
              //å‚æ•°:  PS_addr
              //è¯´æ˜:  æ¨¡å—è¿”å›ï¿½?è®¤å­—
              unsigned char PS_SetAddr(unsigned long PS_addr)
              {
                unsigned short temp;
                unsigned char  ensure;
              
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//å‘½ä»¤åŒ…æ ‡ï¿½?
                SendLength(0x07);
                Sendcmd(0x15);
                AS608_SendData(PS_addr>>24);
                AS608_SendData(PS_addr>>16);
                AS608_SendData(PS_addr>>8);
                AS608_SendData(PS_addr);
                temp = 0x01+0x07+0x15
                +(unsigned char)(PS_addr>>24)+(unsigned char)(PS_addr>>16)
                +(unsigned char)(PS_addr>>8) +(unsigned char)PS_addr;       
                SendCheck(temp);
              
                return ensure;
              }
              //åŠŸèƒ½ï¿½? æ¨¡å—å†…éƒ¨ä¸ºç”¨æˆ·å¼€è¾Ÿäº†256bytesçš„FLASHç©ºé—´ç”¨äºå­˜ç”¨æˆ·ï¿½?ï¿½äº‹ï¿½?,
              //  è¯¥ï¿½?ï¿½äº‹ï¿½?é€»è¾‘ä¸Šï¿½??åˆ†æˆ 16 ï¿½?é¡µï¿½?
              //å‚æ•°:  NotePageNum(0~15),Byte32(è¦å†™å…¥å†…å®¹ï¼Œ32ï¿½?å­—èŠ‚)
              //è¯´æ˜:  æ¨¡å—è¿”å›ï¿½?è®¤å­—
              unsigned char PS_WriteNotepad(unsigned char NotePageNum,unsigned char *Byte32)
              {
                unsigned short temp;
                unsigned char  ensure,i;
                
                *Byte32 = 0;
                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡ï¿½?
                SendLength(36);
                Sendcmd(0x18);
                AS608_SendData(NotePageNum);
                for(i=0;i<32;i++)
                {
                  AS608_SendData(Byte32[i]);
                  temp += Byte32[i];
                }
                temp =0x01+36+0x18+NotePageNum+temp;
                SendCheck(temp);
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/06/2021 16:17:11 PAGE 11  

              
                return ensure;
              }
              //è¯»ï¿½?ï¿½äº‹PS_ReadNotepad
              //åŠŸèƒ½ï¿½?  è¯»å–FLASHç”¨æˆ·åŒºçš„128bytesæ•°æ®
              //å‚æ•°:  NotePageNum(0~15)
              //è¯´æ˜:  æ¨¡å—è¿”å›ï¿½?è®¤å­—+ç”¨æˆ·ä¿¡æ¯
              unsigned char PS_ReadNotepad(unsigned char NotePageNum,unsigned char *Byte32)
              {
                unsigned short temp;
                unsigned char  ensure;
                
                *Byte32 = 0;
                
                if(AS608_PackHead()==1)
                  return 0xFF;
                SendFlag(0x01);//å‘½ä»¤åŒ…æ ‡ï¿½?
                SendLength(0x04);
                Sendcmd(0x19);
                AS608_SendData(NotePageNum);
                temp = 0x01+0x04+0x19+NotePageNum;
                SendCheck(temp);
              
                return ensure;
              }
              #endif
 629          
 630          //è¯»æœ‰æ•ˆæ¨¡æ¿ä¸ªï¿½? PS_ValidTempleteNum
 631          //åŠŸèƒ½ï¼šï¿½?ï¿½æœ‰æ•ˆæ¨¡æ¿ä¸ªï¿½?
 632          //å‚æ•°: ï¿½?
 633          //è¯´æ˜: æ¨¡å—è¿”å›ï¿½?è®¤å­—+æœ‰æ•ˆæ¨¡æ¿ï¿½?æ•°ValidN
 634          unsigned char PS_ValidTempleteNum(unsigned short *ValidN)
 635          {
 636   1        unsigned char ensure;
 637   1      
 638   1        if (AS608_PackHead() == 1)
 639   1          return 0xFF;
 640   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡ï¿½?
 641   1        SendLength(0x03);
 642   1        Sendcmd(0x1d);
 643   1        SendCheck(0x01 + 0x03 + 0x1d);
 644   1      
 645   1        // ensure = ReturnFlag(&p);
 646   1        ensure = JudgeStr(1000, 0x05);
 647   1      
 648   1        *ValidN = (uart_rec_buff[10] << 8) + uart_rec_buff[11];
 649   1      
 650   1        return ensure;
 651   1      }
 652          
 653          unsigned char PS_AutoEnRoll(unsigned short id, unsigned char num, unsigned short param)
 654          {
 655   1        if (AS608_PackHead() == 1)
 656   1          return 0xFF;
 657   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡ï¿½?
 658   1        SendLength(0x08);
 659   1        Sendcmd(0x31);
 660   1        AS608_SendData(id >> 8);
 661   1        AS608_SendData(id & 0xFF);
 662   1        AS608_SendData(num);
 663   1        AS608_SendData(param >> 8);
 664   1        AS608_SendData(param & 0xFF);
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/06/2021 16:17:11 PAGE 12  

 665   1        SendCheck(0x01 + 0x08 + 0x31 + (id >> 8) + (id & 0xFF) + num + (param >> 8) + (param & 0xFF));
 666   1      
 667   1        return 0;
 668   1      }
 669          
 670          //ï¿½?åŠ¨éªŒè¯æŒ‡ï¿½? PS_AutoIdentify
 671          //åŠŸèƒ½ï¿½?
 672          //1.ï¿½?åŠ¨é‡‡é›†æŒ‡çº¹ï¼Œåœ¨æŒ‡çº¹åº“ï¿½?æœç´¢ï¿½?æ ‡æ¨¡æ¿å¹¶è¿”å›æœç´¢ç»“æœï¿½?
 673          //2.å¦‚æœï¿½?æ ‡æ¨¡æ¿åŒå½“å‰é‡‡é›†çš„æŒ‡çº¹æ¯”å¯¹å¾—åˆ†å¤§äºæœ€é«˜é˜€å€¼ï¼Œå¹¶ä¸”ï¿½?æ ‡æ¨¡æ¿ä¸ºä¸å
             -®Œæ•´ç‰¹å¾åˆ™ä»¥é‡‡é›†çš„ç‰¹å¾æ›´æ–°ï¿½?æ ‡æ¨¡æ¿çš„ç©ºç™½åŒºåŸŸï¿½?
 674          //å‚æ•°: ï¿½?
 675          //è¯´æ˜: æ¨¡å—è¿”å›ï¿½?è®¤å­—+é¡µç ï¼ˆç›¸é…æŒ‡çº¹æ¨¡æ¿ï¼‰
 676          unsigned char PS_AutoIdentify(unsigned short id, unsigned char level, unsigned short param)
 677          {
 678   1        if (AS608_PackHead() == 1)
 679   1          return 0xFF;
 680   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡ï¿½?
 681   1        SendLength(0x08);
 682   1        Sendcmd(0x32);
 683   1        AS608_SendData(level);
 684   1        AS608_SendData(id >> 8);
 685   1        AS608_SendData(id & 0xFF);
 686   1        AS608_SendData(param >> 8);
 687   1        AS608_SendData(param & 0xFF);
 688   1        SendCheck(0x01 + 0x08 + 0x32 + (id >> 8) + (id & 0xFF) + level + (param >> 8) + (param & 0xFF));
 689   1      
 690   1        return 0;
 691   1      }
 692          
 693          //ä¸AS608æ¡æ‰‹ PS_HandShake
 694          //å‚æ•°: PS_Addråœ°å€æŒ‡é’ˆ
 695          //è¯´æ˜: æ¨¡å—è¿”æ–°åœ°å€ï¼ˆï¿½?ï¿½ç¡®åœ°å€ï¿½?
 696          unsigned char PS_HandShake(unsigned long *PS_Addr)
 697          {
 698   1        *PS_Addr = 0;
 699   1      
 700   1        if (AS608_PackHead() == 1)
 701   1          return 0xFF;
 702   1        SendFlag(0x01);
 703   1        SendLength(0x03);
 704   1        Sendcmd(0x53);
 705   1        SendCheck(0x57);
 706   1      
 707   1        return JudgeStr(1000, 0x03);
 708   1      }
 709          
 710          unsigned char PS_Reset(void)
 711          {
 712   1        return 0;
 713   1      }
 714          
 715          unsigned char PS_Sleep(void)
 716          {
 717   1        if (AS608_PackHead() == 1)
 718   1          return 0xFF;
 719   1        SendFlag(0x01); //å‘½ä»¤åŒ…æ ‡ï¿½?
 720   1        SendLength(0x03);
 721   1        Sendcmd(0x60);
 722   1        SendCheck(0x01 + 0x03 + 0x60);
 723   1        return 0;
 724   1      }
 725          
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/06/2021 16:17:11 PAGE 13  

 726          //void AS608_log(void)
 727          //{
 728          //  unsigned char i =0;
 729          ////  NRF_LOG_PRINTF_DEBUG("receive :");
 730          //  for(i=0;i<25;i++)
 731          //  {
 732          //    NRF_LOG_PRINTF_DEBUG("%2x ",as608_rec_buff[i]);
 733          //  }
 734          //  NRF_LOG_PRINTF_DEBUG("\n");
 735          //}
 736          
 737          void FP_Light(FP_COLOR_E light_id)
 738          {
 739   1        //  if(fp_flag == FP_LT5X)
 740   1        //  {
 741   1        //#ifdef __FP_LT5X_LIGHT_SUPPORT__
 742   1        unsigned short temp;
 743   1      
 744   1        unsigned char sure = 0; //,p=0;
 745   1        if (light_id == Light_Color)
 746   1          return;
 747   1      
 748   1        if (AS608_PackHead() == 1)
 749   1          return;
 750   1        SendFlag(0x01);
 751   1        SendLength(0x07);
 752   1        Sendcmd(0x41);
 753   1        switch (light_id)
 754   1        {
 755   2        case FP_BLUE:
 756   2          AS608_SendData(0x01);
 757   2          AS608_SendData(0x01);
 758   2          AS608_SendData(0x00);
 759   2          AS608_SendData(0x50);
 760   2          temp = 0x01 + 0x07 + 0x41 + 0x02 + 0x50;
 761   2          break;
 762   2        case FP_GREEN:
 763   2          AS608_SendData(0x01);
 764   2          AS608_SendData(0x02);
 765   2          AS608_SendData(0x02);
 766   2          AS608_SendData(0);
 767   2          temp = 0x01 + 0x07 + 0x41 + 0x05 + 0;
 768   2          break;
 769   2        case FP_RED:
 770   2          AS608_SendData(0x01);
 771   2          AS608_SendData(0x04);
 772   2          AS608_SendData(0x04);
 773   2          AS608_SendData(0);
 774   2          temp = 0x01 + 0x07 + 0x41 + 0x09 + 0;
 775   2          break;
 776   2        case FP_NONE_COLOR:
 777   2          AS608_SendData(0x04);
 778   2          AS608_SendData(0x00);
 779   2          AS608_SendData(0x00);
 780   2          AS608_SendData(0xC8);
 781   2          temp = 0x01 + 0x07 + 0x41 + 0x04 + 0xC8;
 782   2          break;
 783   2        }
 784   1        SendCheck(temp);
 785   1      
 786   1        // sure = ReturnFlag(&p);
 787   1        // sure = JudgeStr(1000, 0x03);
C51 COMPILER V9.59.0.0   DQIOT_FP_SY                                                       03/06/2021 16:17:11 PAGE 14  

 788   1      
 789   1        // if (sure == 0)
 790   1        Light_Color = light_id;
 791   1      
 792   1        //#endif
 793   1      
 794   1        //  }
 795   1      }
 796          
 797          FP_COLOR_E FP_Get_Light(void)
 798          {
 799   1        return Light_Color;
 800   1      }
 801          
 802          FP_COLOR_E FP_Set_Light(FP_COLOR_E light_id)
 803          {
 804   1        Light_Color = light_id;
 805   1        return Light_Color;
 806   1      }
 807          
 808          unsigned char FP_Get_Start_Flag(void)
 809          {
 810   1        if (uart_getbuflen > 0)
 811   1        {
 812   2          unsigned char i;
 813   2      
 814   2          for (i = 0; i < uart_getbuflen; i++)
 815   2          {
 816   3            if (uart_get_buf[i] == 0x55)
 817   3            {
 818   4              uart_getbuflen = 0;
 819   4              return 1;
 820   4            }
 821   3          }
 822   2        }
 823   1        return 0;
 824   1      }
 825          
 826          //#endif//__PREIPHERAL_FP_LT5X_SUPPORT__


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1940    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     25      55
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
