C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         03/06/2021 11:30:33 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DQIOT_DRV
OBJECT MODULE PLACED IN .\output\dqiot_drv.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE source\dqiot_drv.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;
                    -.\Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd_r
                    -fid;.\mmi_inc) DEBUG PRINT(.\list\dqiot_drv.lst) TABS(2) OBJECT(.\output\dqiot_drv.obj)

line level    source

   1          /*!
   2              \file  dqiot_drv.c
   3              \brief drv
   4          */
   5          
   6          /*
   7              Copyright (C) 2018 BYD
   8          */
   9          #ifndef __DQIOT_DRV_C__
  10          
  11          #define __DQIOT_DRV_C__
  12          
  13          #include "string.h"
  14          #include <stdio.h>
  15          #include "stdlib.h"
  16          #include "byd_ctk.h"
  17          #include "dqiot_drv.h"
  18          
  19          #include "mcu02_timer.h"
  20          #include "mcu02_system.h"
  21          #include "mcu02_uart.h"
  22          #include "delay.h"
  23          
  24          uint16_t timer1_count_flag = 0;
  25          
  26          unsigned char uart_get_buf[UART0_GET_DATA_LEN];
  27          //unsigned char uart_send_buf[UART0_SEND_DATA_LEN];
  28          //unsigned char uart_sendbuflen = 0;
  29          unsigned char uart_getbuflen = 0;
  30          
  31          extern void Audio_timer_event_handler(void);
  32          extern void System_timer_event_handler(void);
  33          /*
  34          parameter: 
  35            none
  36          return :
  37            none
  38          */
  39          void dqiot_drv_gpio_init(void)
  40          {
  41   1        dqiot_drv_ext_ldo_init();
  42   1      
  43   1        dqiot_drv_reset_gpio_init();
  44   1      
  45   1        dqiot_drv_key_led_gpio_init();
  46   1        dqiot_drv_rgb_led_gpio_init();
  47   1      
  48   1        dqiot_drv_audio_gpio_init();
  49   1        dqiot_drv_fp_gpio_init();
  50   1        dqiot_drv_motor_gpio_init();
  51   1      
  52   1        gpio_init(VBAT_TEST_PORT, VBAT_TEST_PIN, GPIO_MODE_OUT);
  53   1        gpio_bit_reset(VBAT_TEST_PORT, VBAT_TEST_PIN);
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         03/06/2021 11:30:33 PAGE 2   

  54   1      
  55   1        gpio_init(VBAT_ADC_PORT, VBAT_ADC_PIN, GPIO_MODE_IN_FLOATING);
  56   1        //gpio_bit_reset(VBAT_ADC_PORT,VBAT_ADC_PIN);
  57   1      
  58   1        gpio_init(WIFI_SDA_PORT, WIFI_SDA_PIN, GPIO_MODE_OUT);
  59   1        gpio_bit_set(WIFI_SDA_PORT, WIFI_SDA_PIN);
  60   1      
  61   1        gpio_init(WIFI_SCL_PORT, WIFI_SCL_PIN, GPIO_MODE_OUT);
  62   1        gpio_bit_set(WIFI_SCL_PORT, WIFI_SCL_PIN);
  63   1      
  64   1        gpio_init(SW_PORT, SW_PIN, GPIO_MODE_IN_FLOATING);
  65   1        //gpio_bit_reset(SW_PORT,SW_PIN);
  66   1      
  67   1        gpio_init(GPIOE, GPIO_PIN_4, GPIO_MODE_IN_FLOATING);
  68   1        //gpio_bit_reset(GPIOE,GPIO_PIN_4);
  69   1        gpio_init(GPIOE, GPIO_PIN_5, GPIO_MODE_IN_FLOATING);
  70   1        //gpio_bit_reset(GPIOE,GPIO_PIN_5);
  71   1        gpio_init(GPIOE, GPIO_PIN_6, GPIO_MODE_IN_FLOATING);
  72   1        //gpio_bit_reset(GPIOE,GPIO_PIN_6);
  73   1        gpio_init(GPIOE, GPIO_PIN_7, GPIO_MODE_IN_FLOATING);
  74   1        //gpio_bit_reset(GPIOE,GPIO_PIN_7);
  75   1        return;
  76   1      }
  77          
  78          /*
  79          parameter: 
  80            none
  81          return :
  82            none
  83          */
  84          void dqiot_drv_wake_up(void)
  85          {
  86   1      
  87   1        //WDT_ENABLE();
  88   1      
  89   1        BOR_ENABLE();
  90   1      
  91   1        CSD_ENABLE();
  92   1      
  93   1        //RFID_ENABLE();
  94   1      
  95   1        //dqiot_drv_reset_gpio_init();
  96   1      
  97   1        dqiot_drv_key_led_gpio_init();
  98   1        dqiot_drv_rgb_led_gpio_init();
  99   1      
 100   1        dqiot_drv_audio_gpio_init();
 101   1        dqiot_drv_fp_gpio_init();
 102   1        dqiot_drv_motor_gpio_init();
 103   1      
 104   1        dqiot_drv_ext_ldo_on();
 105   1      
 106   1        dqiot_drv_key_led_on();
 107   1      
 108   1        //byd_setbaseline(0);//�������߸�λ
 109   1        //delay_ms(200);
 110   1        return;
 111   1      }
 112          
 113          /*
 114          parameter: 
 115            none
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         03/06/2021 11:30:33 PAGE 3   

 116          return :
 117            none
 118          */
 119          void dqiot_drv_enter_sleep(void)
 120          {
 121   1      
 122   1        //dqiot_drv_reset_gpio_init();
 123   1        UART0_DISABLE();
 124   1      
 125   1        dqiot_drv_ext_ldo_off();
 126   1      
 127   1        dqiot_drv_audio_gpio_deinit();
 128   1        dqiot_drv_fp_gpio_deinit();
 129   1        dqiot_drv_motor_gpio_deinit();
 130   1      
 131   1        dqiot_drv_key_led_gpio_deinit();
 132   1        dqiot_drv_rgb_led_gpio_deinit();
 133   1      
 134   1        //  rfid_enter_lowpower_config();
 135   1      
 136   1        CSD_DISABLE();
 137   1      
 138   1        //RFID_DISABLE();
 139   1      
 140   1        BOR_DISABLE();
 141   1      
 142   1        WDT_DISABLE();
 143   1        return;
 144   1      }
 145          
 146          /*!
 147              \brief      timer0 isr
 148              \param[in]  none
 149              \param[out] none
 150              \retval     none
 151          */
 152          void dqiot_drv_timer0_isr(void) interrupt 1
 153          {
 154   1        INT_TIMER0_CLR();
 155   1      
 156   1        Audio_timer_event_handler();
 157   1      
 158   1        //if(GET_TIMER0_MODE() != TIMER_8BIT_AUTORELOAD)
 159   1        //{
 160   1        //  TH0 = TH0_reload;
 161   1        //  TL0 = TL0_reload;
 162   1        //}
 163   1      }
 164          
 165          /*!
 166              \brief      timer1 isr
 167              \param[in]  none
 168              \param[out] none
 169              \retval     none
 170          */
 171          void dqiot_drv_timer1_isr(void) interrupt 3
 172          {
 173   1        INT_TIMER1_CLR();
 174   1      
 175   1        if (GET_TIMER1_MODE() != TIMER_8BIT_AUTORELOAD)
 176   1        {
 177   2          TH1 = TH1_reload;
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         03/06/2021 11:30:33 PAGE 4   

 178   2          TL1 = TL1_reload;
 179   2        }
 180   1        timer1_count_flag++;
 181   1      
 182   1      }
 183          
 184          /*!
 185              \brief      timer2 isr
 186              \param[in]  none
 187              \param[out] none
 188              \retval     none
 189          */
 190          void timer2_wdt_isr(void) interrupt 14
 191          {
 192   1      
 193   1        INT_WDT_TIMER2_CLR();
 194   1        if (GET_INT_TIMER2_FLAG_STATE())
 195   1        {
 196   2          //timer2
 197   2          System_timer_event_handler();
 198   2        }
 199   1        else if (GET_INT_WDT_FLAG_STATE())
 200   1        {
 201   2          //wdt
 202   2        }
 203   1      }
 204          
 205          /*
 206          parameter: 
 207            none
 208          return :
 209            none
 210          */
 211          uint16_t dqiot_drv_get_timer1_count(void)
 212          {
 213   1        return timer1_count_flag;
 214   1      }
 215          
 216          /*
 217          parameter: 
 218            none
 219          return :
 220            none
 221          */
 222          void dqiot_drv_set_timer1_count(uint16_t count)
 223          {
 224   1        timer1_count_flag = count;
 225   1        return;
 226   1      }
 227          
 228          /*
 229          parameter: 
 230            none
 231          return :
 232            none
 233          */
 234          void dqiot_drv_timer0_init(uint16_t us)
 235          {
 236   1        uint16_t count;
 237   1        count = us;
 238   1        TIMER0_MODE_SET(TIMER_8BIT_AUTORELOAD); //TIMER_13BIT,TIMER_8BIT_AUTORELOAD,TIMER_8BIT
 239   1        TIMER0_CT_MODE_SET(TIME_SELECT);    //COUNT_SELECT
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         03/06/2021 11:30:33 PAGE 5   

 240   1        TIMER0_COUNT_8BIT(count);       //TIMER_16BIT
 241   1        timer0_1_init(TIMER0);
 242   1        return;
 243   1      }
 244          
 245          /*
 246          parameter: 
 247            none
 248          return :
 249            none
 250          */
 251          void dqiot_drv_timer0_start(void)
 252          {
 253   1        INT_TIMER0_CLR();
 254   1        TIMER0_IPL_SET(HIGH);
 255   1        TIMER0_INT_ENABLE();
 256   1        TIMER0_ENABLE();
 257   1      }
 258          
 259          /*
 260          parameter: 
 261            none
 262          return :
 263            none
 264          */
 265          void dqiot_drv_timer0_stop(void)
 266          {
 267   1        INT_TIMER0_CLR();
 268   1        TIMER0_DISABLE();
 269   1      }
 270          
 271          /*
 272          parameter: 
 273            none
 274          return :
 275            none
 276          */
 277          void dqiot_drv_timer1_init(void)
 278          {
 279   1        uint16_t count;
 280   1        count = 1000;
 281   1        TIMER1_MODE_SET(TIMER_16BIT);  //TIMER_13BIT,TIMER_8BIT_AUTORELOAD,TIMER_8BIT
 282   1        TIMER1_CT_MODE_SET(TIME_SELECT); //COUNT_SELECT
 283   1        TIMER1_COUNT_16BIT(count);     //TIMER_16BIT
 284   1        timer0_1_init(TIMER1);
 285   1        return;
 286   1      }
 287          
 288          /*
 289          parameter: 
 290            none
 291          return :
 292            none
 293          */
 294          void dqiot_drv_timer1_start(void)
 295          {
 296   1        INT_TIMER1_CLR();
 297   1        TIMER1_IPL_SET(LOW);
 298   1        TIMER1_INT_ENABLE();
 299   1        TIMER1_ENABLE();
 300   1      }
 301          
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         03/06/2021 11:30:33 PAGE 6   

 302          /*
 303          parameter: 
 304            none
 305          return :
 306            none
 307          */
 308          void dqiot_drv_timer1_stop(void)
 309          {
 310   1        INT_TIMER0_CLR();
 311   1        TIMER0_DISABLE();
 312   1        dqiot_drv_set_timer1_count(0);
 313   1        return;
 314   1      }
 315          
 316          /*
 317          parameter: 
 318            none
 319          return :
 320            none
 321          */
 322          void dqiot_drv_timer2_init(void)
 323          {
 324   1        /*
 325   1           t = prescale*(1000000/32768)*(count+1) us 
 326   1           prescale = 1,65536 
 327   1        */
 328   1        uint16_t count;
 329   1        count = 3276;
 330   1        TIMER2_CLOCK_SELECT(TIMER2_CLOCK_XTAL); //TIMER2_CLOCK_XTALѡ���ⲿ����Ҫʹ��XTAL_32K_E
             -NABLE()
 331   1        TIMER2_AUTO_RELOAD(ENABLE);       //ENABLE
 332   1        TIMER2_PRESCALE(TIMER2_PRESCALE_1);   //TIMER2_PRESCALE_65536
 333   1        TIMER2_COUNT_SET(count);
 334   1      
 335   1        INT_WDT_TIMER2_CLR(); //����жϱ�־
 336   1        TIMER2_IPL_SET(LOW);  //�ж����ȼ�Ϊ��
 337   1        TIMER2_INT_DISABLE(); //�ر��ж�
 338   1        return;
 339   1      }
 340          
 341          /*
 342          parameter: 
 343            none
 344          return :
 345            none
 346          */
 347          void dqiot_drv_timer2_start(void)
 348          {
 349   1        //INT_WDT_TIMER2_CLR();
 350   1        TIMER2_IPL_SET(LOW);
 351   1        TIMER2_INT_ENABLE();
 352   1        TIMER2_ENABLE();
 353   1        return;
 354   1      }
 355          
 356          /*
 357          parameter: 
 358            none
 359          return :
 360            none
 361          */
 362          void dqiot_drv_timer2_stop(void)
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         03/06/2021 11:30:33 PAGE 7   

 363          {
 364   1        //INT_WDT_TIMER2_CLR();
 365   1        TIMER2_DISABLE();
 366   1        return;
 367   1      }
 368          
 369          /*
 370          parameter: 
 371            none
 372          return :
 373            none
 374          */
 375          void dqiot_drv_uart0A_init(void)
 376          {
 377   1        GPIOE_BIT_SET(GPIO_PIN_4 | GPIO_PIN_5); //������ë��
 378   1      
 379   1        UART0_PORT_SET(UART0_PE4_PE5);
 380   1        UART0_CON2 = 0;
 381   1        UART0_STATE = 0;
 382   1        uart_baudrate_config(UART0, UART_BAUDRATE_57600); //������
 383   1        UART0_STOP_MODE(STOP_WIDTH_1BIT);         //ֹͣλ
 384   1        UART0_DATA_MODE(DATA_MODE_8BIT);          //����λ
 385   1        UART0_PARITY_SET(DISABLE);              //��żУ��ʹ��
 386   1        UART0_PARITY_SEL(ODD_PARITY);           //��żУ��ѡ��
 387   1        UART0_MULTI_MODE(DISABLE);              //�ദ����ͨ��ģʽ
 388   1      
 389   1        UART0_RX_ENABLE(); //����ʹ��
 390   1      #ifdef __DRV_UART0A_INT_SUPPORT__
 391   1        UART0_TX_INT_ENABLE(); //�����ж�ʹ��
 392   1        UART0_RX_INT_ENABLE(); //�����ж�ʹ��
 393   1        INT_UART0_CLR();     //����ж�Դ��־
 394   1        UART0_IPL_SET(LOW);    //�ж����ȼ�����
 395   1        UART0_INT_ENABLE();    //�ж�Դ
 396   1      #else
                UART0_TX_INT_DISABLE(); //�����жϹر�
                UART0_RX_INT_DISABLE(); //�����жϹر�
              #endif
 400   1      
 401   1        // memset(uart_get_buf, 0x00, sizeof(uart_get_buf));
 402   1        // uart_getbuflen = 0;
 403   1      
 404   1        UART0_ENABLE(); //ʹ��uart0
 405   1        return;
 406   1      }
 407          
 408          /*
 409          parameter: 
 410            none
 411          return :
 412            none
 413          */
 414          void dqiot_drv_uart0B_init(void)
 415          {
 416   1        GPIOF_BIT_SET(GPIO_PIN_4 | GPIO_PIN_5); //������ë��
 417   1      
 418   1        UART0_PORT_SET(UART0_PF4_PF5);
 419   1        UART0_CON2 = 0;
 420   1        UART0_STATE = 0;
 421   1        uart_baudrate_config(UART0, UART_BAUDRATE_57600); //������
 422   1        UART0_STOP_MODE(STOP_WIDTH_1BIT);         //ֹͣλ
 423   1        UART0_DATA_MODE(DATA_MODE_8BIT);          //����λ
 424   1        UART0_PARITY_SET(DISABLE);              //��żУ��ʹ��
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         03/06/2021 11:30:33 PAGE 8   

 425   1        UART0_PARITY_SEL(ODD_PARITY);           //��żУ��ѡ��
 426   1        UART0_MULTI_MODE(DISABLE);              //�ദ����ͨ��ģʽ
 427   1      
 428   1        UART0_RX_ENABLE(); //����ʹ��
 429   1      #ifdef __DRV_UART0B_INT_SUPPORT__
 430   1        //UART0_TX_INT_ENABLE();//�����ж�ʹ��
 431   1        UART0_TX_INT_ENABLE(); //�����жϹر�
 432   1        UART0_RX_INT_ENABLE(); //�����ж�ʹ��
 433   1        INT_UART0_CLR();     //����ж�Դ��־
 434   1        UART0_IPL_SET(HIGH);   //�ж����ȼ�����
 435   1        UART0_INT_ENABLE();    //�ж�Դ
 436   1      #else
                UART0_TX_INT_DISABLE(); //�����жϹر�
                UART0_RX_INT_DISABLE(); //�����жϹر�
              #endif
 440   1      
 441   1        // memset(uart_get_buf, 0x00, sizeof(uart_get_buf));
 442   1        // uart_getbuflen = 0;
 443   1      
 444   1        UART0_ENABLE(); //ʹ��uart0
 445   1        return;
 446   1      }
 447          
 448          /*
 449          parameter: 
 450            none
 451          return :
 452            none
 453          */
 454          void dqiot_drv_uart0_isr(void) interrupt 17
 455          {
 456   1      
 457   1        if (GET_UART0_RX_STATE())
 458   1        {
 459   2          if (uart_getbuflen >= UART0_GET_DATA_LEN)
 460   2            return;
 461   2          else
 462   2            uart_get_buf[uart_getbuflen++] = UART0_BUF;
 463   2          CLR_UART0_RX_STATE(); //��������жϱ�־λ
 464   2        }
 465   1        //if(GET_UART0_TX_STATE())
 466   1        //{
 467   1        //  CLR_UART0_TX_STATE();//��������жϱ�־λ
 468   1        //  UART0_TX_INT_DISABLE();
 469   1        //}
 470   1      }
 471          
 472          /*
 473          parameter: 
 474            none
 475          return :
 476            none
 477          */
 478          unsigned char dqiot_drv_get_uart0_data(unsigned char len)
 479          {
 480   1        return uart_get_buf[len];
 481   1      }
 482          
 483          /*
 484          parameter: 
 485            none
 486          return :
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         03/06/2021 11:30:33 PAGE 9   

 487            none
 488          */
 489          void dqiot_drv_clr_uart0_data(void)
 490          {
 491   1        memset(uart_get_buf, 0, sizeof(uart_get_buf));
 492   1        uart_getbuflen = 0;
 493   1      }
 494          
 495          /*
 496          parameter: 
 497            none
 498          return :
 499            none
 500          */
 501          void dqiot_drv_uart0_sendData(unsigned char *p_data, unsigned char length)
 502          {
 503   1      #if 1
 504   1        unsigned char i = 0;
 505   1        //dqiot_drv_uart0B_init();
 506   1        //memset(uart_send_buf,0x00,sizeof(uart_send_buf));
 507   1        //memcpy(uart_send_buf,p_data,length);
 508   1        //uart_sendbuflen = length;
 509   1      
 510   1        for (i = 0; i < length; i++)
 511   1        {
 512   2          uart_tx_byte(UART0, p_data[i]);
 513   2        }
 514   1      #endif
 515   1      }
 516          
 517          char putchar(char c)
 518          {
 519   1        uart_tx_byte(UART0, c);
 520   1        return c;
 521   1      }
 522          
 523          #endif //__DQIOT_DRV_C__


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    888    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     27       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
