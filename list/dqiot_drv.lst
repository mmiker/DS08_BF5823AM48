C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         02/19/2021 17:29:46 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DQIOT_DRV
OBJECT MODULE PLACED IN .\output\dqiot_drv.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE source\dqiot_drv.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;
                    -.\Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd_r
                    -fid;.\mmi_inc) DEBUG PRINT(.\list\dqiot_drv.lst) TABS(2) OBJECT(.\output\dqiot_drv.obj)

line level    source

   1          /*!
   2              \file  dqiot_drv.c
   3              \brief drv
   4          */
   5          
   6          /*
   7              Copyright (C) 2018 BYD
   8          */
   9          #ifndef __DQIOT_DRV_C__
  10          
  11          #define __DQIOT_DRV_C__
  12          
  13          #include "string.h"
  14          //#include <stdio.h>
  15          #include "stdlib.h"
  16          #include "byd_ctk.h"
  17          #include "dqiot_drv.h"
  18          
  19          #include "mcu02_timer.h"
  20          #include "mcu02_system.h"
  21          #include "mcu02_uart.h"
  22          #include "delay.h"
  23          #include "dqiot_fp_sy.h"
  24          
  25          uint16_t timer0_count_flag = 0;
  26          uint16_t timer1_count_flag = 0;
  27          
  28          unsigned char uart_get_buf[UART0_GET_DATA_LEN];
  29          unsigned char uart_send_buf[UART0_SEND_DATA_LEN];
  30          unsigned char uart_get_buf[UART0_GET_DATA_LEN];
  31          unsigned char uart_sendbuflen = 0;
  32          unsigned char uart_getbuflen = 0;
  33          unsigned char falg = 0;
  34          
  35          extern void timer0_event_handler(void);
  36          extern void timer2_event_handler(void);
  37          /*
  38          parameter: 
  39            none
  40          return :
  41            none
  42          */
  43          void dqiot_drv_gpio_init(void)
  44          {
  45   1        dqiot_drv_ext_ldo_init();
  46   1      
  47   1        dqiot_drv_reset_gpio_init();
  48   1      
  49   1        dqiot_drv_key_led_gpio_init();
  50   1        dqiot_drv_rgb_led_gpio_init();
  51   1      
  52   1        dqiot_drv_audio_gpio_init();
  53   1        dqiot_drv_fp_gpio_init();
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         02/19/2021 17:29:46 PAGE 2   

  54   1        dqiot_drv_motor_gpio_init();
  55   1      
  56   1        gpio_init(VBAT_TEST_PORT, VBAT_TEST_PIN, GPIO_MODE_OUT);
  57   1        gpio_bit_reset(VBAT_TEST_PORT, VBAT_TEST_PIN);
  58   1      
  59   1        gpio_init(VBAT_ADC_PORT, VBAT_ADC_PIN, GPIO_MODE_OUT);
  60   1        gpio_bit_reset(VBAT_ADC_PORT, VBAT_ADC_PIN);
  61   1      
  62   1        gpio_init(WIFI_SDA_PORT, WIFI_SDA_PIN, GPIO_MODE_OUT);
  63   1        gpio_bit_reset(WIFI_SDA_PORT, WIFI_SDA_PIN);
  64   1      
  65   1        gpio_init(WIFI_SCL_PORT, WIFI_SCL_PIN, GPIO_MODE_OUT);
  66   1        gpio_bit_reset(WIFI_SCL_PORT, WIFI_SCL_PIN);
  67   1      
  68   1        gpio_init(SW_PORT, SW_PIN, GPIO_MODE_OUT);
  69   1        gpio_bit_reset(SW_PORT, SW_PIN);
  70   1      
  71   1        return;
  72   1      }
  73          
  74          /*
  75          parameter: 
  76            none
  77          return :
  78            none
  79          */
  80          void dqiot_drv_wake_up(void)
  81          {
  82   1        
  83   1        WDT_ENABLE();
  84   1      
  85   1        BOR_ENABLE();
  86   1      
  87   1        RFID_ENABLE();
  88   1      
  89   1        CSD_ENABLE();
  90   1      
  91   1        // dqiot_drv_reset_gpio_init();
  92   1      
  93   1        dqiot_drv_key_led_on();
  94   1        dqiot_drv_rgb_led_on();
  95   1      
  96   1        dqiot_drv_audio_gpio_init();
  97   1        dqiot_drv_fp_gpio_init();
  98   1        dqiot_drv_motor_gpio_init();
  99   1      
 100   1        // dqiot_drv_fp_poweron();
 101   1      
 102   1        dqiot_drv_ext_ldo_on();
 103   1        // dqiot_drv_uart0B_init();
 104   1      
 105   1        //byd_setbaseline(0);//按键基线复位
 106   1        delay_ms(200);
 107   1        return;
 108   1      }
 109          
 110          /*
 111          parameter: 
 112            none
 113          return :
 114            none
 115          */
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         02/19/2021 17:29:46 PAGE 3   

 116          void dqiot_drv_enter_sleep(void)
 117          {
 118   1        UART0_DISABLE();
 119   1        //dqiot_drv_reset_gpio_init();
 120   1      
 121   1        dqiot_drv_audio_gpio_deinit();
 122   1        dqiot_drv_fp_gpio_deinit();
 123   1        dqiot_drv_motor_gpio_deinit();
 124   1      
 125   1        dqiot_drv_ext_ldo_off();
 126   1        dqiot_drv_key_led_on();
 127   1        dqiot_drv_rgb_led_on();
 128   1      
 129   1        CSD_DISABLE();
 130   1      
 131   1        RFID_DISABLE();
 132   1      
 133   1        BOR_DISABLE();
 134   1      
 135   1        WDT_DISABLE();
 136   1      
 137   1        return;
 138   1      }
 139          
 140          /*!
 141              \brief      timer0 isr
 142              \param[in]  none
 143              \param[out] none
 144              \retval     none
 145          */
 146          void dqiot_drv_timer0_isr(void) interrupt 1
 147          {
 148   1        INT_TIMER0_CLR();
 149   1      
 150   1        timer0_event_handler();
 151   1      
 152   1        //if(GET_TIMER0_MODE() != TIMER_8BIT_AUTORELOAD)
 153   1        //{
 154   1        //  TH0 = TH0_reload;
 155   1        //  TL0 = TL0_reload;
 156   1        //}
 157   1      }
 158          
 159          /*!
 160              \brief      timer1 isr
 161              \param[in]  none
 162              \param[out] none
 163              \retval     none
 164          */
 165          void dqiot_drv_timer1_isr(void) interrupt 3
 166          {
 167   1        INT_TIMER1_CLR();
 168   1      
 169   1        if (GET_TIMER1_MODE() != TIMER_8BIT_AUTORELOAD)
 170   1        {
 171   2          TH1 = TH1_reload;
 172   2          TL1 = TL1_reload;
 173   2        }
 174   1        timer1_count_flag++;
 175   1      }
 176          
 177          /*!
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         02/19/2021 17:29:46 PAGE 4   

 178              \brief      timer2 isr
 179              \param[in]  none
 180              \param[out] none
 181              \retval     none
 182          */
 183          void timer2_wdt_isr(void) interrupt 14
 184          {
 185   1      
 186   1        INT_WDT_TIMER2_CLR();
 187   1        if (GET_INT_TIMER2_FLAG_STATE())
 188   1        {
 189   2          //timer2
 190   2          timer2_event_handler();
 191   2        }
 192   1        else if (GET_INT_WDT_FLAG_STATE())
 193   1        {
 194   2          //wdt
 195   2        }
 196   1      }
 197          
 198          /*
 199          parameter: 
 200            none
 201          return :
 202            none
 203          */
 204          uint16_t dqiot_drv_get_timer1_count(void)
 205          {
 206   1        return timer1_count_flag;
 207   1      }
 208          
 209          /*
 210          parameter: 
 211            none
 212          return :
 213            none
 214          */
 215          void dqiot_drv_set_timer1_count(uint16_t count)
 216          {
 217   1        timer1_count_flag = count;
 218   1        return;
 219   1      }
 220          
 221          /*
 222          parameter: 
 223            none
 224          return :
 225            none
 226          */
 227          void dqiot_drv_timer0_init(uint16_t us)
 228          {
 229   1        uint16_t count;
 230   1        count = us;
 231   1        TIMER0_MODE_SET(TIMER_8BIT_AUTORELOAD); //TIMER_13BIT,TIMER_8BIT_AUTORELOAD,TIMER_8BIT
 232   1        TIMER0_CT_MODE_SET(TIME_SELECT);    //COUNT_SELECT
 233   1        TIMER0_COUNT_8BIT(count);       //TIMER_16BIT
 234   1        timer0_1_init(TIMER0);
 235   1        return;
 236   1      }
 237          
 238          /*
 239          parameter: 
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         02/19/2021 17:29:46 PAGE 5   

 240            none
 241          return :
 242            none
 243          */
 244          void dqiot_drv_timer0_start(void)
 245          {
 246   1        INT_TIMER0_CLR();
 247   1        TIMER0_IPL_SET(HIGH);
 248   1        TIMER0_INT_ENABLE();
 249   1        TIMER0_ENABLE();
 250   1      }
 251          
 252          /*
 253          parameter: 
 254            none
 255          return :
 256            none
 257          */
 258          void dqiot_drv_timer0_stop(void)
 259          {
 260   1        INT_TIMER0_CLR();
 261   1        TIMER0_DISABLE();
 262   1      }
 263          
 264          /*
 265          parameter: 
 266            none
 267          return :
 268            none
 269          */
 270          void dqiot_drv_timer1_init(void)
 271          {
 272   1        uint16_t count;
 273   1        count = 1000;
 274   1        TIMER1_MODE_SET(TIMER_16BIT);  //TIMER_13BIT,TIMER_8BIT_AUTORELOAD,TIMER_8BIT
 275   1        TIMER1_CT_MODE_SET(TIME_SELECT); //COUNT_SELECT
 276   1        TIMER1_COUNT_16BIT(count);     //TIMER_16BIT
 277   1        timer0_1_init(TIMER1);
 278   1        return;
 279   1      }
 280          
 281          /*
 282          parameter: 
 283            none
 284          return :
 285            none
 286          */
 287          void dqiot_drv_timer1_start(void)
 288          {
 289   1        INT_TIMER1_CLR();
 290   1        TIMER1_IPL_SET(LOW);
 291   1        TIMER1_INT_ENABLE();
 292   1        TIMER1_ENABLE();
 293   1      }
 294          
 295          /*
 296          parameter: 
 297            none
 298          return :
 299            none
 300          */
 301          void dqiot_drv_timer1_stop(void)
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         02/19/2021 17:29:46 PAGE 6   

 302          {
 303   1        INT_TIMER0_CLR();
 304   1        TIMER0_DISABLE();
 305   1        dqiot_drv_set_timer1_count(0);
 306   1        return;
 307   1      }
 308          
 309          /*
 310          parameter: 
 311            none
 312          return :
 313            none
 314          */
 315          void dqiot_drv_timer2_init(void)
 316          {
 317   1        /*
 318   1           t = prescale*(1000000/32768)*(count+1) us 
 319   1           prescale = 1,65536 
 320   1        */
 321   1        uint16_t count;
 322   1        count = 3276;
 323   1        TIMER2_CLOCK_SELECT(TIMER2_CLOCK_XTAL); //TIMER2_CLOCK_XTAL选择外部晶振要使能XTAL_32K_ENABLE()
 324   1        TIMER2_AUTO_RELOAD(ENABLE);       //ENABLE
 325   1        TIMER2_PRESCALE(TIMER2_PRESCALE_1);   //TIMER2_PRESCALE_65536
 326   1        TIMER2_COUNT_SET(count);
 327   1      
 328   1        INT_WDT_TIMER2_CLR(); //清除中断标志
 329   1        TIMER2_IPL_SET(LOW);  //中断优先级为低
 330   1        TIMER2_INT_DISABLE(); //关闭中断
 331   1        return;
 332   1      }
 333          
 334          /*
 335          parameter: 
 336            none
 337          return :
 338            none
 339          */
 340          void dqiot_drv_timer2_start(void)
 341          {
 342   1        //INT_WDT_TIMER2_CLR();
 343   1        TIMER2_IPL_SET(LOW);
 344   1        TIMER2_INT_ENABLE();
 345   1        TIMER2_ENABLE();
 346   1        return;
 347   1      }
 348          
 349          /*
 350          parameter: 
 351            none
 352          return :
 353            none
 354          */
 355          void dqiot_drv_timer2_stop(void)
 356          {
 357   1        //INT_WDT_TIMER2_CLR();
 358   1        TIMER2_DISABLE();
 359   1        return;
 360   1      }
 361          
 362          /*
 363          parameter: 
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         02/19/2021 17:29:46 PAGE 7   

 364            none
 365          return :
 366            none
 367          */
 368          void dqiot_drv_uart0A_init(void)
 369          {
 370   1        GPIOE_BIT_SET(GPIO_PIN_4 | GPIO_PIN_5); //避免有毛刺
 371   1      
 372   1        UART0_PORT_SET(UART0_PE4_PE5);
 373   1        UART0_CON2 = 0;
 374   1        UART0_STATE = 0;
 375   1        uart_baudrate_config(UART0, UART_BAUDRATE_57600); //波特率
 376   1        UART0_STOP_MODE(STOP_WIDTH_1BIT);         //停止位
 377   1        UART0_DATA_MODE(DATA_MODE_8BIT);          //数据位
 378   1        UART0_PARITY_SET(DISABLE);              //奇偶校验使能
 379   1        UART0_PARITY_SEL(ODD_PARITY);           //奇偶校验选择
 380   1        UART0_MULTI_MODE(DISABLE);              //多处理器通信模式
 381   1      
 382   1        UART0_RX_ENABLE(); //接收使能
 383   1      #ifdef __DRV_UART0A_INT_SUPPORT__
 384   1        UART0_TX_INT_ENABLE(); //发送中断使能
 385   1        UART0_RX_INT_ENABLE(); //接收中断使能
 386   1        INT_UART0_CLR();     //清除中断源标志
 387   1        UART0_IPL_SET(LOW);    //中断优先级设置
 388   1        UART0_INT_ENABLE();    //中断源
 389   1      #else
                UART0_TX_INT_DISABLE(); //发送中断关闭
                UART0_RX_INT_DISABLE(); //接收中断关闭
              #endif
 393   1      
 394   1        // memset(uart_get_buf, 0x00, sizeof(uart_get_buf));
 395   1        // uart_getbuflen = 0;
 396   1      
 397   1        UART0_ENABLE(); //使能uart0
 398   1        return;
 399   1      }
 400          
 401          /*
 402          parameter: 
 403            none
 404          return :
 405            none
 406          */
 407          void dqiot_drv_uart0B_init(void)
 408          {
 409   1        GPIOF_BIT_SET(GPIO_PIN_4 | GPIO_PIN_5); //避免有毛刺
 410   1      
 411   1        UART0_PORT_SET(UART0_PF4_PF5);
 412   1        UART0_CON2 = 0;
 413   1        UART0_STATE = 0;
 414   1        uart_baudrate_config(UART0, UART_BAUDRATE_57600); //波特率
 415   1        UART0_STOP_MODE(STOP_WIDTH_1BIT);         //停止位
 416   1        UART0_DATA_MODE(DATA_MODE_8BIT);          //数据位
 417   1        UART0_PARITY_SET(DISABLE);              //奇偶校验使能
 418   1        UART0_PARITY_SEL(ODD_PARITY);           //奇偶校验选择
 419   1        UART0_MULTI_MODE(DISABLE);              //多处理器通信模式
 420   1      
 421   1        UART0_RX_ENABLE(); //接收使能
 422   1      #ifdef __DRV_UART0B_INT_SUPPORT__
 423   1        UART0_TX_INT_ENABLE(); //发送中断使能
 424   1        // UART0_TX_INT_DISABLE(); //发送中断关闭
 425   1        UART0_RX_INT_ENABLE(); //接收中断使能
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         02/19/2021 17:29:46 PAGE 8   

 426   1        INT_UART0_CLR();     //清除中断源标志
 427   1        UART0_IPL_SET(HIGH);   //中断优先级设置
 428   1        UART0_INT_ENABLE();    //中断源
 429   1      #else
                UART0_TX_INT_DISABLE(); //发送中断关闭
                UART0_RX_INT_DISABLE(); //接收中断关闭
              #endif
 433   1      
 434   1        // memset(uart_get_buf, 0x00, sizeof(uart_get_buf));
 435   1        // uart_getbuflen = 0;
 436   1      
 437   1        UART0_ENABLE(); //使能uart0
 438   1        return;
 439   1      }
 440          
 441          /*
 442          parameter: 
 443            none
 444          return :
 445            none
 446          */
 447          void dqiot_drv_uart0_isr(void) interrupt 17
 448          {
 449   1      
 450   1        INT_UART0_CLR();
 451   1        if (GET_UART0_RX_STATE())
 452   1        {
 453   2          if (uart_getbuflen >= UART0_GET_DATA_LEN)
 454   2            return;
 455   2          else
 456   2            uart_get_buf[uart_getbuflen++] = UART0_BUF;
 457   2      
 458   2          CLR_UART0_RX_STATE(); //清除接收中断标志位
 459   2        }
 460   1        //if(GET_UART0_TX_STATE())
 461   1        //{
 462   1        //  CLR_UART0_TX_STATE();//清除发送中断标志位
 463   1        //  UART0_TX_INT_DISABLE();
 464   1        //}
 465   1      #if 0
                INT_UART0_CLR();
                
                if(GET_UART0_RX_STATE())
                {
                  uart_sendbuflen = 5;
                  CLR_UART0_RX_STATE();//清除接收中断标志位
                }
                else
                {
                  if(uart_getbuflen == UART0_GET_DATA_LEN )
                    return;
                  else
                    uart_get_buf[uart_getbuflen++] = UART0_BUF;
                }
              //  if(GET_UART0_TX_STATE())
              //  {
              //    CLR_UART0_TX_STATE();//清除发送中断标志位
              //      UART0_TX_INT_DISABLE();   
              //  }
              
              #endif
 487   1      }
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         02/19/2021 17:29:46 PAGE 9   

 488          
 489          /*
 490          parameter: 
 491            none
 492          return :
 493            none
 494          */
 495          unsigned char dqiot_drv_get_uart0_data(unsigned char len)
 496          {
 497   1      #if 1
 498   1        if (len > UART0_GET_DATA_LEN)
 499   1          return 0xFF;
 500   1        else
 501   1        {
 502   2          if (len == 0)
 503   2            return uart_sendbuflen;
 504   2          else if (len == 1)
 505   2            return uart_getbuflen;
 506   2          else
 507   2            return uart_get_buf[len - 2];
 508   2        }
 509   1      #else
                return uart_get_buf[len];
              #endif
 512   1      }
 513          
 514          /*
 515          parameter: 
 516            none
 517          return :
 518            none
 519          */
 520          void dqiot_drv_uart0_sendData(unsigned char *p_data, unsigned char length)
 521          {
 522   1      #if 1
 523   1        unsigned char i = 0;
 524   1        dqiot_drv_uart0B_init();
 525   1        memset(uart_send_buf, 0x00, sizeof(uart_send_buf));
 526   1        memcpy(uart_send_buf, p_data, length);
 527   1        uart_sendbuflen = length;
 528   1      
 529   1        for (i = 0; i < length; i++)
 530   1        {
 531   2          // uart_tx_byte(UART0,p_data[i]);
 532   2          uart_tx_byte(UART0, uart_send_buf[i]);
 533   2        }
 534   1      #endif
 535   1      }
 536          
 537          /*
 538          parameter: 
 539            none
 540          return :
 541            none
 542          */
 543          void dqiot_drv_log_output(unsigned char *string)
 544          {
 545   1        dqiot_drv_uart0A_init();
 546   1        while ((*string != '\r') && (*(string + 1) != '\n'))
 547   1        {
 548   2          uart_tx_byte(UART0, *string++);
 549   2        }
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         02/19/2021 17:29:46 PAGE 10  

 550   1        uart_tx_byte(UART0, '\r');
 551   1        uart_tx_byte(UART0, '\n');
 552   1        return;
 553   1      }
 554          
 555          /*
 556          parameter: 
 557            none
 558          return :
 559            none
 560          */
 561          void dqiot_drv_log_output_data(unsigned char sym, unsigned char out_data)
 562          {
 563   1      #if 1
 564   1        unsigned char i = 0, j = 0;
 565   1        unsigned char data_temp[10];
 566   1        unsigned int temp_data = out_data;
 567   1        dqiot_drv_uart0A_init(); //初始化uart0 PE4、5
 568   1      
 569   1        memset(data_temp, 0x00, sizeof(data_temp));
 570   1        for (i = 0; i < 10; i++)
 571   1          uart_tx_byte(UART0, sym);
 572   1      
 573   1        i = 0;
 574   1      
 575   1        while (temp_data / 10)
 576   1        {
 577   2          data_temp[i++] = temp_data % 10;
 578   2          temp_data = temp_data / 10;
 579   2          if (temp_data < 10)
 580   2          {
 581   3            data_temp[i] = temp_data;
 582   3            data_temp[i + 1] = '\0';
 583   3          }
 584   2        }
 585   1      
 586   1        if (i == 0)
 587   1        {
 588   2          uart_tx_byte(UART0, out_data + 0x30);
 589   2        }
 590   1        else
 591   1        {
 592   2          while (i > 0)
 593   2          {
 594   3            uart_tx_byte(UART0, data_temp[i--] + 0x30);
 595   3            if (i == 0)
 596   3            {
 597   4              uart_tx_byte(UART0, data_temp[0] + 0x30);
 598   4              break;
 599   4            }
 600   3          }
 601   2        }
 602   1      
 603   1        for (i = 0; i < 10; i++)
 604   1          uart_tx_byte(UART0, sym);
 605   1      
 606   1        uart_tx_byte(UART0, '\r');
 607   1        uart_tx_byte(UART0, '\n');
 608   1        return;
 609   1      #else
                dqiot_drv_uart0A_init(); //初始化uart0 PE4、5
                uart_tx_byte(UART0, out_data);
C51 COMPILER V9.59.0.0   DQIOT_DRV                                                         02/19/2021 17:29:46 PAGE 11  

              #endif
 613   1      }
 614          
 615          char putchar(char c)
 616          {
 617   1        uart_tx_byte(UART0, c);
 618   1        return c;
 619   1      }
 620          
 621          #endif //__DQIOT_DRV_C__


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1346    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     51      25
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
