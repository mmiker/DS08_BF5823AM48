C51 COMPILER V9.59.0.0   MMI_DECODE                                                        04/27/2021 12:00:57 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MMI_DECODE
OBJECT MODULE PLACED IN .\output\mmi_decode.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE mmi_src\mmi_decode.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\includ
                    -e;.\Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd
                    -_rfid;.\mmi_inc) DEBUG PRINT(.\list\mmi_decode.lst) TABS(2) OBJECT(.\output\mmi_decode.obj)

line level    source

   1          #ifndef __MMI_DECODE_C__
   2          #define __MMI_DECODE_C__
   3          #include "mmi_feature.h"
   4          #ifdef __LOCK_DECODE_SUPPORT__
   5          #include "mmi_decode.h"
   6          #include "string.h"
   7          #include <stdio.h>
   8          
   9          /*
  10          original_key[0][10] exg_key_10
  11          original_key[1][10] sec_key_10
  12          */
  13          unsigned char original_key[2][10];
  14          otp_exchg_num g_pwd_signed_data[10];
  15          decode_data get_decode;
  16          
  17          static unsigned char decode_rondom_code_remainder(unsigned char *random_code);
  18          static unsigned char decode_rondom_code_plus(unsigned char leng, unsigned char array_column);
  19          static unsigned char decode_rondom_code_extract(void);
  20          static void dq_sdk_CharToHexByte(const unsigned char *source, char *dest, int sourceLen);
  21          static unsigned int n_power(unsigned char value);
  22          static void dq_sdk_ByteToHexStr(const unsigned char *source, char *dest, int sourceLen);
  23          
  24          /**
  25            * @brief  校验码解码
  26            * @param  随机码数组
  27            * @return status
  28            * @note   none
  29            * @see    none
  30            */
  31          void decode_check_code(unsigned char *random_code)
  32          {
  33   1          unsigned char i;
  34   1          unsigned int value = 0;
  35   1          unsigned int temp = 0;
  36   1          for (i = 0; i < 13; i++)
  37   1          {
  38   2              if (i % 2 == 0)
  39   2                  value += random_code[i] * 2;
  40   2              else
  41   2                  value += random_code[i] * random_code[i];
  42   2          }
  43   1      
  44   1          temp = value % 100;
  45   1          if (temp < 10)
  46   1              value = temp * 10;
  47   1          else
  48   1              value = temp;
  49   1      
  50   1          get_decode.chk_key_2[0] = (char)(value / 10);
  51   1          get_decode.chk_key_2[1] = (char)(value % 10);
  52   1      
  53   1          // printf("value is %d\n", value);
C51 COMPILER V9.59.0.0   MMI_DECODE                                                        04/27/2021 12:00:57 PAGE 2   

  54   1          // printf("temp is %d\n", temp);
  55   1          // for (i = 0; i < 2; i++)
  56   1          //     printf("chk_key_2 is %d\n", (int)get_decode.chk_key_2[i]);
  57   1      
  58   1          return;
  59   1      }
  60          
  61          /**
  62            * @brief  随机码解码
  63            * @param  随机码数组
  64            * @return status
  65            * @note   none
  66            * @see    none
  67            */
  68          void mmi_dq_decode_app_random_code(unsigned char *random_code)
  69          {
  70   1          // unsigned char i;
  71   1          decode_rondom_code_remainder(random_code); //获取10位解码
  72   1          decode_rondom_code_extract();              //获取8/9位解码
  73   1      
  74   1          // for (i = 0; i < 10; i++)
  75   1          //     printf("exg_code10[%d] is %d\n", (int)i, (int)get_decode.exg_key_10[i]);
  76   1          // for (i = 0; i < 9; i++)
  77   1          //     printf("exg_code9[%d] is %d\n", (int)i, (int)get_decode.exg_key_9[i]);
  78   1          // for (i = 0; i < 8; i++)
  79   1          //     printf("exg_code8[%d] is %d\n", (int)i, (int)get_decode.exg_key_8[i]);
  80   1          // for (i = 0; i < 10; i++)
  81   1          //     printf("sec_code10[%d] is %d\n", (int)i, (int)get_decode.sec_key_10[i]);
  82   1          // for (i = 0; i < 9; i++)
  83   1          //     printf("sec_code9[%d] is %d\n", (int)i, (int)get_decode.sec_key_9[i]);
  84   1          // for (i = 0; i < 8; i++)
  85   1          //     printf("sec_code8[%d] is %d\n", (int)i, (int)get_decode.sec_key_8[i]);
  86   1          // printf("############\n");
  87   1      
  88   1          return;
  89   1      }
  90          
  91          /**
  92            * @brief  时间戳解码10位
  93            * @param  pwd 字符数组(16进制)
  94            * @param  len 长度
  95            * @param  sec_key 安全解码
  96            * @param  exg_key 交换解码
  97            * @return status
  98            * @note   none
  99            * @see    none
 100            */
 101          void decode_time_stamp_10num(unsigned char *pwd, unsigned char len, unsigned char *sec_key, unsigned char 
             -*exg_key)
 102          {
 103   1          unsigned char sec_key_char[10];
 104   1          unsigned char exg_key_char[10];
 105   1          unsigned char pwd_char[10];
 106   1          unsigned char sec_char[10];
 107   1          unsigned char i = 0;
 108   1          unsigned char j = 0;
 109   1          unsigned char hex_pwd_len = 5;
 110   1          unsigned char exchange_id = 0;
 111   1          unsigned char exchange_char[10];
 112   1          unsigned long high_sec_key = 0, low_sec_key = 0;
 113   1          unsigned long high_pwd = 0, low_pwd = 0;
 114   1      
C51 COMPILER V9.59.0.0   MMI_DECODE                                                        04/27/2021 12:00:57 PAGE 3   

 115   1          memset(sec_key_char, 0x00, sizeof(sec_key_char));
 116   1          memset(exg_key_char, 0x00, sizeof(exg_key_char));
 117   1          memset(pwd_char, 0x00, sizeof(pwd_char));
 118   1      
 119   1          dq_sdk_CharToHexByte((const unsigned char *)exg_key, (char *)exg_key_char, hex_pwd_len);
 120   1          for (j = 0; j < hex_pwd_len; j++)
 121   1          {
 122   2              if (exg_key_char[j] == 0)
 123   2                  exg_key_char[j] = 10;
 124   2          }
 125   1      
 126   1          dq_sdk_CharToHexByte((const unsigned char *)sec_key, (char *)sec_key_char, hex_pwd_len);
 127   1          CharToInt_2long(sec_key_char, &high_sec_key, &low_sec_key);
 128   1      
 129   1          dq_sdk_CharToHexByte((const unsigned char *)pwd, (char *)pwd_char, hex_pwd_len);
 130   1      
 131   1          for (i = 0; i < 59; i++)
 132   1          {
 133   2              CharToInt_2long((const unsigned char *)pwd_char, &high_pwd, &low_pwd);
 134   2      
 135   2              if (low_pwd < low_sec_key)
 136   2              {
 137   3                  high_pwd -= 1;
 138   3                  low_pwd += 100000;
 139   3              }
 140   2              if (high_pwd < high_sec_key)
 141   2              {
 142   3                  high_pwd += 100000;
 143   3              }
 144   2              high_pwd -= high_sec_key;
 145   2              low_pwd -= low_sec_key;
 146   2              memset(sec_char, 0x00, sizeof(sec_char));
 147   2              IntToByteStr_2long(high_pwd, low_pwd, (char *)sec_char, 5, 5);
 148   2              memset(pwd_char, 0x00, sizeof(pwd_char));
 149   2              for (j = 0; j < len; j++)
 150   2              {
 151   3                  pwd_char[exg_key_char[j] - 1] = sec_char[j];
 152   3              }
 153   2          }
 154   1      
 155   1          memset(sec_char, 0x00, sizeof(sec_char));
 156   1          exchange_id = pwd_char[2];
 157   1          memset(exchange_char, 0x00, sizeof(exchange_char));
 158   1          dq_sdk_CharToHexByte((const unsigned char *)g_pwd_signed_data[exchange_id].exchg_num, (char *)exchange
             -_char, 5);
 159   1      
 160   1          for (i = 0; i < len; i++)
 161   1          {
 162   2              if (i == 2)
 163   2              {
 164   3                  sec_char[i] = exchange_id;
 165   3              }
 166   2              else
 167   2              {
 168   3                  for (j = 0; j < 10; j++)
 169   3                  {
 170   4                      if (pwd_char[i] == exchange_char[j])
 171   4                      {
 172   5                          sec_char[i] = j;
 173   5                          break;
 174   5                      }
 175   4                  }
C51 COMPILER V9.59.0.0   MMI_DECODE                                                        04/27/2021 12:00:57 PAGE 4   

 176   3              }
 177   2          }
 178   1          for (i = 2; i < len; i++)
 179   1          {
 180   2              sec_char[i] = sec_char[i + 1];
 181   2          }
 182   1          sec_char[len - 1] = exchange_id;
 183   1          memcpy((char *)get_decode.tim_key_10, (const char *)sec_char, len);
 184   1      
 185   1          // for (i = 0; i < len; i++)
 186   1          //     printf("time_decode[%d] is %d\n", (int)i, (int)get_decode.tim_key_10[i]);
 187   1          // printf("get_decode sizeof is %d\n", (int)sizeof(get_decode));
 188   1          // printf("############\n");
 189   1      
 190   1          return;
 191   1      }
 192          
 193          // /**
 194          //   * @brief  时间同步
 195          //   * @param  时间戳解码10位
 196          //   * @return status
 197          //   * @note   none
 198          //   * @see    none
 199          //   */
 200          // decode_status dq_otp_syn_start_time(unsigned char *p_data)
 201          // {
 202          //     unsigned char i = 0;
 203          //     unsigned char start_time[5];
 204          
 205          //     memset(start_time, 0x00, sizeof(start_time));
 206          //     for (i = 0; i < 5; i++)
 207          //     {
 208          //         start_time[i] = p_data[i + 2];
 209          //     }
 210          //     if (get_decode.start_hour == 0xFFFFFFFF)
 211          //     {
 212          //         get_decode.start_hour = dq_sdk_HexcharToInt(start_time, 4);
 213          //         return DECODE_CMD_SUCCESS;
 214          //     }
 215          //     else
 216          //     {
 217          //         unsigned char ret;
 218          //         get_decode.start_hour = dq_sdk_HexcharToInt(start_time, 4);
 219          //         // g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_SET, (unsigned char *)&otp_set_info, sizeof(otp_base_
             -setting_info), &ret, dq_otp_fds_write_common_cb);
 220          //         return DECODE_CMD_SUCCESS;
 221          //     }
 222          // }
 223          
 224          /**
 225            * @brief  计算n^n次方
 226            * @param  value 值
 227            * @return status
 228            * @note   none
 229            * @see    none
 230            */
 231          static unsigned int n_power(unsigned char value)
 232          {
 233   1          unsigned char i;
 234   1          unsigned int num = 1;
 235   1          for (i = 0; i < value; i++)
 236   1          {
C51 COMPILER V9.59.0.0   MMI_DECODE                                                        04/27/2021 12:00:57 PAGE 5   

 237   2              num *= (int)value;
 238   2          }
 239   1          return num;
 240   1      }
 241          
 242          /**
 243            * @brief  随机码初次解码
 244            * @param  随机码
 245            * @return status
 246            * @note   none
 247            * @see    none
 248            */
 249          static unsigned char decode_rondom_code_remainder(unsigned char *random_code)
 250          {
 251   1          unsigned char i = 0, j = 0;
 252   1          unsigned char temp1 = 0, temp2 = 0;
 253   1          unsigned int top_three = 0, rev_three = 0; //前三位，翻转
 254   1      
 255   1          top_three = random_code[0] * 100 + random_code[1] * 10 + random_code[2];
 256   1          rev_three = random_code[2] * 100 + random_code[1] * 10 + random_code[0];
 257   1      
 258   1          for (i = 0; i < 10; i++)
 259   1          {
 260   2              temp1 = top_three % (10 - i);
 261   2              temp2 = rev_three % (10 - i);
 262   2      
 263   2              original_key[0][i] = temp1;
 264   2              original_key[1][i] = temp2;
 265   2          }
 266   1      
 267   1          decode_rondom_code_plus(10, 0);
 268   1          decode_rondom_code_plus(10, 1);
 269   1      
 270   1          return 0;
 271   1      }
 272          
 273          /**
 274            * @brief  获取10位完整解码
 275            * @param  数据长度
 276            * @param  二位数组行号（数据存入该行）
 277            * @return status
 278            * @note   none
 279            * @see    none
 280            */
 281          static unsigned char decode_rondom_code_plus(unsigned char leng, unsigned char array_column)
 282          {
 283   1          unsigned char i, j;
 284   1      
 285   1          for (i = 0; i < leng; i++)
 286   1          {
 287   2              for (j = 0; j < i;)
 288   2              {
 289   3                  if (original_key[array_column][i] == original_key[array_column][j])
 290   3                  {
 291   4                      original_key[array_column][i] += 1;
 292   4                      if (original_key[array_column][i] == 10)
 293   4                          original_key[array_column][i] = 0;
 294   4                      j = 0;
 295   4                  }
 296   3                  else
 297   3                  {
 298   4                      if (array_column == 0)
C51 COMPILER V9.59.0.0   MMI_DECODE                                                        04/27/2021 12:00:57 PAGE 6   

 299   4                          get_decode.exg_key_10[i] = original_key[array_column][i];
 300   4                      else
 301   4                          get_decode.sec_key_10[i] = original_key[array_column][i];
 302   4      
 303   4                      j++;
 304   4                  }
 305   3              }
 306   2              if (i == 0)
 307   2              {
 308   3                  if (array_column == 0)
 309   3                      get_decode.exg_key_10[i] = original_key[array_column][i];
 310   3                  else
 311   3                      get_decode.sec_key_10[i] = original_key[array_column][i];
 312   3              }
 313   2          }
 314   1      
 315   1          return 0;
 316   1      }
 317          
 318          /**
 319            * @brief  获取8/9位解码
 320            * @param  none
 321            * @return status
 322            * @note   none
 323            * @see    none
 324            */
 325          static unsigned char decode_rondom_code_extract(void)
 326          {
 327   1          unsigned char i, j;
 328   1      
 329   1          j = 0;
 330   1          for (i = 0; i < 10; i++)
 331   1          {
 332   2              if (original_key[0][i] != 0 && original_key[0][i] != 9)
 333   2              {
 334   3                  get_decode.exg_key_8[j] = original_key[0][i];
 335   3                  j++;
 336   3              }
 337   2          }
 338   1      
 339   1          j = 0;
 340   1          for (i = 0; i < 10; i++)
 341   1          {
 342   2              if (original_key[1][i] != 0 && original_key[1][i] != 9)
 343   2              {
 344   3                  get_decode.sec_key_8[j] = original_key[1][i];
 345   3                  j++;
 346   3              }
 347   2          }
 348   1      
 349   1          j = 0;
 350   1          for (i = 0; i < 10; i++)
 351   1          {
 352   2              if (original_key[0][i] != 0)
 353   2              {
 354   3                  get_decode.exg_key_9[j] = original_key[0][i];
 355   3                  j++;
 356   3              }
 357   2          }
 358   1      
 359   1          j = 0;
 360   1          for (i = 0; i < 10; i++)
C51 COMPILER V9.59.0.0   MMI_DECODE                                                        04/27/2021 12:00:57 PAGE 7   

 361   1          {
 362   2              if (original_key[1][i] != 0)
 363   2              {
 364   3                  get_decode.sec_key_9[j] = original_key[1][i];
 365   3                  j++;
 366   3              }
 367   2          }
 368   1      
 369   1          return 0;
 370   1      }
 371          
 372          /**
 373            * @brief  字符数组转整形
 374            * @param  p_data 字符数组
 375            * @param  len 字符数组长度
 376            * @return 值
 377            * @note   none
 378            * @see    none
 379            */
 380          unsigned long CharToInt_long(unsigned char *p_data, unsigned char len)
 381          {
 382   1          unsigned char i, j;
 383   1          unsigned long temp1 = 0;
 384   1      
 385   1          for (j = 0, i = 0; i < len; i++)
 386   1          {
 387   2              if (p_data[i] == 0xff)
 388   2              {
 389   3                  j = i;
 390   3                  break;
 391   3              }
 392   2          }
 393   1      
 394   1          for (i = 0; i < j; i++)
 395   1              temp1 = (temp1 * 10 + p_data[i]);
 396   1      
 397   1          return temp1;
 398   1      }
 399          
 400          /**
 401            * @brief  10位字符数组转整形
 402            * @param  source 数组
 403            * @param  sourcelen 长度
 404            * @param  high 高位5
 405            * @param  low 低位5
 406            * @return status
 407            * @note   none
 408            * @see    none
 409            */
 410          unsigned char CharToInt_2long(const unsigned char *source, unsigned long *high, unsigned long *low)
 411          {
 412   1          short i;
 413   1          *high = 0;
 414   1          *low = 0;
 415   1          for (i = 0; i < 5; i++)
 416   1          {
 417   2              *high = *high * 10 + source[i];
 418   2          }
 419   1          for (i = 5; i < 10; i++)
 420   1          {
 421   2              *low = *low * 10 + source[i];
 422   2          }
C51 COMPILER V9.59.0.0   MMI_DECODE                                                        04/27/2021 12:00:57 PAGE 8   

 423   1      
 424   1          return 0;
 425   1      }
 426          
 427          /**
 428            * @brief  10位整形转数组
 429            * @param  high 高位
 430            * @param  low 低位
 431            * @param  dest 数组
 432            * @param  highLen 高位长度
 433            * @param  lowlen 低位长度
 434            * @return status
 435            * @note   none
 436            * @see    none
 437            */
 438          unsigned char IntToByteStr_2long(unsigned long high, unsigned long low, char *dest, int highLen, int lowhi
             -gh)
 439          {
 440   1          unsigned char i = 0;
 441   1          unsigned long temp_data1 = high;
 442   1          unsigned long temp_data2 = low;
 443   1          for (i = 0; i < 5; i++)
 444   1          {
 445   2              dest[highLen - i - 1] = temp_data1 % 10;
 446   2              temp_data1 = temp_data1 / 10;
 447   2          }
 448   1          for (i = 0; i < 5; i++)
 449   1          {
 450   2              dest[highLen + lowhigh - i - 1] = temp_data2 % 10;
 451   2              temp_data2 = temp_data2 / 10;
 452   2          }
 453   1      
 454   1          return 0;
 455   1      }
 456          
 457          /**
 458            * @brief  十六进制转数组
 459            * @param  source
 460            * @param  dest
 461            * @param  sourceLen
 462            * @return status
 463            * @note   none
 464            * @see    none
 465            */
 466          static void dq_sdk_CharToHexByte(const unsigned char *source, char *dest, int sourceLen)
 467          {
 468   1          short i;
 469   1          unsigned char highByte, lowByte;
 470   1          for (i = 0; i < sourceLen; i++)
 471   1          {
 472   2              highByte = source[i] >> 4;
 473   2              lowByte = source[i] & 0x0f;
 474   2              dest[i * 2] = highByte;
 475   2              if (lowByte != 0x0F)
 476   2                  dest[i * 2 + 1] = lowByte;
 477   2          }
 478   1          return;
 479   1      }
 480          
 481          int dq_sdk_HexcharToInt(unsigned char *source, int length)
 482          {
 483   1          int int_data = 0;
C51 COMPILER V9.59.0.0   MMI_DECODE                                                        04/27/2021 12:00:57 PAGE 9   

 484   1          char dest[20];
 485   1          unsigned char ret = 0;
 486   1          //dest = malloc(length*2*sizeof(unsigned char));
 487   1      
 488   1          memset(dest, 0x00, sizeof(dest));
 489   1          dq_sdk_ByteToHexStr(source, dest, length);
 490   1          ret = sscanf((const char *)dest, "%x", &int_data);
 491   1      
 492   1          //free(dest);
 493   1          if (ret == 1)
 494   1              return int_data;
 495   1          else
 496   1              return 0;
 497   1      }
 498          
 499          static void dq_sdk_ByteToHexStr(const unsigned char *source, char *dest, int sourceLen)
 500          {
 501   1          short i;
 502   1          unsigned char highByte, lowByte;
 503   1          for (i = 0; i < sourceLen; i++)
 504   1          {
 505   2              highByte = source[i] >> 4;
 506   2              lowByte = source[i] & 0x0f;
 507   2              highByte += 0x30;
 508   2              if (highByte > 0x39)
 509   2                  dest[i * 2] = highByte + 0x07;
 510   2              else
 511   2                  dest[i * 2] = highByte;
 512   2              lowByte += 0x30;
 513   2              if (lowByte > 0x39)
 514   2                  dest[i * 2 + 1] = lowByte + 0x07;
 515   2              else
 516   2                  dest[i * 2 + 1] = lowByte;
 517   2          }
 518   1          return;
 519   1      }
 520          
 521          #endif //__LOCK_DECODE_SUPPORT__
 522          #endif //__MMI_DECODE_C__


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3381    ----
   CONSTANT SIZE    =      3    ----
   XDATA SIZE       =    146     191
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
