C51 COMPILER V9.59.0.0   MMI_DECODE                                                        04/23/2021 13:15:58 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MMI_DECODE
OBJECT MODULE PLACED IN .\output\mmi_decode.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE mmi_src\mmi_decode.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\includ
                    -e;.\Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd
                    -_rfid;.\mmi_inc) DEBUG PRINT(.\list\mmi_decode.lst) TABS(2) OBJECT(.\output\mmi_decode.obj)

line level    source

   1          #ifndef __MMI_DECODE_C__
   2          #define __MMI_DECODE_C__
   3          #include "mmi_feature.h"
   4          #ifdef __LOCK_DECODE_SUPPORT__
   5          #include "mmi_decode.h"
   6          #include "dqiot_drv.h"
   7          #include "string.h"
   8          #include <stdio.h>
   9          
  10          /*
  11          original_key[0][10] exg_key_10
  12          original_key[1][10] sec_key_10
  13          */
  14          unsigned char original_key[2][10];
  15          struct decode_data get_decode;
  16          
  17          static unsigned char decode_rondom_code_remainder(unsigned char *random_code);
  18          static unsigned char decode_rondom_code_plus(unsigned char leng, unsigned char array_column);
  19          static unsigned char decode_rondom_code_extract(void);
  20          
  21          /**
  22            * @brief  随机码解码
  23            * @param  字符数组
  24            * @return status
  25            * @note   none
  26            * @see    none
  27            */
  28          unsigned char mmi_dq_decode_app_random_code(unsigned char *random_code)
  29          {
  30   1          // unsigned char i;
  31   1      
  32   1          decode_rondom_code_remainder(random_code); //获取10位解码
  33   1          decode_rondom_code_extract();              //获取8/9位解码
  34   1      
  35   1          // dqiot_drv_uart0A_init();
  36   1          // for (i = 0; i < 10; i++)
  37   1          //     printf("exg_code10[%d] is %d\n", (int)i, (int)get_decode.exg_key_10[i]);
  38   1          // for (i = 0; i < 9; i++)
  39   1          //     printf("exg_code9[%d] is %d\n", (int)i, (int)get_decode.exg_key_9[i]);
  40   1          // for (i = 0; i < 8; i++)
  41   1          //     printf("exg_code8[%d] is %d\n", (int)i, (int)get_decode.exg_key_8[i]);
  42   1          // printf("############\n");
  43   1          // for (i = 0; i < 10; i++)
  44   1          //     printf("sec_code10[%d] is %d\n", (int)i, (int)get_decode.sec_key_10[i]);
  45   1          // for (i = 0; i < 9; i++)
  46   1          //     printf("sec_code9[%d] is %d\n", (int)i, (int)get_decode.sec_key_9[i]);
  47   1          // for (i = 0; i < 8; i++)
  48   1          //     printf("sec_code8[%d] is %d\n", (int)i, (int)get_decode.sec_key_8[i]);
  49   1          // dqiot_drv_uart0B_init();
  50   1      
  51   1          return 0;
  52   1      }
  53          
C51 COMPILER V9.59.0.0   MMI_DECODE                                                        04/23/2021 13:15:58 PAGE 2   

  54          /**
  55            * @brief  随机码初次解码
  56            * @param  随机码
  57            * @return status
  58            * @note   none
  59            * @see    none
  60            */
  61          static unsigned char decode_rondom_code_remainder(unsigned char *random_code)
  62          {
  63   1          unsigned char i = 0, j = 0;
  64   1          unsigned char temp1 = 0, temp2 = 0;
  65   1          unsigned int top_three = 0, rev_three = 0; //前三位，翻转
  66   1      
  67   1          top_three = random_code[0] * 100 + random_code[1] * 10 + random_code[2];
  68   1          rev_three = random_code[2] * 100 + random_code[1] * 10 + random_code[0];
  69   1      
  70   1          for (i = 0; i < 10; i++)
  71   1          {
  72   2              temp1 = top_three % (10 - i);
  73   2              temp2 = rev_three % (10 - i);
  74   2      
  75   2              original_key[0][i] = temp1;
  76   2              original_key[1][i] = temp2;
  77   2          }
  78   1      
  79   1          decode_rondom_code_plus(10, 0);
  80   1          decode_rondom_code_plus(10, 1);
  81   1      
  82   1          return 0;
  83   1      }
  84          
  85          /**
  86            * @brief  获取10位完整解码
  87            * @param  数据长度
  88            * @param  二位数组行号（数据存入该行）
  89            * @return status
  90            * @note   none
  91            * @see    none
  92            */
  93          static unsigned char decode_rondom_code_plus(unsigned char leng, unsigned char array_column)
  94          {
  95   1          unsigned char i, j;
  96   1      
  97   1          for (i = 0; i < leng; i++)
  98   1          {
  99   2              for (j = 0; j < i;)
 100   2              {
 101   3                  if (original_key[array_column][i] == original_key[array_column][j])
 102   3                  {
 103   4                      original_key[array_column][i] += 1;
 104   4                      if (original_key[array_column][i] == 10)
 105   4                          original_key[array_column][i] = 0;
 106   4                      j = 0;
 107   4                  }
 108   3                  else
 109   3                  {
 110   4                      if (array_column == 0)
 111   4                          get_decode.exg_key_10[i] = original_key[array_column][i];
 112   4                      else
 113   4                          get_decode.sec_key_10[i] = original_key[array_column][i];
 114   4      
 115   4                      j++;
C51 COMPILER V9.59.0.0   MMI_DECODE                                                        04/23/2021 13:15:58 PAGE 3   

 116   4                  }
 117   3              }
 118   2              if (i == 0)
 119   2              {
 120   3                  if (array_column == 0)
 121   3                      get_decode.exg_key_10[i] = original_key[array_column][i];
 122   3                  else
 123   3                      get_decode.sec_key_10[i] = original_key[array_column][i];
 124   3              }
 125   2          }
 126   1      
 127   1          return 0;
 128   1      }
 129          
 130          /**
 131            * @brief  获取8/9位解码
 132            * @param  none
 133            * @return status
 134            * @note   none
 135            * @see    none
 136            */
 137          static unsigned char decode_rondom_code_extract(void)
 138          {
 139   1          unsigned char i, j;
 140   1      
 141   1          j = 0;
 142   1          for (i = 0; i < 10; i++)
 143   1          {
 144   2              if (original_key[0][i] != 0 && original_key[0][i] != 9)
 145   2              {
 146   3                  get_decode.exg_key_8[j] = original_key[0][i];
 147   3                  j++;
 148   3              }
 149   2          }
 150   1      
 151   1          j = 0;
 152   1          for (i = 0; i < 10; i++)
 153   1          {
 154   2              if (original_key[1][i] != 0 && original_key[1][i] != 9)
 155   2              {
 156   3                  get_decode.sec_key_8[j] = original_key[1][i];
 157   3                  j++;
 158   3              }
 159   2          }
 160   1      
 161   1          j = 0;
 162   1          for (i = 0; i < 10; i++)
 163   1          {
 164   2              if (original_key[0][i] != 0)
 165   2              {
 166   3                  get_decode.exg_key_9[j] = original_key[0][i];
 167   3                  j++;
 168   3              }
 169   2          }
 170   1      
 171   1          j = 0;
 172   1          for (i = 0; i < 10; i++)
 173   1          {
 174   2              if (original_key[1][i] != 0)
 175   2              {
 176   3                  get_decode.sec_key_9[j] = original_key[1][i];
 177   3                  j++;
C51 COMPILER V9.59.0.0   MMI_DECODE                                                        04/23/2021 13:15:58 PAGE 4   

 178   3              }
 179   2          }
 180   1      
 181   1          return 0;
 182   1      }
 183          
 184          #endif //__LOCK_DECODE_SUPPORT__
 185          #endif //__MMI_DECODE_C__


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    749    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     74      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
