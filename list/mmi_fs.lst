<<<<<<< HEAD
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/24/2021 17:19:10 PAGE 1   
=======
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/25/2021 17:43:02 PAGE 1   
>>>>>>> six commit


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MMI_FS
OBJECT MODULE PLACED IN .\output\mmi_fs.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE mmi_src\mmi_fs.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;.\
                    -Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd_rfi
                    -d;.\mmi_inc) DEBUG PRINT(.\list\mmi_fs.lst) TABS(2) OBJECT(.\output\mmi_fs.obj)

line level    source

   1          #ifndef __MMI_FS_C__
   2          #define __MMI_FS_C__
   3          
   4          #include "mmi_fs.h"
   5          #include "mmi_sys.h"
   6          #include "mcu02_sfr.h"
   7          #include "mcu02_eeprom.h"
   8          #include "string.h"
   9          //#include "stdio.h"
  10          
  11          #include "mmi_fps.h"
  12          
  13          mmi_fs_setting g_dq_fs_init_set;
  14          
  15          #define MMI_DQ_FS_PWD_MAX_NUM 100
<<<<<<< HEAD
  16          mmi_fs_pwd g_dq_fs_pwd[MMI_DQ_FS_PWD_MAX_NUM];
  17          
  18          #if defined(__LOCK_FP_SUPPORT__)
  19          #define MMI_DQ_FS_FP_MAX_NUM 50
  20          mmi_fs_fp g_dq_fs_fp[MMI_DQ_FS_FP_MAX_NUM];
  21          #endif
  22          
  23          #ifdef __LOCK_RFID_CARD_SUPPORT__
  24          #define MMI_DQ_FS_RFID_MAX_NUM 10
  25          mmi_fs_rfid g_dq_fs_rfid[MMI_DQ_FS_RFID_MAX_NUM];
  26          #endif
  27          
  28          static void mmi_dq_fds_read(mid_fds_file_id file, uint8_t *r_data, uint16_t r_size)
  29          {
  30   1        uint16_t i;
  31   1      
  32   1        switch (file)
  33   1        {
  34   2        case MID_FDS_FILE_SET:
  35   2          eeprom_select(0);
  36   2          for (i = 0; i < r_size; i++)
  37   2          {
  38   3            r_data[i] = eeprom_read_byte(0, i); //读第一页
  39   3          }
  40   2          break;
  41   2        case MID_FDS_FILE_PWD:
  42   2          eeprom_select(0);
  43   2          for (i = 0; i < r_size; i++)
  44   2          {
  45   3            r_data[i] = eeprom_read_byte(0, i + 24); //读第一页
  46   3          }
  47   2          break;
  48   2        case MID_FDS_FILE_FP:
  49   2          eeprom_select(1);
  50   2          eeprom_nvr_read_page(r_data, 0, 0, r_size);
  51   2          break;
  52   2        case MID_FDS_FILE_RF:
  53   2          eeprom_select(1);
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/24/2021 17:19:10 PAGE 2   

  54   2          eeprom_nvr_read_page(r_data, 1, 0, r_size);
  55   2          break;
  56   2        default:
  57   2          break;
  58   2        }
  59   1      }
  60          
  61          static RET_VAL mmi_dq_fds_write(mid_fds_file_id file, uint8_t *w_data, uint16_t w_size)
  62          {
  63   1        uint16_t i;
  64   1        ErrStatus ret;
  65   1        eeprom_erase_time(9);
  66   1        switch (file)
  67   1        {
  68   2        case MID_FDS_FILE_SET:
  69   2        {
  70   3          uint8_t *w_data2 = (uint8_t *)g_dq_fs_pwd;
  71   3          uint16_t w_size2 = sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_NUM;
  72   3          eeprom_select(0);
  73   3          eeprom_erase_page(0); //擦除1K
  74   3          for (i = 0; i < w_size; i++)
  75   3          {
  76   4            ret = eeprom_write_byte(0, i, w_data[i]); //读第一页
  77   4            if (ret == ERROR)
  78   4            {
  79   5              //printf("mmi_dq_fds_write  error  %d\n",i);
  80   5              return RET_FAIL;
  81   5            }
  82   4          }
  83   3          for (i = 0; i < w_size2; i++)
  84   3          {
  85   4            ret = eeprom_write_byte(0, i + 24, w_data2[i]); //读第一页
  86   4            if (ret == ERROR)
  87   4            {
  88   5              //printf("mmi_dq_fds_write  error  %d\n",i);
  89   5              return RET_FAIL;
  90   5            }
  91   4          }
  92   3        }
  93   2        break;
  94   2        case MID_FDS_FILE_PWD:
  95   2        {
  96   3          uint8_t *w_data2 = (uint8_t *)&g_dq_fs_init_set;
  97   3          uint16_t w_size2 = sizeof(mmi_fs_setting);
  98   3          eeprom_select(0);
  99   3          eeprom_erase_page(0); //擦除1K
 100   3          for (i = 0; i < w_size2; i++)
 101   3          {
 102   4            ret = eeprom_write_byte(0, i, w_data2[i]); //读第一页
 103   4            if (ret == ERROR)
 104   4            {
 105   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 106   5              return RET_FAIL;
 107   5            }
 108   4          }
 109   3          for (i = 0; i < w_size; i++)
 110   3          {
 111   4            ret = eeprom_write_byte(0, i + 24, w_data[i]); //读第一页
 112   4            if (ret == ERROR)
 113   4            {
 114   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 115   5              return RET_FAIL;
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/24/2021 17:19:10 PAGE 3   

 116   5            }
 117   4          }
 118   3        }
 119   2        break;
 120   2        case MID_FDS_FILE_FP:
 121   2          eeprom_select(1);
 122   2          eeprom_erase_page(0); //擦除512byte
 123   2          for (i = 0; i < w_size; i++)
 124   2          {
 125   3            ret = eeprom_write_byte(0, i, w_data[i]);
 126   3            if (ret == ERROR)
 127   3            {
 128   4              //printf("mmi_dq_fds_write  error  %d\n",i);
 129   4              return RET_FAIL;
 130   4            }
 131   3          }
 132   2          break;
 133   2        case MID_FDS_FILE_RF:
 134   2          eeprom_select(1);
 135   2          eeprom_erase_page(1); //擦除512byte
 136   2          for (i = 0; i < w_size; i++)
 137   2          {
 138   3            ret = eeprom_write_byte(1, i, w_data[i]);
 139   3            if (ret == ERROR)
 140   3            {
 141   4              //printf("mmi_dq_fds_write  error  %d\n",i);
 142   4              return RET_FAIL;
 143   4            }
 144   3          }
 145   2          break;
 146   2        default:
 147   2          return RET_FAIL;
 148   2        }
 149   1        //printf("mmi_dq_fds_write  suc\n");
 150   1        return RET_SUCESS;
 151   1      }
 152          
 153          /*
 154          parameter: 
 155            none
 156          return :
 157            none
 158          */
 159          void mmi_dq_fs_init(void)
 160          {
 161   1        mmi_dq_fds_read(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 162   1        if (FDS_INIT_LOCK_SUC == g_dq_fs_init_set.init_flag || FDS_INIT_APP_SUC == g_dq_fs_init_set.init_flag)
 163   1        {
 164   2          unsigned char i = 0;
 165   2          mmi_dq_fds_read(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_N
             -UM);
 166   2          mmi_dq_fds_read(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM);
 167   2          mmi_dq_fds_read(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MAX
             -_NUM);
 168   2          if (g_dq_fs_init_set.admin_status > 0)
 169   2          {
 170   3            for (; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 171   3            {
 172   4              if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
 173   4                break;
 174   4            }
 175   3            if (i >= MMI_DQ_FS_PWD_MAX_NUM)
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/24/2021 17:19:10 PAGE 4   

 176   3            {
 177   4              g_dq_fs_init_set.admin_status = 0;
 178   4              mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 179   4            }
 180   3          }
 181   2        }
 182   1        else
 183   1        {
 184   2          //printf("mmi_dq_fs_init init error");
 185   2          memset(g_dq_fs_pwd, 0xFF, sizeof(g_dq_fs_pwd));
 186   2          mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_
             -NUM);
 187   2      
 188   2          memset(g_dq_fs_fp, 0xFF, sizeof(g_dq_fs_fp));
 189   2          mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM)
             -;
 190   2      
 191   2          mmi_dq_fp_empty();
 192   2      
 193   2          memset(g_dq_fs_rfid, 0xFF, sizeof(g_dq_fs_rfid));
 194   2          mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MA
             -X_NUM);
 195   2      
 196   2          g_dq_fs_init_set.init_flag = FDS_INIT_LOCK_SUC;
 197   2          g_dq_fs_init_set.open_pro_sound = 1;
 198   2          g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 199   2          g_dq_fs_init_set.admin_status = 0;
 200   2          g_dq_fs_init_set.factory_flag = 0;
 201   2          g_dq_fs_init_set.wifi_flag = 0;
 202   2          mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 203   2        }
 204   1      }
 205          
 206          /**
 207            * @brief  手动初始化
 208            * @param  none
 209            * @return none
 210            * @note   none
 211            * @see    none
 212            */
 213          RET_VAL mmi_dq_fs_clr_set(void)
 214          {
 215   1        g_dq_fs_init_set.open_pro_sound = 1;
 216   1        g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 217   1      
 218   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 219   1      }
 220          
 221          /**
 222            * @brief  复位初始化
 223            * @param  none
 224            * @return none
 225            * @note   none
 226            * @see    none
 227            */
 228          RET_VAL mmi_dq_fs_reset(void)
 229          {
 230   1        memset(g_dq_fs_pwd, 0xFF, sizeof(g_dq_fs_pwd));
 231   1        mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_N
             -UM);
 232   1      
 233   1        memset(g_dq_fs_fp, 0xFF, sizeof(g_dq_fs_fp));
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/24/2021 17:19:10 PAGE 5   

 234   1        mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM);
 235   1      
 236   1        mmi_dq_fp_empty();
 237   1      
 238   1        memset(g_dq_fs_rfid, 0xFF, sizeof(g_dq_fs_rfid));
 239   1        mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MAX
             -_NUM);
 240   1      
 241   1        g_dq_fs_init_set.init_flag = FDS_INIT_LOCK_SUC;
 242   1        g_dq_fs_init_set.open_pro_sound = 1;
 243   1        g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 244   1        g_dq_fs_init_set.admin_status = 0;
 245   1        g_dq_fs_init_set.wifi_flag = 0;
 246   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 247   1      }
 248          
 249          /*
 250          parameter: 
 251            none
 252          return :
 253            none
 254          */
 255          void mmi_dq_fs_pwd_string_to_byte(unsigned char *input_pwd, unsigned char pwd_len, unsigned char *output_p
             -wd)
 256          {
 257   1        unsigned char i = 0;
 258   1        unsigned char bit_l = 0;
 259   1        unsigned char bit_h = 0;
 260   1      
 261   1        for (i = 0; i < pwd_len; i++)
 262   1        {
 263   2          bit_l = *(input_pwd + i) & 0x0F;
 264   2          i++;
 265   2          if (i < pwd_len)
 266   2            bit_h = *(input_pwd + i) & 0x0F;
 267   2          else
 268   2            bit_h = 0xF;
 269   2          *output_pwd++ = bit_l << 4 | bit_h;
 270   2        }
 271   1        return;
 272   1      }
 273          /*
 274          parameter: 
 275            none
 276          return :
 277            none
 278          */
 279          void mmi_dq_fs_pwd_byte_to_string(unsigned char *input_pwd, unsigned char *output_pwd)
 280          {
 281   1        unsigned char i = 0;
 282   1        unsigned char pwd = 0;
 283   1        for (i = 0; i < 4; i++)
 284   1        {
 285   2          pwd = *(input_pwd + i);
 286   2          if (pwd == 0xFF)
 287   2            break;
 288   2          else
 289   2            *output_pwd++ = (pwd & 0xF0) >> 4;
 290   2          if ((pwd & 0x0F) == 0x0F)
 291   2            break;
 292   2          else
 293   2          {
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/24/2021 17:19:10 PAGE 6   

 294   3            *output_pwd++ = pwd & 0x0F;
 295   3          }
 296   2        }
 297   1        return;
 298   1      }
 299          
 300          /*
 301          parameter: 
 302            none
 303          return :
 304            none
 305          */
 306          unsigned char mmi_dq_fs_get_pwd_unuse_index(void)
 307          {
 308   1        unsigned char i = 0;
 309   1      
 310   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 311   1        {
 312   2          if (g_dq_fs_pwd[i].flag == 0xFF)
 313   2            break;
 314   2        }
 315   1      
 316   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 317   1          return i;
 318   1        else
 319   1          return 0xFF;
 320   1      }
 321          
 322          /*
 323          parameter: 
 324            none
 325          return :
 326            none
 327          */
 328          unsigned char mmi_dq_fs_check_input_pwd(unsigned char *input_pwd, unsigned char len, fds_use_type type)
 329          {
 330   1        unsigned char i = 0;
 331   1        unsigned char k = 0;
 332   1        unsigned char password[4];
 333   1        unsigned char ret_val = 0xFF;
 334   1      
 335   1        memset(password, 0xFF, sizeof(password));
 336   1        mmi_dq_fs_pwd_string_to_byte(input_pwd, len, password);
 337   1      
 338   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 339   1        {
 340   2          if (g_dq_fs_pwd[i].flag != 0xFF)
 341   2          {
 342   3            for (k = 0; k < 4; k++)
 343   3            {
 344   4              if (password[k] != g_dq_fs_pwd[i].key_pwd[k])
 345   4                break;
 346   4            }
 347   3            if (k == 4)
 348   3            {
 349   4              break;
 350   4            }
 351   3          }
 352   2        }
 353   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 354   1        {
 355   2          if ((g_dq_fs_pwd[i].flag == type) || (type == FDS_USE_TYPE_ALL))
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/24/2021 17:19:10 PAGE 7   

 356   2            ret_val = i;
 357   2          else
 358   2            ret_val = 0xFF;
 359   2        }
 360   1        else
 361   1          ret_val = 0xFF;
 362   1      
 363   1        return ret_val;
 364   1      }
 365          
 366          /*
 367          parameter: 
 368            none
 369          return :
 370            none
 371          */
 372          RET_VAL mmi_dq_fs_set_pwd(unsigned char *pwd, unsigned char pwd_size, fds_use_type type)
 373          {
 374   1        unsigned char i = 0xFF;
 375   1        unsigned char password[4];
 376   1      
 377   1        if (type == FDS_USE_TYPE_ADMIN)
 378   1        {
 379   2          for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 380   2          {
 381   3            if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
 382   3              break;
 383   3          }
 384   2        }
 385   1        if (i >= MMI_DQ_FS_PWD_MAX_NUM)
 386   1        {
 387   2          for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 388   2          {
 389   3            if (g_dq_fs_pwd[i].flag == 0xFF)
 390   3              break;
 391   3          }
 392   2        }
 393   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 394   1        {
 395   2          memset(password, 0xFF, sizeof(password));
 396   2          //g_dq_fs_pwd[i].index = i;
 397   2          mmi_dq_fs_pwd_string_to_byte(pwd, pwd_size, password);
 398   2          memcpy((char *)g_dq_fs_pwd[i].key_pwd, (const char *)password, 4);
 399   2          g_dq_fs_pwd[i].flag = type;
 400   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_P
             -WD_MAX_NUM);
 401   2        }
 402   1        return RET_FAIL;
 403   1      }
 404          
 405          /*
 406          parameter: 
 407            none
 408          return :
 409            none
 410          */
 411          RET_VAL mmi_dq_fs_del_pwd(unsigned char index, fds_use_type type)
 412          {
 413   1        if (index < MMI_DQ_FS_PWD_MAX_NUM && g_dq_fs_pwd[index].flag == type)
 414   1        {
 415   2          g_dq_fs_pwd[index].flag = FDS_USE_TYPE_INVALID;
 416   2          //g_dq_fs_pwd[index].index = 0xFF;
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/24/2021 17:19:10 PAGE 8   

 417   2          memset(g_dq_fs_pwd[index].key_pwd, 0xFF, sizeof(g_dq_fs_pwd[index].key_pwd));
 418   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_P
             -WD_MAX_NUM);
 419   2        }
 420   1        return RET_FAIL;
 421   1      }
 422          
 423          /*
 424          parameter: 
 425            none
 426          return :
 427            none
 428          */
 429          RET_VAL mmi_dq_fs_clr_pwd(void)
 430          {
 431   1        unsigned char i = 0;
 432   1      
 433   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 434   1        {
 435   2          if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_USER)
 436   2          {
 437   3            g_dq_fs_pwd[i].flag = FDS_USE_TYPE_INVALID;
 438   3            //g_dq_fs_pwd[i].index = 0xFF;
 439   3            memset(g_dq_fs_pwd[i].key_pwd, 0xFF, sizeof(g_dq_fs_pwd[i].key_pwd));
 440   3          }
 441   2        }
 442   1        return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PW
             -D_MAX_NUM);
 443   1      }
 444          
 445          #if defined(__LOCK_FP_SUPPORT__)
 446          /*
 447          parameter: 
 448            none
 449          return :
 450            none
 451          */
 452          unsigned char mmi_dq_fs_get_fp_unuse_index(void)
 453          {
 454   1        unsigned char i = 2;
 455   1      
 456   1        for (; i < MMI_DQ_FS_FP_MAX_NUM; i++)
 457   1        {
 458   2          if (g_dq_fs_fp[i].fp_index == 0xFF)
 459   2            break;
 460   2        }
 461   1        if (i >= MMI_DQ_FS_FP_MAX_NUM)
 462   1          return 0xFF;
 463   1        return i;
 464   1      }
 465          
 466          /*
 467          parameter: 
 468            none
 469          return :
 470            none
 471          */
 472          RET_VAL mmi_dq_fs_check_fp(unsigned char fp_index, fds_use_type type)
 473          {
 474   1        if ((fp_index < MMI_DQ_FS_FP_MAX_NUM) && (g_dq_fs_fp[fp_index].fp_index == fp_index) && ((g_dq_fs_fp[fp_i
             -ndex].flag == type) || (type == FDS_USE_TYPE_ALL)))
 475   1          return RET_SUCESS;
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/24/2021 17:19:10 PAGE 9   

 476   1        else
 477   1          return RET_FAIL;
 478   1      }
 479          
 480          /*
 481          parameter: 
 482            none
 483          return :
 484            none
 485          */
 486          RET_VAL mmi_dq_fs_set_fp(unsigned char fs_index, fds_use_type type)
 487          {
 488   1        g_dq_fs_fp[fs_index].fp_index = fs_index;
 489   1        g_dq_fs_fp[fs_index].flag = type;
 490   1        return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MA
             -X_NUM);
 491   1      }
 492          
 493          /*
 494          parameter: 
 495            none
 496          return :
 497            none
 498          */
 499          RET_VAL mmi_dq_fs_del_fp(unsigned char fp_index, fds_use_type type)
 500          {
 501   1        if (mmi_dq_fs_check_fp(fp_index, type) == RET_SUCESS)
 502   1        {
 503   2          g_dq_fs_fp[fp_index].flag = FDS_USE_TYPE_INVALID;
 504   2          g_dq_fs_fp[fp_index].fp_index = 0xFF;
 505   2          return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_M
             -AX_NUM);
 506   2        }
 507   1        return RET_FAIL;
 508   1      }
 509          
 510          /*
 511          parameter: 
 512            none
 513          return :
 514            none
 515          */
 516          RET_VAL mmi_dq_fs_clr_fp(void)
 517          {
 518   1        unsigned char i = 0;
 519   1        unsigned short fp_ret = 0;
 520   1      
 521   1        for (i = 0; i < MMI_DQ_FS_FP_MAX_NUM; i++)
 522   1        {
 523   2          if (g_dq_fs_fp[i].flag != FDS_USE_TYPE_ADMIN)
 524   2          {
 525   3            if (g_dq_fs_fp[i].fp_index != 0xFF)
 526   3            {
 527   4              fp_ret = mmi_dq_fp_delete(g_dq_fs_fp[i].fp_index);
 528   4              if (fp_ret == 0)
 529   4              {
 530   5                g_dq_fs_fp[i].flag = FDS_USE_TYPE_INVALID;
 531   5                g_dq_fs_fp[i].fp_index = 0xFF;
 532   5              }
 533   4            }
 534   3          }
 535   2        }
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/24/2021 17:19:10 PAGE 10  

 536   1      
 537   1        return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MA
             -X_NUM);
 538   1      }
 539          
 540          #endif
 541          
 542          #ifdef __LOCK_RFID_CARD_SUPPORT__
 543          
 544          /*
 545          parameter: 
 546            none
 547          return :
 548            none
 549          */
 550          unsigned char mmi_dq_fs_get_rfid_unuse_index(void)
 551          {
 552   1        unsigned char i = 0;
 553   1      
 554   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 555   1        {
 556   2          if (g_dq_fs_rfid[i].index == 0xFF)
 557   2            break;
 558   2        }
 559   1      
 560   1        if (i >= MMI_DQ_FS_RFID_MAX_NUM)
 561   1          return 0xFF;
 562   1        return i;
 563   1      }
=======
  16          mmi_fs_pwd    g_dq_fs_pwd[MMI_DQ_FS_PWD_MAX_NUM];
  17          
  18          #if defined(__LOCK_FP_SUPPORT__) 
  19          #define     MMI_DQ_FS_FP_MAX_NUM      50
  20          mmi_fs_fp   g_dq_fs_fp[MMI_DQ_FS_FP_MAX_NUM];
  21          #endif
  22          
  23          #ifdef __LOCK_RFID_CARD_SUPPORT__
  24          #define     MMI_DQ_FS_RFID_MAX_NUM      10
  25          mmi_fs_rfid   g_dq_fs_rfid[MMI_DQ_FS_RFID_MAX_NUM];
  26          #endif
  27          
  28          
  29          
  30          static void mmi_dq_fds_read(mid_fds_file_id file,  uint8_t* r_data ,uint16_t r_size)
  31          {
  32   1        uint16_t i;
  33   1      
  34   1        switch(file)
  35   1        {
  36   2          case MID_FDS_FILE_SET:
  37   2            eeprom_select(0);
  38   2            for(i = 0; i < r_size; i++)
  39   2            {
  40   3              r_data[i] = eeprom_read_byte(0,i);//读第一页
  41   3            }
  42   2            break;
  43   2          case MID_FDS_FILE_PWD:
  44   2            eeprom_select(0);
  45   2            for(i = 0; i < r_size; i++)
  46   2            {
  47   3              r_data[i] = eeprom_read_byte(0,i+24);//读第一页
  48   3            }
  49   2            break;
  50   2      #ifdef __LOCK_FP_SUPPORT__
  51   2          case MID_FDS_FILE_FP:
  52   2            eeprom_select(1);
  53   2            eeprom_nvr_read_page(r_data,0,0,r_size);
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/25/2021 17:43:02 PAGE 2   

  54   2            break;
  55   2      #endif
  56   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
  57   2          case MID_FDS_FILE_RF:
  58   2            eeprom_select(1);
  59   2              eeprom_nvr_read_page(r_data,1,0,r_size);
  60   2            break;
  61   2      #endif
  62   2          default:
  63   2            break;
  64   2        }
  65   1      }
  66          
  67          static RET_VAL mmi_dq_fds_write(mid_fds_file_id file, uint8_t* w_data ,uint16_t w_size)
  68          {
  69   1        uint16_t i;
  70   1          ErrStatus ret;
  71   1        eeprom_erase_time(9);
  72   1        switch(file)
  73   1        {
  74   2          case MID_FDS_FILE_SET:
  75   2            {
  76   3              uint8_t* w_data2 = (uint8_t *)g_dq_fs_pwd;
  77   3              uint16_t w_size2 = sizeof(mmi_fs_pwd)*MMI_DQ_FS_PWD_MAX_NUM;
  78   3              eeprom_select(0);
  79   3              eeprom_erase_page(0);//擦除1K
  80   3              for(i = 0; i < w_size; i++)
  81   3              {
  82   4                ret = eeprom_write_byte(0,i,w_data[i]);//读第一页
  83   4                if(ret==ERROR) 
  84   4                {
  85   5                  //printf("mmi_dq_fds_write  error  %d\n",i);
  86   5                  return RET_FAIL;
  87   5                }
  88   4              }
  89   3              for(i = 0; i < w_size2; i++)
  90   3              {
  91   4                ret = eeprom_write_byte(0,i+24,w_data2[i]);//读第一页
  92   4                if(ret==ERROR) 
  93   4                {
  94   5                  //printf("mmi_dq_fds_write  error  %d\n",i);
  95   5                  return RET_FAIL;
  96   5                }
  97   4              }
  98   3            }
  99   2            break;
 100   2          case MID_FDS_FILE_PWD:
 101   2            {
 102   3              uint8_t* w_data2 = (uint8_t *)&g_dq_fs_init_set;
 103   3              uint16_t w_size2 = sizeof(mmi_fs_setting);
 104   3              eeprom_select(0);
 105   3              eeprom_erase_page(0);//擦除1K
 106   3              for(i = 0; i < w_size2; i++)
 107   3              {
 108   4                ret = eeprom_write_byte(0,i,w_data2[i]);//读第一页
 109   4                if(ret==ERROR) 
 110   4                {
 111   5                  //printf("mmi_dq_fds_write  error  %d\n",i);
 112   5                  return RET_FAIL;
 113   5                }
 114   4              }
 115   3              for(i = 0; i < w_size; i++)
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/25/2021 17:43:02 PAGE 3   

 116   3              {
 117   4                ret = eeprom_write_byte(0,i+24,w_data[i]);//读第一页
 118   4                if(ret==ERROR) 
 119   4                {
 120   5                  //printf("mmi_dq_fds_write  error  %d\n",i);
 121   5                  return RET_FAIL;
 122   5                }
 123   4              }
 124   3            }
 125   2            break;
 126   2      #ifdef __LOCK_FP_SUPPORT__
 127   2          case MID_FDS_FILE_FP:
 128   2            eeprom_select(1);
 129   2            eeprom_erase_page(0);//擦除512byte
 130   2            for(i = 0; i < w_size; i++)
 131   2            {
 132   3              ret = eeprom_write_byte(0,i,w_data[i]);
 133   3              if(ret==ERROR) 
 134   3              {
 135   4                //printf("mmi_dq_fds_write  error  %d\n",i);
 136   4                return RET_FAIL;
 137   4              }
 138   3            }
 139   2            break;
 140   2      #endif
 141   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 142   2          case MID_FDS_FILE_RF:
 143   2            eeprom_select(1);
 144   2            eeprom_erase_page(1);//擦除512byte
 145   2            for(i = 0; i < w_size; i++)
 146   2            {
 147   3              ret = eeprom_write_byte(1,i,w_data[i]);
 148   3              if(ret==ERROR) 
 149   3              {
 150   4                //printf("mmi_dq_fds_write  error  %d\n",i);
 151   4                return RET_FAIL;
 152   4              }
 153   3            }
 154   2            break;
 155   2      #endif
 156   2          default:
 157   2            return RET_FAIL;
 158   2        }
 159   1        //printf("mmi_dq_fds_write  suc\n");
 160   1        return RET_SUCESS;
 161   1      }
 162          
 163          
 164          
 165          /*
 166          parameter: 
 167            none
 168          return :
 169            none
 170          */
 171          void mmi_dq_fs_init(void)
 172          {
 173   1        mmi_dq_fds_read(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 174   1        if(FDS_INIT_LOCK_SUC == g_dq_fs_init_set.init_flag || FDS_INIT_APP_SUC == g_dq_fs_init_set.init_flag)
 175   1        {
 176   2          unsigned char i = 0;
 177   2          mmi_dq_fds_read(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd)*MMI_DQ_FS_PWD_MAX_NUM
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/25/2021 17:43:02 PAGE 4   

             -);
 178   2      #ifdef __LOCK_FP_SUPPORT__
 179   2          mmi_dq_fds_read(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp)*MMI_DQ_FS_FP_MAX_NUM);
 180   2      #endif
 181   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 182   2          mmi_dq_fds_read(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid)*MMI_DQ_FS_RFID_MAX_N
             -UM);
 183   2      #endif
 184   2          if(g_dq_fs_init_set.admin_status > 0)
 185   2          {
 186   3            for(;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 187   3            {
 188   4              if(g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
 189   4                break;
 190   4            }
 191   3            if(i>=MMI_DQ_FS_PWD_MAX_NUM)
 192   3            {
 193   4              g_dq_fs_init_set.admin_status = 0;
 194   4              mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 195   4            }
 196   3          }
 197   2        }
 198   1        else
 199   1        {
 200   2          //printf("mmi_dq_fs_init init error");
 201   2          memset(g_dq_fs_pwd,0xFF,sizeof(g_dq_fs_pwd));
 202   2          mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd)*MMI_DQ_FS_PWD_MAX_NU
             -M);
 203   2          
 204   2      #ifdef __LOCK_FP_SUPPORT__
 205   2          memset(g_dq_fs_fp,0xFF,sizeof(g_dq_fs_fp));
 206   2          mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp)*MMI_DQ_FS_FP_MAX_NUM);
 207   2      
 208   2          mmi_dq_fp_empty();
 209   2      #endif
 210   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 211   2          memset(g_dq_fs_rfid,0xFF,sizeof(g_dq_fs_rfid));
 212   2          mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid)*MMI_DQ_FS_RFID_MAX_
             -NUM);
 213   2      #endif
 214   2          g_dq_fs_init_set.init_flag = FDS_INIT_LOCK_SUC;
 215   2          g_dq_fs_init_set.open_pro_sound = 1;
 216   2          g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 217   2          g_dq_fs_init_set.admin_status = 0;
 218   2          g_dq_fs_init_set.factory_flag = 0;
 219   2          g_dq_fs_init_set.wifi_flag = 0;
 220   2          mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 221   2        }
 222   1      }
 223          
 224          /**
 225            * @brief  手动初始化
 226            * @param  none
 227            * @return none
 228            * @note   none
 229            * @see    none
 230            */
 231          RET_VAL mmi_dq_fs_clr_set(void)
 232          {
 233   1        g_dq_fs_init_set.open_pro_sound = 1;
 234   1        g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 235   1      
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/25/2021 17:43:02 PAGE 5   

 236   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 237   1      }
 238          
 239          /**
 240            * @brief  复位初始化
 241            * @param  none
 242            * @return none
 243            * @note   none
 244            * @see    none
 245            */
 246          RET_VAL mmi_dq_fs_reset(void)
 247          {
 248   1        memset(g_dq_fs_pwd, 0xFF, sizeof(g_dq_fs_pwd));
 249   1        mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_N
             -UM);
 250   1      #ifdef __LOCK_FP_SUPPORT__
 251   1        memset(g_dq_fs_fp, 0xFF, sizeof(g_dq_fs_fp));
 252   1        mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM);
 253   1      
 254   1        mmi_dq_fp_empty();
 255   1      #endif
 256   1      #ifdef __LOCK_RFID_CARD_SUPPORT__
 257   1        memset(g_dq_fs_rfid, 0xFF, sizeof(g_dq_fs_rfid));
 258   1        mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MAX
             -_NUM);
 259   1      #endif
 260   1        g_dq_fs_init_set.init_flag = FDS_INIT_LOCK_SUC;
 261   1        g_dq_fs_init_set.open_pro_sound = 1;
 262   1        g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 263   1        g_dq_fs_init_set.admin_status = 0;
 264   1        g_dq_fs_init_set.wifi_flag = 0;
 265   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 266   1      }
 267          
 268          /*
 269          parameter: 
 270            none
 271          return :
 272            none
 273          */
 274          void mmi_dq_fs_pwd_string_to_byte(unsigned char *input_pwd,unsigned char pwd_len,unsigned char *output_pwd
             -)
 275          {
 276   1        unsigned char i = 0;
 277   1        unsigned char bit_l = 0;
 278   1        unsigned char bit_h = 0;
 279   1      
 280   1        for(i=0;i<pwd_len;i++)
 281   1        {
 282   2          bit_l = *(input_pwd+i)&0x0F;
 283   2          i++;
 284   2          if(i < pwd_len)
 285   2            bit_h = *(input_pwd+i)&0x0F;
 286   2          else
 287   2            bit_h = 0xF;
 288   2          *output_pwd++ = bit_l<<4|bit_h;
 289   2        }
 290   1        return;
 291   1      }
 292          /*
 293          parameter: 
 294            none
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/25/2021 17:43:02 PAGE 6   

 295          return :
 296            none
 297          */
 298          void mmi_dq_fs_pwd_byte_to_string(unsigned char *input_pwd,unsigned char *output_pwd)
 299          {
 300   1        unsigned char i = 0;
 301   1        unsigned char pwd = 0;
 302   1        for(i=0;i<4;i++)
 303   1        {
 304   2          pwd = *(input_pwd+i);
 305   2          if(pwd == 0xFF)
 306   2            break;
 307   2          else 
 308   2            *output_pwd++ = (pwd&0xF0)>>4;
 309   2          if((pwd&0x0F) == 0x0F)
 310   2            break;
 311   2          else
 312   2          {
 313   3            *output_pwd++ = pwd&0x0F;
 314   3          }
 315   2        }
 316   1        return;
 317   1      }
 318          
 319          /*
 320          parameter: 
 321            none
 322          return :
 323            none
 324          */
 325          unsigned char mmi_dq_fs_get_pwd_unuse_index(void)
 326          {
 327   1        unsigned char i = 0;
 328   1      
 329   1        for(i=0;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 330   1        {
 331   2          if(g_dq_fs_pwd[i].flag == 0xFF)
 332   2            break;
 333   2        }
 334   1      
 335   1        if(i<MMI_DQ_FS_PWD_MAX_NUM)
 336   1          return i;
 337   1        else
 338   1          return 0xFF;
 339   1      }
 340          
 341          /*
 342          parameter: 
 343            none
 344          return :
 345            none
 346          */
 347          unsigned char mmi_dq_fs_check_input_pwd(unsigned char *input_pwd,unsigned char len,fds_use_type type)
 348          {
 349   1        unsigned char i = 0;
 350   1        unsigned char k = 0;
 351   1        unsigned char password[4];
 352   1        unsigned char ret_val = 0xFF;
 353   1        
 354   1        memset(password,0xFF,sizeof(password));
 355   1        mmi_dq_fs_pwd_string_to_byte(input_pwd,len,password);
 356   1        
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/25/2021 17:43:02 PAGE 7   

 357   1        for(i=0;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 358   1        {
 359   2          if(g_dq_fs_pwd[i].flag != 0xFF)
 360   2          {
 361   3            for(k=0;k<4;k++)
 362   3            {
 363   4              if(password[k] != g_dq_fs_pwd[i].key_pwd[k])
 364   4                break;
 365   4            }
 366   3            if(k == 4)
 367   3            {
 368   4              break;
 369   4            }
 370   3          }
 371   2        }
 372   1        if(i<MMI_DQ_FS_PWD_MAX_NUM)
 373   1        {
 374   2          if((g_dq_fs_pwd[i].flag == type)||(type == FDS_USE_TYPE_ALL))
 375   2            ret_val = i;
 376   2          else
 377   2            ret_val = 0xFF;
 378   2        }
 379   1        else
 380   1          ret_val = 0xFF;
 381   1        
 382   1        return ret_val;
 383   1      }
 384          
 385          /*
 386          parameter: 
 387            none
 388          return :
 389            none
 390          */
 391          RET_VAL mmi_dq_fs_set_pwd(unsigned char *pwd,unsigned char pwd_size,fds_use_type type)
 392          {
 393   1        unsigned char i = 0xFF;
 394   1        unsigned char password[4];
 395   1      
 396   1        if(type == FDS_USE_TYPE_ADMIN)
 397   1        {
 398   2          for(i=0;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 399   2          {
 400   3            if(g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
 401   3              break;
 402   3          }
 403   2        }
 404   1        if(i >= MMI_DQ_FS_PWD_MAX_NUM)
 405   1        {
 406   2          for(i=0;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 407   2          {
 408   3            if(g_dq_fs_pwd[i].flag == 0xFF)
 409   3              break;
 410   3          }
 411   2        }
 412   1        if(i<MMI_DQ_FS_PWD_MAX_NUM)
 413   1        {
 414   2          memset(password,0xFF,sizeof(password));
 415   2          //g_dq_fs_pwd[i].index = i;
 416   2          mmi_dq_fs_pwd_string_to_byte(pwd,pwd_size,password);
 417   2          memcpy((char *)g_dq_fs_pwd[i].key_pwd,(const char *)password,4);
 418   2          g_dq_fs_pwd[i].flag = type;
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/25/2021 17:43:02 PAGE 8   

 419   2          return  mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd,sizeof(mmi_fs_pwd)*MMI_DQ_FS_PWD_
             -MAX_NUM);
 420   2          
 421   2        }
 422   1        return RET_FAIL;
 423   1      }
 424          
 425          /*
 426          parameter: 
 427            none
 428          return :
 429            none
 430          */
 431          RET_VAL mmi_dq_fs_del_pwd(unsigned char index,fds_use_type type)
 432          {
 433   1        if(index < MMI_DQ_FS_PWD_MAX_NUM && g_dq_fs_pwd[index].flag == type)
 434   1        {
 435   2          g_dq_fs_pwd[index].flag = FDS_USE_TYPE_INVALID;
 436   2          //g_dq_fs_pwd[index].index = 0xFF;
 437   2          memset(g_dq_fs_pwd[index].key_pwd,0xFF,sizeof(g_dq_fs_pwd[index].key_pwd));
 438   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd,sizeof(mmi_fs_pwd)*MMI_DQ_FS_PWD_
             -MAX_NUM);
 439   2        }
 440   1        return RET_FAIL;
 441   1      }
 442          
 443          /*
 444          parameter: 
 445            none
 446          return :
 447            none
 448          */
 449          RET_VAL mmi_dq_fs_clr_pwd(void)
 450          {
 451   1        unsigned char i = 0;
 452   1      
 453   1        for(i=0;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 454   1        {
 455   2          if(g_dq_fs_pwd[i].flag == FDS_USE_TYPE_USER)
 456   2          {
 457   3            g_dq_fs_pwd[i].flag = FDS_USE_TYPE_INVALID;
 458   3            //g_dq_fs_pwd[i].index = 0xFF;
 459   3            memset(g_dq_fs_pwd[i].key_pwd,0xFF,sizeof(g_dq_fs_pwd[i].key_pwd));
 460   3          }
 461   2        }
 462   1        return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd,sizeof(mmi_fs_pwd)*MMI_DQ_FS_PWD_M
             -AX_NUM);
 463   1      }
 464          
 465          
 466          #if defined (__LOCK_FP_SUPPORT__)
 467          /*
 468          parameter: 
 469            none
 470          return :
 471            none
 472          */
 473          unsigned char mmi_dq_fs_get_fp_unuse_index(void)
 474          {
 475   1        unsigned char i = 2;
 476   1        
 477   1        for(;i<MMI_DQ_FS_FP_MAX_NUM;i++)
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/25/2021 17:43:02 PAGE 9   

 478   1        {
 479   2          if(g_dq_fs_fp[i].fp_index == 0xFF)
 480   2            break;
 481   2        }
 482   1        if(i>=MMI_DQ_FS_FP_MAX_NUM)
 483   1          return 0xFF;
 484   1        return i;
 485   1      }
 486          
 487          /*
 488          parameter: 
 489            none
 490          return :
 491            none
 492          */
 493          RET_VAL mmi_dq_fs_check_fp(unsigned char fp_index, fds_use_type type)
 494          {
 495   1        if((fp_index < MMI_DQ_FS_FP_MAX_NUM) && (g_dq_fs_fp[fp_index].fp_index == fp_index) && ((g_dq_fs_fp[fp_in
             -dex].flag == type)||(type == FDS_USE_TYPE_ALL)))
 496   1          return RET_SUCESS;
 497   1        else
 498   1          return RET_FAIL;
 499   1      }
 500          
 501          /*
 502          parameter: 
 503            none
 504          return :
 505            none
 506          */
 507          RET_VAL mmi_dq_fs_set_fp(unsigned char fs_index,fds_use_type type)
 508          {
 509   1        g_dq_fs_fp[fs_index].fp_index = fs_index;
 510   1        g_dq_fs_fp[fs_index].flag = type;
 511   1        return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp)*MMI_DQ_FS_FP_MAX_
             -NUM);
 512   1      }
 513          
 514          /*
 515          parameter: 
 516            none
 517          return :
 518            none
 519          */
 520          RET_VAL mmi_dq_fs_del_fp(unsigned char fp_index,fds_use_type type)
 521          {
 522   1        if(mmi_dq_fs_check_fp(fp_index,type) == RET_SUCESS)
 523   1        {
 524   2          g_dq_fs_fp[fp_index].flag = FDS_USE_TYPE_INVALID;
 525   2          g_dq_fs_fp[fp_index].fp_index = 0xFF;
 526   2          return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp)*MMI_DQ_FS_FP_MAX
             -_NUM);
 527   2        }
 528   1        return RET_FAIL;
 529   1      }
 530          
 531          /*
 532          parameter: 
 533            none
 534          return :
 535            none
 536          */
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/25/2021 17:43:02 PAGE 10  

 537          RET_VAL mmi_dq_fs_clr_fp(void)
 538          {
 539   1        unsigned char i = 0;
 540   1        unsigned short fp_ret = 0;
 541   1      
 542   1        for(i=0;i<MMI_DQ_FS_FP_MAX_NUM;i++)
 543   1        {
 544   2          if(g_dq_fs_fp[i].flag != FDS_USE_TYPE_ADMIN)
 545   2          {
 546   3            if(g_dq_fs_fp[i].fp_index != 0xFF)
 547   3            {
 548   4              fp_ret = mmi_dq_fp_delete(g_dq_fs_fp[i].fp_index);
 549   4              if(fp_ret == 0)
 550   4              {
 551   5                g_dq_fs_fp[i].flag = FDS_USE_TYPE_INVALID;
 552   5                g_dq_fs_fp[i].fp_index = 0xFF;
 553   5              }
 554   4            }
 555   3          }
 556   2        }
 557   1        return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp)*MMI_DQ_FS_FP_MAX_
             -NUM);
 558   1      }
 559          
 560          #endif
 561          
 562          
 563          #ifdef __LOCK_RFID_CARD_SUPPORT__
>>>>>>> six commit
 564          
 565          /*
 566          parameter: 
 567            none
 568          return :
 569            none
 570          */
<<<<<<< HEAD
 571          unsigned char mmi_dq_fs_check_rfid(unsigned char *sec_data, fds_use_type type)
 572          {
 573   1        unsigned char i = 0, j = 0;
 574   1      
 575   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 576   1        {
 577   2          for (j = 0; j < RFID_SEC_DATA_LEN; j++)
 578   2          {
 579   3            if (g_dq_fs_rfid[i].sec_data[j] != sec_data[j])
 580   3              break;
 581   3          }
 582   2          if (j == RFID_SEC_DATA_LEN)
 583   2            break;
 584   2        }
 585   1        if (i < MMI_DQ_FS_RFID_MAX_NUM && ((g_dq_fs_rfid[i].flag == type) || (type == FDS_USE_TYPE_ALL)))
 586   1        {
 587   2          return i;
 588   2        }
 589   1        else
 590   1        {
 591   2          return 0xFF;
 592   2        }
 593   1      }
 594          
 595          /*
 596          parameter: 
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/24/2021 17:19:10 PAGE 11  

 597            none
 598          return :
 599            none
 600          */
 601          RET_VAL mmi_dq_fs_set_rfid(unsigned char *sec_data, fds_use_type type)
 602          {
 603   1        unsigned char i = 0, j = 0;
 604   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 605   1        {
 606   2          if (g_dq_fs_rfid[i].index == 0xFF)
 607   2            break;
 608   2        }
 609   1        if (i < MMI_DQ_FS_RFID_MAX_NUM)
 610   1        {
 611   2          g_dq_fs_rfid[i].index = i;
 612   2          g_dq_fs_rfid[i].flag = type;
 613   2          for (j = 0; j < RFID_SEC_DATA_LEN; j++)
 614   2          {
 615   3            g_dq_fs_rfid[i].sec_data[j] = sec_data[j];
 616   3          }
 617   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_
             -RFID_MAX_NUM);
 618   2        }
 619   1        return RET_FAIL;
 620   1      }
 621          
 622          /*
 623          parameter: 
 624            none
 625          return :
 626            none
 627          */
 628          RET_VAL mmi_dq_fs_del_rfid(unsigned char rfid_index)
 629          {
 630   1        if (rfid_index < MMI_DQ_FS_RFID_MAX_NUM && g_dq_fs_rfid[rfid_index].index == rfid_index)
 631   1        {
 632   2          g_dq_fs_rfid[rfid_index].index = 0xFF;
 633   2          g_dq_fs_rfid[rfid_index].flag = FDS_USE_TYPE_INVALID;
 634   2          memset(g_dq_fs_rfid[rfid_index].sec_data, 0xFF, sizeof(g_dq_fs_rfid[rfid_index].sec_data));
 635   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_
             -RFID_MAX_NUM);
 636   2        }
 637   1        return RET_FAIL;
 638   1      }
 639          
 640          /*
 641          parameter: 
 642            none
 643          return :
 644            none
 645          */
 646          RET_VAL mmi_dq_fs_clr_rfid(void)
 647          {
 648   1        unsigned char i = 0;
 649   1      
 650   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 651   1        {
 652   2          g_dq_fs_rfid[i].flag = FDS_USE_TYPE_INVALID;
 653   2          g_dq_fs_rfid[i].index = 0xFF;
 654   2          memset(g_dq_fs_rfid[i].sec_data, 0xFF, sizeof(g_dq_fs_rfid[i].sec_data));
 655   2        }
 656   1        return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_R
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/24/2021 17:19:10 PAGE 12  

             -FID_MAX_NUM);
 657   1      }
 658          
 659          #endif
 660          
 661          /*
 662          parameter: 
 663            none
 664          return :
 665            none
 666          */
 667          RET_VAL mmi_dq_fs_set_open_mode(sys_open_mode mode)
 668          {
 669   1        if (g_dq_fs_init_set.open_mode == mode)
 670   1          return RET_SUCESS;
 671   1      
 672   1        g_dq_fs_init_set.open_mode = mode;
 673   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 674   1      }
 675          /*
 676          parameter: 
 677            none
 678          return :
 679            none
 680          */
 681          sys_open_mode mmi_dq_fs_get_open_mode(void)
 682          {
 683   1        return g_dq_fs_init_set.open_mode;
 684   1      }
 685          
 686          /*
 687          parameter: 
 688            none
 689          return :
 690            none
 691          */
 692          RET_VAL mmi_dq_fs_set_pro_sound(unsigned char flag)
 693          {
 694   1        if (g_dq_fs_init_set.open_pro_sound == flag)
 695   1          return RET_SUCESS;
 696   1      
 697   1        g_dq_fs_init_set.open_pro_sound = flag;
 698   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 699   1      }
 700          
 701          /*
 702          parameter: 
 703            none
 704          return :
 705            none
 706          */
 707          unsigned char mmi_dq_fs_get_pro_sound_state(void)
 708          {
 709   1        return g_dq_fs_init_set.open_pro_sound;
 710   1      }
 711          
 712          /*
 713          parameter: 
 714            none
 715          return :
 716            none
 717          */
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/24/2021 17:19:10 PAGE 13  

 718          unsigned char mmi_dq_fs_get_init_flag(void)
 719          {
 720   1        return g_dq_fs_init_set.init_flag;
 721   1      }
 722          
 723          /*
 724          parameter: 
 725            none
 726          return :
 727            none
 728          */
 729          RET_VAL mmi_dq_fs_set_init_flag(unsigned char flag)
 730          {
 731   1        g_dq_fs_init_set.init_flag = flag;
 732   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 733   1      }
 734          
 735          /*
 736          parameter: 
 737            none
 738          return :
 739            none
 740          */
 741          RET_VAL mmi_dq_fs_set_factory_flag(unsigned char flag)
 742          {
 743   1        g_dq_fs_init_set.factory_flag = flag;
 744   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
=======
 571          unsigned char mmi_dq_fs_get_rfid_unuse_index(void)
 572          {
 573   1        unsigned char i = 0;
 574   1      
 575   1        for(i=0;i<MMI_DQ_FS_RFID_MAX_NUM;i++)
 576   1        {
 577   2          if(g_dq_fs_rfid[i].index == 0xFF)
 578   2            break;
 579   2        }
 580   1      
 581   1        if(i>=MMI_DQ_FS_RFID_MAX_NUM)
 582   1          return 0xFF;
 583   1        return i;
 584   1      }
 585          
 586          /*
 587          parameter: 
 588            none
 589          return :
 590            none
 591          */
 592          unsigned char mmi_dq_fs_check_rfid(unsigned char *sec_data, fds_use_type type)
 593          {
 594   1        unsigned char i = 0,j = 0;
 595   1        
 596   1        for(i=0;i<MMI_DQ_FS_RFID_MAX_NUM;i++)
 597   1        {
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/25/2021 17:43:02 PAGE 11  

 598   2          for(j=0;j<RFID_SEC_DATA_LEN;j++)
 599   2          {
 600   3            if(g_dq_fs_rfid[i].sec_data[j] != sec_data[j])
 601   3              break;
 602   3          }
 603   2          if(j == RFID_SEC_DATA_LEN)
 604   2            break;
 605   2        }
 606   1        if(i<MMI_DQ_FS_RFID_MAX_NUM&&((g_dq_fs_rfid[i].flag == type)||(type == FDS_USE_TYPE_ALL)))
 607   1        {
 608   2          return i;
 609   2        }
 610   1        else
 611   1        {
 612   2          return 0xFF;
 613   2        }
 614   1      }
 615          
 616          /*
 617          parameter: 
 618            none
 619          return :
 620            none
 621          */
 622          RET_VAL mmi_dq_fs_set_rfid(unsigned char *sec_data, fds_use_type type)
 623          {
 624   1        unsigned char i = 0,j = 0;
 625   1        for(i=0;i<MMI_DQ_FS_RFID_MAX_NUM;i++)
 626   1        {
 627   2          if(g_dq_fs_rfid[i].index == 0xFF)
 628   2            break;
 629   2        }
 630   1        if(i < MMI_DQ_FS_RFID_MAX_NUM)
 631   1        {
 632   2          g_dq_fs_rfid[i].index = i;
 633   2          g_dq_fs_rfid[i].flag = type;
 634   2          for(j=0;j<RFID_SEC_DATA_LEN;j++)
 635   2          {
 636   3            g_dq_fs_rfid[i].sec_data[j] = sec_data[j];
 637   3          }
 638   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid)*MMI_DQ_FS_RF
             -ID_MAX_NUM);
 639   2        }
 640   1        return RET_FAIL;
 641   1      }
 642          
 643          /*
 644          parameter: 
 645            none
 646          return :
 647            none
 648          */
 649          RET_VAL mmi_dq_fs_del_rfid(unsigned char rfid_index)
 650          {
 651   1        if(rfid_index < MMI_DQ_FS_RFID_MAX_NUM && g_dq_fs_rfid[rfid_index].index == rfid_index)
 652   1        {
 653   2          g_dq_fs_rfid[rfid_index].index = 0xFF;
 654   2          g_dq_fs_rfid[rfid_index].flag = FDS_USE_TYPE_INVALID;
 655   2          memset(g_dq_fs_rfid[rfid_index].sec_data,0xFF,sizeof(g_dq_fs_rfid[rfid_index].sec_data));
 656   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid)*MMI_DQ_FS_RF
             -ID_MAX_NUM);
 657   2        }
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/25/2021 17:43:02 PAGE 12  

 658   1        return RET_FAIL;
 659   1      }
 660          
 661          
 662          /*
 663          parameter: 
 664            none
 665          return :
 666            none
 667          */
 668          RET_VAL mmi_dq_fs_clr_rfid(void)
 669          {
 670   1        unsigned char i = 0;
 671   1        
 672   1        for(i=0;i<MMI_DQ_FS_RFID_MAX_NUM;i++)
 673   1        {
 674   2          g_dq_fs_rfid[i].flag = FDS_USE_TYPE_INVALID;
 675   2          g_dq_fs_rfid[i].index = 0xFF;
 676   2          memset(g_dq_fs_rfid[i].sec_data,0xFF,sizeof(g_dq_fs_rfid[i].sec_data));
 677   2        }
 678   1        return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid)*MMI_DQ_FS_RFI
             -D_MAX_NUM);
 679   1      }
 680          
 681          #endif
 682          
 683          /*
 684          parameter: 
 685            none
 686          return :
 687            none
 688          */
 689          RET_VAL mmi_dq_fs_set_open_mode(sys_open_mode mode)
 690          {
 691   1        if(g_dq_fs_init_set.open_mode == mode)
 692   1          return RET_SUCESS;
 693   1      
 694   1        g_dq_fs_init_set.open_mode = mode;
 695   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 696   1        
 697   1      }
 698          /*
 699          parameter: 
 700            none
 701          return :
 702            none
 703          */
 704          sys_open_mode mmi_dq_fs_get_open_mode(void)
 705          {
 706   1        return g_dq_fs_init_set.open_mode;
 707   1      }
 708          
 709          /*
 710          parameter: 
 711            none
 712          return :
 713            none
 714          */
 715          RET_VAL mmi_dq_fs_set_pro_sound(unsigned char flag)
 716          {
 717   1        if(g_dq_fs_init_set.open_pro_sound == flag)
 718   1          return RET_SUCESS;
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/25/2021 17:43:02 PAGE 13  

 719   1        
 720   1        g_dq_fs_init_set.open_pro_sound = flag;
 721   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 722   1      
 723   1      }
 724          
 725          /*
 726          parameter: 
 727            none
 728          return :
 729            none
 730          */
 731          unsigned char mmi_dq_fs_get_pro_sound_state(void)
 732          {
 733   1        return g_dq_fs_init_set.open_pro_sound;
 734   1      }
 735          
 736          /*
 737          parameter: 
 738            none
 739          return :
 740            none
 741          */
 742          unsigned char mmi_dq_fs_get_init_flag(void)
 743          {
 744   1        return g_dq_fs_init_set.init_flag;
>>>>>>> six commit
 745   1      }
 746          
 747          /*
 748          parameter: 
 749            none
 750          return :
 751            none
 752          */
<<<<<<< HEAD
 753          unsigned char mmi_dq_fs_get_factory_flag(void)
 754          {
 755   1        return g_dq_fs_init_set.factory_flag;
 756   1      }
 757          
 758          /*
 759          parameter: 
 760            none
 761          return :
 762            none
 763          */
 764          unsigned char mmi_dq_fs_get_admin_status(void)
 765          {
 766   1        return g_dq_fs_init_set.admin_status;
 767   1      }
 768          
 769          /*
 770          parameter: 
 771            none
 772          return :
 773            none
 774          */
 775          RET_VAL mmi_dq_fs_set_admin_status(unsigned char status)
 776          {
 777   1        g_dq_fs_init_set.admin_status = status;
 778   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 779   1      }
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/24/2021 17:19:10 PAGE 14  

 780          
 781          /*
 782          parameter: 
 783            none
 784          return :
 785            none
 786          */
 787          RET_VAL mmi_dq_fs_set_wifi_setting(unsigned char flag)
 788          {
 789   1        g_dq_fs_init_set.wifi_flag = flag;
 790   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
=======
 753          RET_VAL mmi_dq_fs_set_init_flag(unsigned char flag)
 754          {
 755   1        g_dq_fs_init_set.init_flag = flag;
 756   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 757   1      }
 758          
 759          /*
 760          parameter: 
 761            none
 762          return :
 763            none
 764          */
 765          RET_VAL mmi_dq_fs_set_factory_flag(unsigned char flag)
 766          {
 767   1        g_dq_fs_init_set.factory_flag= flag;
 768   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 769   1      }
 770          
 771          /*
 772          parameter: 
 773            none
 774          return :
 775            none
 776          */
 777          unsigned char mmi_dq_fs_get_factory_flag(void)
 778          {
 779   1        return g_dq_fs_init_set.factory_flag;
 780   1      }
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/25/2021 17:43:02 PAGE 14  

 781          
 782          /*
 783          parameter: 
 784            none
 785          return :
 786            none
 787          */
 788          unsigned char mmi_dq_fs_get_admin_status(void)
 789          {
 790   1        return g_dq_fs_init_set.admin_status;
>>>>>>> six commit
 791   1      }
 792          
 793          /*
 794          parameter: 
 795            none
 796          return :
 797            none
 798          */
<<<<<<< HEAD
 799          unsigned char mmi_dq_fs_get_wifi_setting(void)
 800          {
 801   1        return g_dq_fs_init_set.wifi_flag;
 802   1      }
 803          
 804          #endif
=======
 799          RET_VAL mmi_dq_fs_set_admin_status(unsigned char status)
 800          {
 801   1        g_dq_fs_init_set.admin_status = status;
 802   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 803   1      }
 804          
 805          /*
 806          parameter: 
 807            none
 808          return :
 809            none
 810          */
 811          RET_VAL mmi_dq_fs_set_wifi_setting(unsigned char flag)
 812          {
 813   1        g_dq_fs_init_set.wifi_flag = flag;
 814   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 815   1      }
 816          
 817          /*
 818          parameter: 
 819            none
 820          return :
 821            none
 822          */
 823          unsigned char mmi_dq_fs_get_wifi_setting(void)
 824          {
 825   1        return g_dq_fs_init_set.wifi_flag;
 826   1      }
 827          
 828          
 829          
 830          
 831          
 832          
 833          
 834          
 835          
 836          
 837          
 838          
 839          
 840          
 841          
 842          
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/25/2021 17:43:02 PAGE 15  

 843          
 844          
 845          
 846          
 847          
 848          
 849          
 850          
 851          
 852          
 853          
 854          #endif
>>>>>>> six commit


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3548    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    750      68
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
