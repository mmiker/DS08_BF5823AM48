C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:29:53 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MMI_FS
OBJECT MODULE PLACED IN .\output\mmi_fs.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE mmi_src\mmi_fs.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;.\
                    -Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd_rfi
                    -d;.\mmi_inc) DEBUG PRINT(.\list\mmi_fs.lst) TABS(2) OBJECT(.\output\mmi_fs.obj)

line level    source

   1          #ifndef __MMI_FS_C__
   2          #define __MMI_FS_C__
   3          
   4          #include "mmi_fs.h"
   5          #include "mmi_sys.h"
   6          #include "mcu02_sfr.h"
   7          #include "mcu02_eeprom.h"
   8          #include "string.h"
   9          #include "stdio.h"
  10          #include "dqiot_drv.h"
  11          #include "mmi_fps.h"
  12          
  13          mmi_fs_setting g_dq_fs_init_set;
  14          
  15          #define MMI_DQ_FS_PWD_MAX_NUM 100
  16          mmi_fs_pwd g_dq_fs_pwd[MMI_DQ_FS_PWD_MAX_NUM];
  17          
  18          #if defined(__LOCK_FP_SUPPORT__)
  19          #define MMI_DQ_FS_FP_MAX_NUM 50
  20          mmi_fs_fp g_dq_fs_fp[MMI_DQ_FS_FP_MAX_NUM];
  21          #endif
  22          
  23          #ifdef __LOCK_RFID_CARD_SUPPORT__
  24          #define MMI_DQ_FS_RFID_MAX_NUM 10
  25          mmi_fs_rfid g_dq_fs_rfid[MMI_DQ_FS_RFID_MAX_NUM];
  26          #endif
  27          
  28          static void mmi_dq_fds_read(mid_fds_file_id file, uint8_t *r_data, uint16_t r_size)
  29          {
  30   1        uint16_t i;
  31   1      
  32   1        switch (file)
  33   1        {
  34   2        case MID_FDS_FILE_SET:
  35   2          eeprom_select(0);
  36   2          for (i = 0; i < r_size; i++)
  37   2          {
  38   3            r_data[i] = eeprom_read_byte(0, i); //读第一页
  39   3          }
  40   2          break;
  41   2        case MID_FDS_FILE_PWD:
  42   2          eeprom_select(0);
  43   2          for (i = 0; i < r_size; i++)
  44   2          {
  45   3            r_data[i] = eeprom_read_byte(0, i + 24); //读第一页
  46   3          }
  47   2          break;
  48   2        case MID_FDS_FILE_FP:
  49   2          eeprom_select(1);
  50   2          eeprom_nvr_read_page(r_data, 0, 0, r_size);
  51   2          break;
  52   2        case MID_FDS_FILE_RF:
  53   2          eeprom_select(1);
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:29:53 PAGE 2   

  54   2          eeprom_nvr_read_page(r_data, 1, 0, r_size);
  55   2          break;
  56   2        default:
  57   2          break;
  58   2        }
  59   1      }
  60          
  61          static RET_VAL mmi_dq_fds_write(mid_fds_file_id file, uint8_t *w_data, uint16_t w_size)
  62          {
  63   1        uint16_t i;
  64   1        ErrStatus ret;
  65   1        eeprom_erase_time(9);
  66   1        switch (file)
  67   1        {
  68   2        case MID_FDS_FILE_SET:
  69   2        {
  70   3          uint8_t *w_data2 = (uint8_t *)g_dq_fs_pwd;
  71   3          uint16_t w_size2 = sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_NUM;
  72   3          eeprom_select(0);
  73   3          eeprom_erase_page(0); //擦除1K
  74   3          for (i = 0; i < w_size; i++)
  75   3          {
  76   4            ret = eeprom_write_byte(0, i, w_data[i]); //读第一页
  77   4            if (ret == ERROR)
  78   4            {
  79   5              //printf("mmi_dq_fds_write  error  %d\n",i);
  80   5              return RET_FAIL;
  81   5            }
  82   4          }
  83   3          for (i = 0; i < w_size2; i++)
  84   3          {
  85   4            ret = eeprom_write_byte(0, i + 24, w_data2[i]); //读第一页
  86   4            if (ret == ERROR)
  87   4            {
  88   5              //printf("mmi_dq_fds_write  error  %d\n",i);
  89   5              return RET_FAIL;
  90   5            }
  91   4          }
  92   3        }
  93   2        break;
  94   2        case MID_FDS_FILE_PWD:
  95   2        {
  96   3          uint8_t *w_data2 = (uint8_t *)&g_dq_fs_init_set;
  97   3          uint16_t w_size2 = sizeof(mmi_fs_setting);
  98   3          eeprom_select(0);
  99   3          eeprom_erase_page(0); //擦除1K
 100   3          for (i = 0; i < w_size2; i++)
 101   3          {
 102   4            ret = eeprom_write_byte(0, i, w_data2[i]); //读第一页
 103   4            if (ret == ERROR)
 104   4            {
 105   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 106   5              return RET_FAIL;
 107   5            }
 108   4          }
 109   3          for (i = 0; i < w_size; i++)
 110   3          {
 111   4            ret = eeprom_write_byte(0, i + 24, w_data[i]); //读第一页
 112   4            if (ret == ERROR)
 113   4            {
 114   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 115   5              return RET_FAIL;
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:29:53 PAGE 3   

 116   5            }
 117   4          }
 118   3        }
 119   2        break;
 120   2        case MID_FDS_FILE_FP:
 121   2          eeprom_select(1);
 122   2          eeprom_erase_page(0); //擦除512byte
 123   2          for (i = 0; i < w_size; i++)
 124   2          {
 125   3            ret = eeprom_write_byte(0, i, w_data[i]);
 126   3            if (ret == ERROR)
 127   3            {
 128   4              //printf("mmi_dq_fds_write  error  %d\n",i);
 129   4              return RET_FAIL;
 130   4            }
 131   3          }
 132   2          break;
 133   2        case MID_FDS_FILE_RF:
 134   2          eeprom_select(1);
 135   2          eeprom_erase_page(1); //擦除512byte
 136   2          for (i = 0; i < w_size; i++)
 137   2          {
 138   3            ret = eeprom_write_byte(1, i, w_data[i]);
 139   3            if (ret == ERROR)
 140   3            {
 141   4              //printf("mmi_dq_fds_write  error  %d\n",i);
 142   4              return RET_FAIL;
 143   4            }
 144   3          }
 145   2          break;
 146   2        default:
 147   2          return RET_FAIL;
 148   2        }
 149   1        printf("mmi_dq_fds_write  suc\n");
 150   1        return RET_SUCESS;
 151   1      }
 152          
 153          /*
 154          parameter: 
 155            none
 156          return :
 157            none
 158          */
 159          void mmi_dq_fs_init(void)
 160          {
 161   1        mmi_dq_fds_read(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 162   1        if (FDS_INIT_LOCK_SUC == g_dq_fs_init_set.init_flag || FDS_INIT_APP_SUC == g_dq_fs_init_set.init_flag)
 163   1        {
 164   2          unsigned char i = 0;
 165   2          mmi_dq_fds_read(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_N
             -UM);
 166   2          for (; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 167   2          {
 168   3            if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
 169   3              break;
 170   3          }
 171   2          if (i < MMI_DQ_FS_PWD_MAX_NUM)
 172   2          {
 173   3            mmi_dq_fds_read(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM)
             -;
 174   3            mmi_dq_fds_read(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MA
             -X_NUM);
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:29:53 PAGE 4   

 175   3            return;
 176   3          }
 177   2        }
 178   1      
 179   1        {
 180   2          //printf("mmi_dq_fs_init init error");
 181   2          memset(g_dq_fs_pwd, 0xFF, sizeof(g_dq_fs_pwd));
 182   2          mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_
             -NUM);
 183   2      
 184   2          memset(g_dq_fs_fp, 0xFF, sizeof(g_dq_fs_fp));
 185   2          mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM)
             -;
 186   2      
 187   2          memset(g_dq_fs_rfid, 0xFF, sizeof(g_dq_fs_rfid));
 188   2          mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MA
             -X_NUM);
 189   2      
 190   2          g_dq_fs_init_set.init_flag = FDS_INIT_INVALID;
 191   2          g_dq_fs_init_set.open_pro_sound = 1;
 192   2          g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 193   2          g_dq_fs_init_set.admin_status = 0;
 194   2          g_dq_fs_init_set.factory_flag = 0;
 195   2          mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 196   2      
 197   2          if (FP_Status == 1) /* 判断指纹握手是否成功 */
 198   2            mmi_dq_fp_empty();
 199   2        }
 200   1      }
 201          
 202          /*
 203          parameter: 
 204            none
 205          return :
 206            none
 207          */
 208          void mmi_dq_fs_pwd_string_to_byte(unsigned char *input_pwd, unsigned char pwd_len, unsigned char *output_p
             -wd)
 209          {
 210   1        unsigned char i = 0;
 211   1        unsigned char bit_l = 0;
 212   1        unsigned char bit_h = 0;
 213   1      
 214   1        for (i = 0; i < pwd_len; i++)
 215   1        {
 216   2          bit_l = *(input_pwd + i) & 0x0F;
 217   2          i++;
 218   2          if (i < pwd_len)
 219   2            bit_h = *(input_pwd + i) & 0x0F;
 220   2          else
 221   2            bit_h = 0xF;
 222   2          *output_pwd++ = bit_l << 4 | bit_h;
 223   2        }
 224   1        return;
 225   1      }
 226          /*
 227          parameter: 
 228            none
 229          return :
 230            none
 231          */
 232          void mmi_dq_fs_pwd_byte_to_string(unsigned char *input_pwd, unsigned char *output_pwd)
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:29:53 PAGE 5   

 233          {
 234   1        unsigned char i = 0;
 235   1        unsigned char pwd = 0;
 236   1        for (i = 0; i < 4; i++)
 237   1        {
 238   2          pwd = *(input_pwd + i);
 239   2          if (pwd == 0xFF)
 240   2            break;
 241   2          else
 242   2            *output_pwd++ = (pwd & 0xF0) >> 4;
 243   2          if ((pwd & 0x0F) == 0x0F)
 244   2            break;
 245   2          else
 246   2          {
 247   3            *output_pwd++ = pwd & 0x0F;
 248   3          }
 249   2        }
 250   1        return;
 251   1      }
 252          
 253          /*
 254          parameter: 
 255            none
 256          return :
 257            none
 258          */
 259          unsigned char mmi_dq_fs_get_pwd_unuse_index(void)
 260          {
 261   1        unsigned char i = 0;
 262   1      
 263   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 264   1        {
 265   2          if (g_dq_fs_pwd[i].flag == 0xFF)
 266   2            break;
 267   2        }
 268   1      
 269   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 270   1          return i;
 271   1        else
 272   1          return 0xFF;
 273   1      }
 274          
 275          /*
 276          parameter: 
 277            none
 278          return :
 279            none
 280          */
 281          unsigned char mmi_dq_fs_check_input_pwd(unsigned char *input_pwd, unsigned char len, fds_use_type type)
 282          {
 283   1        unsigned char i = 0;
 284   1        unsigned char k = 0;
 285   1        unsigned char password[4];
 286   1        unsigned char ret_val = 0xFF;
 287   1      
 288   1        memset(password, 0xFF, sizeof(password));
 289   1        mmi_dq_fs_pwd_string_to_byte(input_pwd, len, password);
 290   1      
 291   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 292   1        {
 293   2          if (g_dq_fs_pwd[i].flag != 0xFF)
 294   2          {
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:29:53 PAGE 6   

 295   3            for (k = 0; k < 4; k++)
 296   3            {
 297   4              if (password[k] != g_dq_fs_pwd[i].key_pwd[k])
 298   4                break;
 299   4            }
 300   3            if (k == 4)
 301   3            {
 302   4              break;
 303   4            }
 304   3          }
 305   2        }
 306   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 307   1        {
 308   2          if ((g_dq_fs_pwd[i].flag == type) || (type == FDS_USE_TYPE_ALL))
 309   2            ret_val = i;
 310   2          else
 311   2            ret_val = 0xFF;
 312   2        }
 313   1        else
 314   1          ret_val = 0xFF;
 315   1      
 316   1        return ret_val;
 317   1      }
 318          
 319          /*
 320          parameter: 
 321            none
 322          return :
 323            none
 324          */
 325          RET_VAL mmi_dq_fs_set_pwd(unsigned char *pwd, unsigned char pwd_size, fds_use_type type)
 326          {
 327   1        unsigned char i = 0xFF;
 328   1        unsigned char password[4];
 329   1      
 330   1        if (type == FDS_USE_TYPE_ADMIN)
 331   1        {
 332   2          for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 333   2          {
 334   3            if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
 335   3              break;
 336   3          }
 337   2        }
 338   1        if (i >= MMI_DQ_FS_PWD_MAX_NUM)
 339   1        {
 340   2          for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 341   2          {
 342   3            if (g_dq_fs_pwd[i].flag == 0xFF)
 343   3              break;
 344   3          }
 345   2        }
 346   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 347   1        {
 348   2          memset(password, 0xFF, sizeof(password));
 349   2          //g_dq_fs_pwd[i].index = i;
 350   2          mmi_dq_fs_pwd_string_to_byte(pwd, pwd_size, password);
 351   2          memcpy((char *)g_dq_fs_pwd[i].key_pwd, (const char *)password, 4);
 352   2          g_dq_fs_pwd[i].flag = type;
 353   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_P
             -WD_MAX_NUM);
 354   2        }
 355   1        return RET_FAIL;
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:29:53 PAGE 7   

 356   1      }
 357          
 358          /*
 359          parameter: 
 360            none
 361          return :
 362            none
 363          */
 364          RET_VAL mmi_dq_fs_del_pwd(unsigned char index, fds_use_type type)
 365          {
 366   1        if (index < MMI_DQ_FS_PWD_MAX_NUM && g_dq_fs_pwd[index].flag == type)
 367   1        {
 368   2          g_dq_fs_pwd[index].flag = FDS_USE_TYPE_INVALID;
 369   2          //g_dq_fs_pwd[index].index = 0xFF;
 370   2          memset(g_dq_fs_pwd[index].key_pwd, 0xFF, sizeof(g_dq_fs_pwd[index].key_pwd));
 371   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_P
             -WD_MAX_NUM);
 372   2        }
 373   1        return RET_FAIL;
 374   1      }
 375          
 376          /*
 377          parameter: 
 378            none
 379          return :
 380            none
 381          */
 382          RET_VAL mmi_dq_fs_clr_pwd(void)
 383          {
 384   1        unsigned char i = 0;
 385   1      
 386   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 387   1        {
 388   2          if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_USER)
 389   2          {
 390   3            g_dq_fs_pwd[i].flag = FDS_USE_TYPE_INVALID;
 391   3            //g_dq_fs_pwd[i].index = 0xFF;
 392   3            memset(g_dq_fs_pwd[i].key_pwd, 0xFF, sizeof(g_dq_fs_pwd[i].key_pwd));
 393   3          }
 394   2        }
 395   1      
 396   1        return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PW
             -D_MAX_NUM);
 397   1      }
 398          
 399          #if defined(__LOCK_FP_SUPPORT__)
 400          /*
 401          parameter: 
 402            none
 403          return :
 404            none
 405          */
 406          unsigned char mmi_dq_fs_get_fp_unuse_index(void)
 407          {
 408   1        unsigned char i = 2;
 409   1      
 410   1        for (; i < MMI_DQ_FS_FP_MAX_NUM; i++)
 411   1        {
 412   2          if (g_dq_fs_fp[i].fp_index == 0xFF)
 413   2            break;
 414   2        }
 415   1        if (i >= MMI_DQ_FS_FP_MAX_NUM)
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:29:53 PAGE 8   

 416   1          return 0xFF;
 417   1        return i;
 418   1      }
 419          
 420          /*
 421          parameter: 
 422            none
 423          return :
 424            none
 425          */
 426          RET_VAL mmi_dq_fs_check_fp(unsigned char fp_index, fds_use_type type)
 427          {
*** WARNING C235 IN LINE 427 OF mmi_src\mmi_fs.c: parameter 1: different types
 428   1        // dqiot_drv_log_output_data('!',fp_index);
 429   1        // dqiot_drv_log_output_data('!',type);
 430   1        // dqiot_drv_log_output_data('!',MMI_DQ_FS_FP_MAX_NUM);
 431   1        // dqiot_drv_log_output_data('!',g_dq_fs_fp[fp_index].fp_index); //0xff
 432   1        // dqiot_drv_log_output_data('!',g_dq_fs_fp[fp_index].flag); //0xff
 433   1        // dqiot_drv_log_output_data('!',FDS_USE_TYPE_ALL);
 434   1      
 435   1        if ((fp_index < MMI_DQ_FS_FP_MAX_NUM) && (g_dq_fs_fp[fp_index].fp_index == fp_index) && ((g_dq_fs_fp[fp_i
             -ndex].flag == type) || (type == FDS_USE_TYPE_ALL)))
 436   1          return RET_SUCESS;
 437   1        else
 438   1          return RET_FAIL;
 439   1      }
 440          
 441          /*
 442          parameter: 
 443            none
 444          return :
 445            none
 446          */
 447          RET_VAL mmi_dq_fs_set_fp(unsigned char fs_index, fds_use_type type)
 448          {
 449   1        g_dq_fs_fp[fs_index].fp_index = fs_index;
 450   1        g_dq_fs_fp[fs_index].flag = type;
 451   1        return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MA
             -X_NUM);
 452   1      }
 453          
 454          /*
 455          parameter: 
 456            none
 457          return :
 458            none
 459          */
 460          RET_VAL mmi_dq_fs_del_fp(unsigned char fp_index, fds_use_type type)
 461          {
 462   1        if (mmi_dq_fs_check_fp(fp_index, type) == RET_SUCESS)
 463   1        {
 464   2          g_dq_fs_fp[fp_index].flag = FDS_USE_TYPE_INVALID;
 465   2          g_dq_fs_fp[fp_index].fp_index = 0xFF;
 466   2          return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_M
             -AX_NUM);
 467   2        }
 468   1        return RET_FAIL;
 469   1      }
 470          
 471          /*
 472          parameter: 
 473            none
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:29:53 PAGE 9   

 474          return :
 475            none
 476          */
 477          RET_VAL mmi_dq_fs_clr_fp(void)
 478          {
 479   1        unsigned char i = 0;
 480   1        unsigned short fp_ret = 0;
 481   1      
 482   1        for (i = 0; i < MMI_DQ_FS_FP_MAX_NUM; i++)
 483   1        {
 484   2          if (g_dq_fs_fp[i].flag != FDS_USE_TYPE_ADMIN)
 485   2          {
 486   3            if (g_dq_fs_fp[i].fp_index != 0xFF)
 487   3            {
 488   4              //fp_ret = mmi_dq_fp_delete(g_dq_fs_fp[i].fp_index);
 489   4              if (fp_ret == 0)
 490   4              {
 491   5                g_dq_fs_fp[i].flag = FDS_USE_TYPE_INVALID;
 492   5                g_dq_fs_fp[i].fp_index = 0xFF;
 493   5              }
 494   4            }
 495   3          }
 496   2        }
 497   1        return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MA
             -X_NUM);
 498   1      }
 499          
 500          #endif
 501          
 502          #ifdef __LOCK_RFID_CARD_SUPPORT__
 503          
 504          /*
 505          parameter: 
 506            none
 507          return :
 508            none
 509          */
 510          unsigned short mmi_dq_fs_get_rfid_unuse_index(void)
 511          {
 512   1        unsigned char i = 0;
 513   1      
 514   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 515   1        {
 516   2          if (g_dq_fs_rfid[i].index == 0xFF)
 517   2            break;
 518   2        }
 519   1      
 520   1        if (i >= MMI_DQ_FS_RFID_MAX_NUM)
 521   1          return 0xFF;
 522   1        return i;
 523   1      }
 524          
 525          /*
 526          parameter: 
 527            none
 528          return :
 529            none
 530          */
 531          unsigned char mmi_dq_fs_check_rfid(unsigned char *sec_data, fds_use_type type)
 532          {
 533   1        unsigned char i = 0, j = 0;
 534   1      
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:29:53 PAGE 10  

 535   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 536   1        {
 537   2          for (j = 0; j < RFID_SEC_DATA_LEN; j++)
 538   2          {
 539   3            if (g_dq_fs_rfid[i].sec_data[j] != sec_data[j])
 540   3              break;
 541   3          }
 542   2          if (j == RFID_SEC_DATA_LEN)
 543   2            break;
 544   2        }
 545   1        if (i < MMI_DQ_FS_RFID_MAX_NUM && ((g_dq_fs_rfid[i].flag == type) || (type == FDS_USE_TYPE_ALL)))
 546   1        {
 547   2          return i;
 548   2        }
 549   1        else
 550   1        {
 551   2          return 0xFF;
 552   2        }
 553   1      }
 554          
 555          /*
 556          parameter: 
 557            none
 558          return :
 559            none
 560          */
 561          RET_VAL mmi_dq_fs_set_rfid(unsigned char *sec_data, fds_use_type type)
 562          {
 563   1        unsigned char i = 0, j = 0;
 564   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 565   1        {
 566   2          if (g_dq_fs_rfid[i].index == 0xFF)
 567   2            break;
 568   2        }
 569   1        if (i < MMI_DQ_FS_RFID_MAX_NUM)
 570   1        {
 571   2          g_dq_fs_rfid[i].index = i;
 572   2          g_dq_fs_rfid[i].flag = type;
 573   2          for (j = 0; j < RFID_SEC_DATA_LEN; j++)
 574   2          {
 575   3            g_dq_fs_rfid[i].sec_data[j] = sec_data[j];
 576   3          }
 577   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_
             -RFID_MAX_NUM);
 578   2        }
 579   1        return RET_FAIL;
 580   1      }
 581          
 582          /*
 583          parameter: 
 584            none
 585          return :
 586            none
 587          */
 588          RET_VAL mmi_dq_fs_del_rfid(unsigned char rfid_index)
 589          {
 590   1        if (rfid_index < MMI_DQ_FS_RFID_MAX_NUM && g_dq_fs_rfid[rfid_index].index == rfid_index)
 591   1        {
 592   2          g_dq_fs_rfid[rfid_index].index = 0xFF;
 593   2          g_dq_fs_rfid[rfid_index].flag = FDS_USE_TYPE_INVALID;
 594   2          memset(g_dq_fs_rfid[rfid_index].sec_data, 0xFF, sizeof(g_dq_fs_rfid[rfid_index].sec_data));
 595   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:29:53 PAGE 11  

             -RFID_MAX_NUM);
 596   2        }
 597   1        return RET_FAIL;
 598   1      }
 599          
 600          /*
 601          parameter: 
 602            none
 603          return :
 604            none
 605          */
 606          RET_VAL mmi_dq_fs_clr_rfid(void)
 607          {
 608   1        unsigned char i = 0;
 609   1      
 610   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 611   1        {
 612   2          g_dq_fs_rfid[i].flag = FDS_USE_TYPE_INVALID;
 613   2          g_dq_fs_rfid[i].index = 0xFF;
 614   2          memset(g_dq_fs_rfid[i].sec_data, 0xFF, sizeof(g_dq_fs_rfid[i].sec_data));
 615   2        }
 616   1        return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_R
             -FID_MAX_NUM);
 617   1      }
 618          
 619          #endif
 620          
 621          /*
 622          parameter: 
 623            none
 624          return :
 625            none
 626          */
 627          RET_VAL mmi_dq_fs_set_open_mode(sys_open_mode mode)
 628          {
 629   1        if (g_dq_fs_init_set.open_mode == mode)
 630   1          return RET_SUCESS;
 631   1      
 632   1        g_dq_fs_init_set.open_mode = mode;
 633   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 634   1      }
 635          /*
 636          parameter: 
 637            none
 638          return :
 639            none
 640          */
 641          sys_open_mode mmi_dq_fs_get_open_mode(void)
 642          {
 643   1        return g_dq_fs_init_set.open_mode;
 644   1      }
 645          
 646          /*
 647          parameter: 
 648            none
 649          return :
 650            none
 651          */
 652          RET_VAL mmi_dq_fs_set_pro_sound(unsigned char flag)
 653          {
 654   1        if (g_dq_fs_init_set.open_pro_sound == flag)
 655   1          return RET_SUCESS;
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:29:53 PAGE 12  

 656   1      
 657   1        g_dq_fs_init_set.open_pro_sound = flag;
 658   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 659   1      }
 660          
 661          /*
 662          parameter: 
 663            none
 664          return :
 665            none
 666          */
 667          unsigned char mmi_dq_fs_get_pro_sound_state(void)
 668          {
 669   1        return g_dq_fs_init_set.open_pro_sound;
 670   1      }
 671          
 672          /*
 673          parameter: 
 674            none
 675          return :
 676            none
 677          */
 678          unsigned char mmi_dq_fs_get_init_flag(void)
 679          {
 680   1        return g_dq_fs_init_set.init_flag;
 681   1      }
 682          
 683          /*
 684          parameter: 
 685            none
 686          return :
 687            none
 688          */
 689          RET_VAL mmi_dq_fs_set_init_flag(unsigned char flag)
 690          {
 691   1        g_dq_fs_init_set.init_flag = flag;
 692   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 693   1      }
 694          
 695          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3258    ----
   CONSTANT SIZE    =     23    ----
   XDATA SIZE       =    749      67
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
