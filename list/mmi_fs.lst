C51 COMPILER V9.59.0.0   MMI_FS                                                            04/07/2021 10:03:36 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MMI_FS
OBJECT MODULE PLACED IN .\output\mmi_fs.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE mmi_src\mmi_fs.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;.\
                    -Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd_rfi
                    -d;.\mmi_inc) DEBUG PRINT(.\list\mmi_fs.lst) TABS(2) OBJECT(.\output\mmi_fs.obj)

line level    source

   1          #ifndef __MMI_FS_C__
   2          #define __MMI_FS_C__
   3          
   4          #include "mmi_fs.h"
   5          #include "mmi_sys.h"
   6          #include "mcu02_sfr.h"
   7          #include "mcu02_eeprom.h"
   8          #include "string.h"
   9          // #include <stdio.h>
  10          
  11          #include "mmi_fps.h"
  12          #include "mmi_ms.h"
  13          #include "dq_otp.h"
  14          
  15          unsigned char get_index = 0;
  16          
  17          mmi_fs_setting data g_dq_fs_init_set;
  18          
  19          #define MMI_DQ_FS_PWD_MAX_NUM 100
  20          mmi_fs_pwd g_dq_fs_pwd[MMI_DQ_FS_PWD_MAX_NUM];
  21          
  22          #if defined(__LOCK_FP_SUPPORT__)
  23          #define MMI_DQ_FS_FP_MAX_NUM 30
  24          mmi_fs_fp g_dq_fs_fp[MMI_DQ_FS_FP_MAX_NUM];
  25          #endif
  26          
  27          #ifdef __LOCK_RFID_CARD_SUPPORT__
  28          #define MMI_DQ_FS_RFID_MAX_NUM 10
  29          mmi_fs_rfid g_dq_fs_rfid[MMI_DQ_FS_RFID_MAX_NUM];
  30          #endif
  31          
  32          #define FP_ADMIN_NUM 2
  33          #define FP_110_NUM 3
  34          
  35          #define PWD_ADMIN_NUM 1
  36          #define PWD_110_NUM 1
  37          
  38          static void mmi_dq_fds_read(mid_fds_file_id file, uint8_t *r_data, uint16_t r_size)
  39          {
  40   1        uint16_t i;
  41   1      
  42   1        switch (file)
  43   1        {
  44   2          case MID_FDS_FILE_SET:
  45   2            eeprom_select(0);
  46   2            for(i = 0; i < r_size; i++)
  47   2            {
  48   3              r_data[i] = eeprom_read_byte(0,i);//读第一页
  49   3            }
  50   2            break;
  51   2          case MID_FDS_FILE_PWD:
  52   2            eeprom_select(0);
  53   2            for(i = 0; i < r_size; i++)
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/07/2021 10:03:36 PAGE 2   

  54   2            {
  55   3              r_data[i] = eeprom_read_byte(0,i+24);//读第一页
  56   3            }
  57   2            break;
  58   2      #ifdef __LOCK_FP_SUPPORT__
  59   2        case MID_FDS_FILE_FP:
  60   2          eeprom_select(1);
  61   2          eeprom_nvr_read_page(r_data, 0, 0, r_size);
  62   2          break;
  63   2      #endif
  64   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
  65   2        case MID_FDS_FILE_RF:
  66   2          eeprom_select(1);
  67   2          eeprom_nvr_read_page(r_data, 1, 0, r_size);
  68   2          break;
  69   2      #endif
  70   2        default:
  71   2          break;
  72   2        }
  73   1      }
  74          
  75          static RET_VAL mmi_dq_fds_write(mid_fds_file_id file, uint8_t *w_data, uint16_t w_size)
  76          {
  77   1        uint16_t i;
  78   1        ErrStatus ret;
  79   1        eeprom_erase_time(9);
  80   1        switch (file)
  81   1        {
  82   2          case MID_FDS_FILE_SET:
  83   2            {
  84   3              uint8_t* w_data2 = (uint8_t *)g_dq_fs_pwd;
  85   3              uint16_t w_size2 = sizeof(mmi_fs_pwd)*MMI_DQ_FS_PWD_MAX_NUM;
  86   3              eeprom_select(0);
  87   3              eeprom_erase_page(0);//擦除1K
  88   3              for(i = 0; i < w_size; i++)
  89   3              {
  90   4                ret = eeprom_write_byte(0,i,w_data[i]);//读第一页
  91   4                if(ret==ERROR) 
  92   4                {
  93   5                  //printf("mmi_dq_fds_write  error  %d\n",i);
  94   5                  return RET_FAIL;
  95   5                }
  96   4              }
  97   3              for(i = 0; i < w_size2; i++)
  98   3              {
  99   4                ret = eeprom_write_byte(0,i+24,w_data2[i]);//读第一页
 100   4                if(ret==ERROR) 
 101   4                {
 102   5                  //printf("mmi_dq_fds_write  error  %d\n",i);
 103   5                  return RET_FAIL;
 104   5                }
 105   4              }
 106   3            }
 107   2            break;
 108   2          case MID_FDS_FILE_PWD:
 109   2            {
 110   3              uint8_t* w_data2 = (uint8_t *)&g_dq_fs_init_set;
 111   3              uint16_t w_size2 = sizeof(mmi_fs_setting);
 112   3              eeprom_select(0);
 113   3              eeprom_erase_page(0);//擦除1K
 114   3              for(i = 0; i < w_size2; i++)
 115   3              {
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/07/2021 10:03:36 PAGE 3   

 116   4                ret = eeprom_write_byte(0,i,w_data2[i]);//读第一页
 117   4                if(ret==ERROR) 
 118   4                {
 119   5                  //printf("mmi_dq_fds_write  error  %d\n",i);
 120   5                  return RET_FAIL;
 121   5                }
 122   4              }
 123   3              for(i = 0; i < w_size; i++)
 124   3              {
 125   4                ret = eeprom_write_byte(0,i+24,w_data[i]);//读第一页
 126   4                if(ret==ERROR) 
 127   4                {
 128   5                  //printf("mmi_dq_fds_write  error  %d\n",i);
 129   5                  return RET_FAIL;
 130   5                }
 131   4              }
 132   3            }
 133   2            break;
 134   2      #ifdef __LOCK_FP_SUPPORT__
 135   2          case MID_FDS_FILE_FP:
 136   2            eeprom_select(1);
 137   2            eeprom_erase_page(0);//擦除512byte
 138   2            for(i = 0; i < w_size; i++)
 139   2            {
 140   3              ret = eeprom_write_byte(0,i,w_data[i]);
 141   3              if(ret==ERROR) 
 142   3              {
 143   4                //printf("mmi_dq_fds_write  error  %d\n",i);
 144   4                return RET_FAIL;
 145   4              }
 146   3            }
 147   2            break;
 148   2      #endif
 149   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 150   2          case MID_FDS_FILE_RF:
 151   2            eeprom_select(1);
 152   2            eeprom_erase_page(1);//擦除512byte
 153   2            for(i = 0; i < w_size; i++)
 154   2            {
 155   3              ret = eeprom_write_byte(1,i,w_data[i]);
 156   3              if(ret==ERROR) 
 157   3              {
 158   4                //printf("mmi_dq_fds_write  error  %d\n",i);
 159   4                return RET_FAIL;
 160   4              }
 161   3            }
 162   2            break;
 163   2      #endif
 164   2        default:
 165   2          return RET_FAIL;
 166   2        }
 167   1        //printf("mmi_dq_fds_write  suc\n");
 168   1        return RET_SUCESS;
 169   1      }
 170          
 171          /*
 172          parameter: 
 173            none
 174          return :
 175            none
 176          */
 177          void mmi_dq_fs_init(void)
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/07/2021 10:03:36 PAGE 4   

 178          {
 179   1        mmi_dq_fds_read(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 180   1        if (FDS_INIT_LOCK_SUC == g_dq_fs_init_set.init_flag || FDS_INIT_APP_SUC == g_dq_fs_init_set.init_flag)
 181   1        {
 182   2          unsigned char i = 0;
 183   2          mmi_dq_fds_read(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_N
             -UM);
 184   2      #ifdef __LOCK_FP_SUPPORT__
 185   2          mmi_dq_fds_read(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM);
 186   2      #endif
 187   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 188   2          mmi_dq_fds_read(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MAX
             -_NUM);
 189   2      #endif
 190   2          if (g_dq_fs_init_set.admin_status > 0)
 191   2          {
 192   3            for (; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 193   3            {
 194   4              if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
 195   4                break;
 196   4            }
 197   3            if (i >= MMI_DQ_FS_PWD_MAX_NUM)
 198   3            {
 199   4              g_dq_fs_init_set.admin_status = 0;
 200   4              mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 201   4            }
 202   3          }
 203   2        }
 204   1        else
 205   1        {
 206   2          //printf("mmi_dq_fs_init init error");
 207   2          memset(g_dq_fs_pwd, 0xFF, sizeof(g_dq_fs_pwd));
 208   2          mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_
             -NUM);
 209   2      
 210   2      #ifdef __LOCK_FP_SUPPORT__
 211   2          memset(g_dq_fs_fp, 0xFF, sizeof(g_dq_fs_fp));
 212   2          mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM)
             -;
 213   2      
 214   2          mmi_dq_fp_empty();
 215   2      #endif
 216   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 217   2          memset(g_dq_fs_rfid, 0xFF, sizeof(g_dq_fs_rfid));
 218   2          mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MA
             -X_NUM);
 219   2      #endif
 220   2          g_dq_fs_init_set.init_flag = FDS_INIT_LOCK_SUC;
 221   2          g_dq_fs_init_set.open_pro_sound = 1;
 222   2          g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 223   2          g_dq_fs_init_set.admin_status = 0;
 224   2          g_dq_fs_init_set.factory_flag = 0;
 225   2          g_dq_fs_init_set.wifi_flag = 0;
 226   2          mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 227   2        }
 228   1      }
 229          
 230          /**
 231            * @brief  手动初始化
 232            * @param  none
 233            * @return none
 234            * @note   none
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/07/2021 10:03:36 PAGE 5   

 235            * @see    none
 236            */
 237          RET_VAL mmi_dq_fs_clr_set(void)
 238          {
 239   1        g_dq_fs_init_set.open_pro_sound = 1;
 240   1        g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 241   1      
 242   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 243   1      }
 244          
 245          /**
 246            * @brief  复位初始化
 247            * @param  none
 248            * @return none
 249            * @note   none
 250            * @see    none
 251            */
 252          RET_VAL mmi_dq_fs_reset(void)
 253          {
 254   1        memset(g_dq_fs_pwd, 0xFF, sizeof(g_dq_fs_pwd));
 255   1        mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_N
             -UM);
 256   1      #ifdef __LOCK_FP_SUPPORT__
 257   1        memset(g_dq_fs_fp, 0xFF, sizeof(g_dq_fs_fp));
 258   1        mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM);
 259   1      
 260   1        mmi_dq_fp_empty();
 261   1      #endif
 262   1      #ifdef __LOCK_RFID_CARD_SUPPORT__
 263   1        memset(g_dq_fs_rfid, 0xFF, sizeof(g_dq_fs_rfid));
 264   1        mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MAX
             -_NUM);
 265   1      #endif
 266   1        g_dq_fs_init_set.init_flag = FDS_INIT_LOCK_SUC;
 267   1        g_dq_fs_init_set.open_pro_sound = 1;
 268   1        g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 269   1        g_dq_fs_init_set.admin_status = 0;
 270   1        g_dq_fs_init_set.wifi_flag = 0;
 271   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 272   1      }
 273          
 274          /*
 275          parameter: 
 276            none
 277          return :
 278            none
 279          */
 280          void mmi_dq_fs_pwd_string_to_byte(unsigned char *input_pwd, unsigned char pwd_len, unsigned char *output_p
             -wd)
 281          {
 282   1        unsigned char i = 0;
 283   1        unsigned char bit_l = 0;
 284   1        unsigned char bit_h = 0;
 285   1      
 286   1        for (i = 0; i < pwd_len; i++)
 287   1        {
 288   2          bit_l = *(input_pwd + i) & 0x0F;
 289   2          i++;
 290   2          if (i < pwd_len)
 291   2            bit_h = *(input_pwd + i) & 0x0F;
 292   2          else
 293   2            bit_h = 0xF;
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/07/2021 10:03:36 PAGE 6   

 294   2          *output_pwd++ = bit_l << 4 | bit_h;
 295   2        }
 296   1        return;
 297   1      }
 298          /*
 299          parameter: 
 300            none
 301          return :
 302            none
 303          */
 304          unsigned char mmi_dq_fs_pwd_byte_to_string(unsigned char *input_pwd,unsigned char *output_pwd)
 305          {
 306   1        unsigned char i = 0;
 307   1        unsigned char pwd = 0;
 308   1        unsigned char len = 0;
 309   1        for(i=0;i<4;i++)
 310   1        {
 311   2          pwd = *(input_pwd + i);
 312   2          if (pwd == 0xFF)
 313   2            break;
 314   2          else 
 315   2          {
 316   3            *output_pwd++ = (pwd&0xF0)>>4;
 317   3            len++;
 318   3          }
 319   2          if((pwd&0x0F) == 0x0F)
 320   2            break;
 321   2          else
 322   2          {
 323   3            *output_pwd++ = pwd&0x0F;
 324   3            len++;
 325   3          }
 326   2        }
 327   1        return len;
 328   1      }
 329          
 330          /*
 331          parameter: 
 332            none
 333          return :
 334            none
 335          */
 336          unsigned char mmi_dq_fs_get_pwd_unuse_index(void)
 337          {
 338   1        unsigned char i = PWD_ADMIN_NUM;
 339   1      #ifdef __LOCK_110_SUPPORT__
 340   1        i+=PWD_110_NUM;
 341   1      #endif
 342   1        for(;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 343   1        {
 344   2          if (g_dq_fs_pwd[i].flag == 0xFF)
 345   2            break;
 346   2        }
 347   1      
 348   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 349   1          return i;
 350   1        else
 351   1          return 0xFF;
 352   1      }
 353          
 354          /*
 355          parameter: 
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/07/2021 10:03:36 PAGE 7   

 356            none
 357          return :
 358            none
 359          */
 360          unsigned char mmi_dq_fs_check_input_pwd(unsigned char *input_pwd, unsigned char len, fds_use_type type)
 361          {
 362   1        unsigned char i = 0;
 363   1        unsigned char k = 0;
 364   1        unsigned char password[4];
 365   1        unsigned char ret_val = 0xFF;
 366   1      
 367   1        memset(password, 0xFF, sizeof(password));
 368   1        mmi_dq_fs_pwd_string_to_byte(input_pwd, len, password);
 369   1      
 370   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 371   1        {
 372   2          if (g_dq_fs_pwd[i].flag != 0xFF)
 373   2          {
 374   3            for (k = 0; k < 4; k++)
 375   3            {
 376   4              if (password[k] != g_dq_fs_pwd[i].key_pwd[k])
 377   4                break;
 378   4            }
 379   3            if (k == 4)
 380   3            {
 381   4              break;
 382   4            }
 383   3          }
 384   2        }
 385   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 386   1        {
 387   2          if ((g_dq_fs_pwd[i].flag == type) || (type == FDS_USE_TYPE_ALL))
 388   2            ret_val = i;
 389   2          else
 390   2            ret_val = 0xFF;
 391   2        }
 392   1        else
 393   1          ret_val = 0xFF;
 394   1      
 395   1        return ret_val;
 396   1      }
 397          
 398          /*
 399          parameter: 
 400            none
 401          return :
 402            none
 403          */
 404          unsigned char mmi_dq_fs_check_input_pwd_for_open(unsigned char *input_pwd,unsigned char len)
 405          {
 406   1        unsigned char i = 0,n = 0;
 407   1        unsigned char k,j;
 408   1        unsigned char password[8];
 409   1        unsigned char passlen = 0;
 410   1        unsigned char ret_val = 0xFF;
 411   1        
 412   1        for(i=0;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 413   1        {
 414   2          if(g_dq_fs_pwd[i].flag == FDS_USE_TYPE_INVALID)
 415   2            continue;
 416   2          memset(password,0xFF,sizeof(password));
 417   2          passlen = mmi_dq_fs_pwd_byte_to_string(g_dq_fs_pwd[i].key_pwd,password);
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/07/2021 10:03:36 PAGE 8   

 418   2          for(k = 0;k+passlen <= len; k++)
 419   2          {
 420   3            for(j=0;j<passlen;j++)
 421   3            {
 422   4              if(password[j] != input_pwd[k+j])
 423   4                break;
 424   4            }
 425   3            if(j==passlen)
 426   3              break;
 427   3          }
 428   2          if(j == passlen)
 429   2            break;
 430   2        }
 431   1        if(i<MMI_DQ_FS_PWD_MAX_NUM)
 432   1        {
 433   2          //printf("check input return i: %d",(unsigned int)i);
 434   2          get_index = i;
 435   2          return i;
 436   2        }
 437   1        else
 438   1        {
 439   2          unsigned char adminword[8];
 440   2          unsigned char checkCode_out[8];
 441   2          unsigned char pass = 0;
 442   2          memset(adminword,0xFF,sizeof(adminword));
 443   2          passlen = mmi_dq_fs_pwd_byte_to_string(g_dq_fs_pwd[0].key_pwd,adminword);
 444   2          for(i=0;i<8;i++)
 445   2          {
 446   3            if(adminword[i]==0xFF)
 447   3              adminword[i] = 0;
 448   3            else
 449   3              adminword[i] += '0';
 450   3      
 451   3            if(input_pwd[i]==0xFF)
 452   3              password[i] = 0;
 453   3            else
 454   3              password[i] = input_pwd[i] + '0';
 455   3          }
 456   2          pass = dq_check_otp((char *)password,(char *)adminword,g_dq_fs_init_set.check_data,checkCode_out);
 457   2          if(pass > 0)
 458   2          {
 459   3            memcpy(g_dq_fs_init_set.check_data,checkCode_out,8);
 460   3            mmi_dq_fds_write(MID_FDS_FILE_SET,(unsigned char *)&g_dq_fs_init_set,sizeof(mmi_fs_setting));
 461   3            return 0xFE;
 462   3          }
 463   2        }
 464   1        //printf("check input return 0xFF");
 465   1        return 0xFF;
 466   1      }
 467          
 468          /*
 469          parameter: 
 470            none
 471          return :
 472            none
 473          */
 474          RET_VAL mmi_dq_fs_set_pwd(unsigned char *pwd,unsigned char pwd_size,fds_use_type type)
 475          {
 476   1        unsigned char i = 0;
 477   1        unsigned char password[4];
 478   1      
 479   1        if(type == FDS_USE_TYPE_ADMIN)
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/07/2021 10:03:36 PAGE 9   

 480   1          i = 0;
 481   1      #ifdef __LOCK_110_SUPPORT__
 482   1        else if(type == FDS_USE_TYPE_110)
 483   1          i = 1;
 484   1      #endif
 485   1        else
 486   1        {
 487   2      #ifdef __LOCK_110_SUPPORT__
 488   2          i = PWD_ADMIN_NUM+PWD_110_NUM;
 489   2      #else
                  i = PWD_ADMIN_NUM;
              #endif
 492   2          for(;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 493   2          {
 494   3            if (g_dq_fs_pwd[i].flag == 0xFF)
 495   3              break;
 496   3          }
 497   2        }
 498   1      
 499   1        get_index = i;
 500   1      
 501   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 502   1        {
 503   2          memset(password, 0xFF, sizeof(password));
 504   2          //g_dq_fs_pwd[i].index = i;
 505   2          mmi_dq_fs_pwd_string_to_byte(pwd, pwd_size, password);
 506   2          memcpy((char *)g_dq_fs_pwd[i].key_pwd, (const char *)password, 4);
 507   2          g_dq_fs_pwd[i].flag = type;
 508   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_P
             -WD_MAX_NUM);
 509   2        }
 510   1        return RET_FAIL;
 511   1      }
 512          
 513          /*
 514          parameter: 
 515            none
 516          return :
 517            none
 518          */
 519          RET_VAL mmi_dq_fs_del_pwd(unsigned char index, fds_use_type type)
 520          {
 521   1        if (index < MMI_DQ_FS_PWD_MAX_NUM && g_dq_fs_pwd[index].flag == type)
 522   1        {
 523   2          g_dq_fs_pwd[index].flag = FDS_USE_TYPE_INVALID;
 524   2          //g_dq_fs_pwd[index].index = 0xFF;
 525   2          memset(g_dq_fs_pwd[index].key_pwd, 0xFF, sizeof(g_dq_fs_pwd[index].key_pwd));
 526   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_P
             -WD_MAX_NUM);
 527   2        }
 528   1        return RET_FAIL;
 529   1      }
 530          
 531          /*
 532          parameter: 
 533            none
 534          return :
 535            none
 536          */
 537          RET_VAL mmi_dq_fs_clr_pwd(void)
 538          {
 539   1        unsigned char i = PWD_ADMIN_NUM;
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/07/2021 10:03:36 PAGE 10  

 540   1      #ifdef __LOCK_110_SUPPORT__
 541   1        i += PWD_110_NUM;
 542   1      #endif
 543   1        for(;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 544   1        {
 545   2          if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_USER)
 546   2          {
 547   3            g_dq_fs_pwd[i].flag = FDS_USE_TYPE_INVALID;
 548   3            //g_dq_fs_pwd[i].index = 0xFF;
 549   3            memset(g_dq_fs_pwd[i].key_pwd, 0xFF, sizeof(g_dq_fs_pwd[i].key_pwd));
 550   3          }
 551   2        }
 552   1        return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PW
             -D_MAX_NUM);
 553   1      }
 554          
 555          #if defined(__LOCK_FP_SUPPORT__)
 556          /*
 557          parameter: 
 558            none
 559          return :
 560            none
 561          */
 562          unsigned char mmi_dq_fs_get_fp_unuse_index(void)
 563          {
 564   1        unsigned char i = FP_ADMIN_NUM;
 565   1      #ifdef __LOCK_110_SUPPORT__
 566   1        i += FP_110_NUM;
 567   1      #endif
 568   1        for(;i<MMI_DQ_FS_FP_MAX_NUM;i++)
 569   1        {
 570   2          if (g_dq_fs_fp[i].fp_index == 0xFF)
 571   2            break;
 572   2        }
 573   1        if (i >= MMI_DQ_FS_FP_MAX_NUM)
 574   1          return 0xFF;
 575   1        return i;
 576   1      }
 577          
 578          #ifdef __LOCK_110_SUPPORT__
 579          /*
 580          parameter: 
 581            none
 582          return :
 583            none
 584          */
 585          unsigned char mmi_dq_fs_get_fp_110_unuse_index(void)
 586          {
 587   1        unsigned char i = FP_ADMIN_NUM;
 588   1        unsigned char j = 0;
 589   1      
 590   1        for(;j<FP_110_NUM;j++)
 591   1        {
 592   2          if(g_dq_fs_fp[i+j].fp_index == 0xFF)
 593   2            break;
 594   2        }
 595   1        if(j>=FP_110_NUM)
 596   1          return 0xFF;
 597   1        return i+j;
 598   1      }
 599          #endif
 600          
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/07/2021 10:03:36 PAGE 11  

 601          /*
 602          parameter: 
 603            none
 604          return :
 605            none
 606          */
 607          RET_VAL mmi_dq_fs_check_fp(unsigned char fp_index, fds_use_type type)
 608          {
 609   1        if ((fp_index < MMI_DQ_FS_FP_MAX_NUM) && (g_dq_fs_fp[fp_index].fp_index == fp_index) && ((g_dq_fs_fp[fp_i
             -ndex].flag == type) || (type == FDS_USE_TYPE_ALL)))
 610   1          return RET_SUCESS;
 611   1        else
 612   1          return RET_FAIL;
 613   1      }
 614          
 615          /*
 616          parameter: 
 617            none
 618          return :
 619            none
 620          */
 621          RET_VAL mmi_dq_fs_set_fp(unsigned char fs_index, fds_use_type type)
 622          {
 623   1        g_dq_fs_fp[fs_index].fp_index = fs_index;
 624   1        g_dq_fs_fp[fs_index].flag = type;
 625   1        return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MA
             -X_NUM);
 626   1      }
 627          
 628          /*
 629          parameter: 
 630            none
 631          return :
 632            none
 633          */
 634          RET_VAL mmi_dq_fs_del_fp(unsigned char fp_index, fds_use_type type)
 635          {
 636   1        if (mmi_dq_fs_check_fp(fp_index, type) == RET_SUCESS)
 637   1        {
 638   2          g_dq_fs_fp[fp_index].flag = FDS_USE_TYPE_INVALID;
 639   2          g_dq_fs_fp[fp_index].fp_index = 0xFF;
 640   2          return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_M
             -AX_NUM);
 641   2        }
 642   1        return RET_FAIL;
 643   1      }
 644          
 645          /*
 646          parameter: 
 647            none
 648          return :
 649            none
 650          */
 651          RET_VAL mmi_dq_fs_clr_fp(void)
 652          {
 653   1        unsigned char i = FP_ADMIN_NUM;
 654   1        unsigned short fp_ret = 0;
 655   1      #ifdef __LOCK_110_SUPPORT__
 656   1        i += FP_110_NUM;
 657   1      #endif
 658   1        for(;i<MMI_DQ_FS_FP_MAX_NUM;i++)
 659   1        {
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/07/2021 10:03:36 PAGE 12  

 660   2          if(g_dq_fs_fp[i].fp_index != 0xFF)
 661   2          {
 662   3            fp_ret = mmi_dq_fp_delete(g_dq_fs_fp[i].fp_index);
 663   3            if(fp_ret == 0)
 664   3            {
 665   4              g_dq_fs_fp[i].flag = FDS_USE_TYPE_INVALID;
 666   4              g_dq_fs_fp[i].fp_index = 0xFF;
 667   4            }
 668   3          }
 669   2        }
 670   1        return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp)*MMI_DQ_FS_FP_MAX_
             -NUM);
 671   1      }
 672          
 673          #endif
 674          
 675          #ifdef __LOCK_RFID_CARD_SUPPORT__
 676          
 677          /*
 678          parameter: 
 679            none
 680          return :
 681            none
 682          */
 683          unsigned char mmi_dq_fs_get_rfid_unuse_index(void)
 684          {
 685   1        unsigned char i = 0;
 686   1      
 687   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 688   1        {
 689   2          if (g_dq_fs_rfid[i].index == 0xFF)
 690   2            break;
 691   2        }
 692   1      
 693   1        if (i >= MMI_DQ_FS_RFID_MAX_NUM)
 694   1          return 0xFF;
 695   1        return i;
 696   1      }
 697          
 698          /*
 699          parameter: 
 700            none
 701          return :
 702            none
 703          */
 704          unsigned char mmi_dq_fs_check_rfid(unsigned char *sec_data, fds_use_type type)
 705          {
 706   1        unsigned char i = 0, j = 0;
 707   1      
 708   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 709   1        {
 710   2          for (j = 0; j < RFID_SEC_DATA_LEN; j++)
 711   2          {
 712   3            if (g_dq_fs_rfid[i].sec_data[j] != sec_data[j])
 713   3              break;
 714   3          }
 715   2          if (j == RFID_SEC_DATA_LEN)
 716   2            break;
 717   2        }
 718   1        if (i < MMI_DQ_FS_RFID_MAX_NUM && ((g_dq_fs_rfid[i].flag == type) || (type == FDS_USE_TYPE_ALL)))
 719   1        {
 720   2          return i;
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/07/2021 10:03:36 PAGE 13  

 721   2        }
 722   1        else
 723   1        {
 724   2          return 0xFF;
 725   2        }
 726   1      }
 727          
 728          /*
 729          parameter: 
 730            none
 731          return :
 732            none
 733          */
 734          RET_VAL mmi_dq_fs_set_rfid(unsigned char *sec_data, fds_use_type type)
 735          {
 736   1        unsigned char i = 0, j = 0;
 737   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 738   1        {
 739   2          if (g_dq_fs_rfid[i].index == 0xFF)
 740   2            break;
 741   2        }
 742   1        if (i < MMI_DQ_FS_RFID_MAX_NUM)
 743   1        {
 744   2          g_dq_fs_rfid[i].index = i;
 745   2          g_dq_fs_rfid[i].flag = type;
 746   2          for (j = 0; j < RFID_SEC_DATA_LEN; j++)
 747   2          {
 748   3            g_dq_fs_rfid[i].sec_data[j] = sec_data[j];
 749   3          }
 750   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_
             -RFID_MAX_NUM);
 751   2        }
 752   1        return RET_FAIL;
 753   1      }
 754          
 755          /*
 756          parameter: 
 757            none
 758          return :
 759            none
 760          */
 761          RET_VAL mmi_dq_fs_del_rfid(unsigned char rfid_index)
 762          {
 763   1        if (rfid_index < MMI_DQ_FS_RFID_MAX_NUM && g_dq_fs_rfid[rfid_index].index == rfid_index)
 764   1        {
 765   2          g_dq_fs_rfid[rfid_index].index = 0xFF;
 766   2          g_dq_fs_rfid[rfid_index].flag = FDS_USE_TYPE_INVALID;
 767   2          memset(g_dq_fs_rfid[rfid_index].sec_data, 0xFF, sizeof(g_dq_fs_rfid[rfid_index].sec_data));
 768   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_
             -RFID_MAX_NUM);
 769   2        }
 770   1        return RET_FAIL;
 771   1      }
 772          
 773          /*
 774          parameter: 
 775            none
 776          return :
 777            none
 778          */
 779          RET_VAL mmi_dq_fs_clr_rfid(void)
 780          {
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/07/2021 10:03:36 PAGE 14  

 781   1        unsigned char i = 0;
 782   1      
 783   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 784   1        {
 785   2          g_dq_fs_rfid[i].flag = FDS_USE_TYPE_INVALID;
 786   2          g_dq_fs_rfid[i].index = 0xFF;
 787   2          memset(g_dq_fs_rfid[i].sec_data, 0xFF, sizeof(g_dq_fs_rfid[i].sec_data));
 788   2        }
 789   1        return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_R
             -FID_MAX_NUM);
 790   1      }
 791          
 792          #endif
 793          
 794          /*
 795          parameter: 
 796            none
 797          return :
 798            none
 799          */
 800          RET_VAL mmi_dq_fs_set_open_mode(sys_open_mode mode)
 801          {
 802   1        if (g_dq_fs_init_set.open_mode == mode)
 803   1          return RET_SUCESS;
 804   1      
 805   1        g_dq_fs_init_set.open_mode = mode;
 806   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 807   1        
 808   1      }
 809          /*
 810          parameter: 
 811            none
 812          return :
 813            none
 814          */
 815          sys_open_mode mmi_dq_fs_get_open_mode(void)
 816          {
 817   1        return g_dq_fs_init_set.open_mode;
 818   1      }
 819          
 820          /*
 821          parameter: 
 822            none
 823          return :
 824            none
 825          */
 826          RET_VAL mmi_dq_fs_set_pro_sound(unsigned char flag)
 827          {
 828   1        if (g_dq_fs_init_set.open_pro_sound == flag)
 829   1          return RET_SUCESS;
 830   1      
 831   1        g_dq_fs_init_set.open_pro_sound = flag;
 832   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 833   1      }
 834          
 835          /*
 836          parameter: 
 837            none
 838          return :
 839            none
 840          */
 841          unsigned char mmi_dq_fs_get_pro_sound_state(void)
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/07/2021 10:03:36 PAGE 15  

 842          {
 843   1        return g_dq_fs_init_set.open_pro_sound;
 844   1      }
 845          
 846          /*
 847          parameter: 
 848            none
 849          return :
 850            none
 851          */
 852          unsigned char mmi_dq_fs_get_init_flag(void)
 853          {
 854   1        return g_dq_fs_init_set.init_flag;
 855   1      }
 856          
 857          /*
 858          parameter: 
 859            none
 860          return :
 861            none
 862          */
 863          RET_VAL mmi_dq_fs_set_init_flag(unsigned char flag)
 864          {
 865   1        g_dq_fs_init_set.init_flag = flag;
 866   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 867   1      }
 868          
 869          /*
 870          parameter: 
 871            none
 872          return :
 873            none
 874          */
 875          RET_VAL mmi_dq_fs_set_factory_flag(unsigned char flag)
 876          {
 877   1        g_dq_fs_init_set.factory_flag = flag;
 878   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 879   1      }
 880          
 881          /*
 882          parameter: 
 883            none
 884          return :
 885            none
 886          */
 887          unsigned char mmi_dq_fs_get_factory_flag(void)
 888          {
 889   1        return g_dq_fs_init_set.factory_flag;
 890   1      }
 891          
 892          /*
 893          parameter: 
 894            none
 895          return :
 896            none
 897          */
 898          unsigned char mmi_dq_fs_get_admin_status(void)
 899          {
 900   1        return g_dq_fs_init_set.admin_status;
 901   1      }
 902          
 903          /*
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/07/2021 10:03:36 PAGE 16  

 904          parameter: 
 905            none
 906          return :
 907            none
 908          */
 909          RET_VAL mmi_dq_fs_set_admin_status(unsigned char status)
 910          {
 911   1        g_dq_fs_init_set.admin_status = status;
 912   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 913   1      }
 914          
 915          #if 0
              /*
              parameter: 
                none
              return :
                none
              */
              RET_VAL mmi_dq_fs_set_wifi_setting(unsigned char flag)
              {
                g_dq_fs_init_set.wifi_flag = flag;
                return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
              }
              
              /*
              parameter: 
                none
              return :
                none
              */
              unsigned char mmi_dq_fs_get_wifi_setting(void)
              {
                return g_dq_fs_init_set.wifi_flag;
              }
              #endif
 939          
 940          
 941          
 942          /*
 943          parameter: 
 944            none
 945          return :
 946            none
 947          */
 948          RET_VAL mmi_dq_fs_set_business_flag(unsigned char flag)
 949          {
 950   1        #if 1
 951   1        if(flag != g_dq_fs_init_set.business_flag)
 952   1        {
 953   2          g_dq_fs_init_set.business_flag = flag;
 954   2          return mmi_dq_fds_write(MID_FDS_FILE_SET,(unsigned char *)&g_dq_fs_init_set,sizeof(mmi_fs_setting));
 955   2        }
 956   1        #else
                g_dq_fs_init_set.business_flag = flag;
                #endif
 959   1        return RET_SUCESS;
 960   1      }
 961          
 962          /*
 963          parameter: 
 964            none
 965          return :
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/07/2021 10:03:36 PAGE 17  

 966            none
 967          */
 968          unsigned char mmi_dq_fs_get_business_flag(void)
 969          {
 970   1        return g_dq_fs_init_set.business_flag;
 971   1      }
 972          
 973          
 974          
 975          
 976          
 977          
 978          
 979          
 980          
 981          
 982          
 983          
 984          
 985          
 986          
 987          
 988          
 989          
 990          
 991          
 992          
 993          
 994          
 995          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4120    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    705     104
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     15    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
