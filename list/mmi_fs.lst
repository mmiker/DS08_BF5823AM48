C51 COMPILER V9.59.0.0   MMI_FS                                                            03/05/2021 16:00:16 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MMI_FS
OBJECT MODULE PLACED IN .\output\mmi_fs.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE mmi_src\mmi_fs.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;.\
                    -Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd_rfi
                    -d;.\mmi_inc) DEBUG PRINT(.\list\mmi_fs.lst) TABS(2) OBJECT(.\output\mmi_fs.obj)

line level    source

   1          #ifndef __MMI_FS_C__
   2          #define __MMI_FS_C__
   3          
   4          #include "mmi_fs.h"
   5          #include "mmi_sys.h"
   6          #include "mcu02_sfr.h"
   7          #include "mcu02_eeprom.h"
   8          #include "string.h"
   9          #include "stdio.h"
  10          #include "delay.h"
  11          #include "mmi_fps.h"
  12          
  13          mmi_fs_setting data g_dq_fs_init_set;
  14          
  15          #define MMI_DQ_FS_PWD_MAX_NUM 100
  16          mmi_fs_pwd g_dq_fs_pwd[MMI_DQ_FS_PWD_MAX_NUM];
  17          
  18          #if defined(__LOCK_FP_SUPPORT__)
  19          #define MMI_DQ_FS_FP_MAX_NUM 50
  20          mmi_fs_fp g_dq_fs_fp[MMI_DQ_FS_FP_MAX_NUM];
  21          #endif
  22          
  23          #ifdef __LOCK_RFID_CARD_SUPPORT__
  24          #define MMI_DQ_FS_RFID_MAX_NUM 10
  25          mmi_fs_rfid g_dq_fs_rfid[MMI_DQ_FS_RFID_MAX_NUM];
  26          #endif
  27          
  28          static void mmi_dq_fds_read(mid_fds_file_id file, uint8_t *r_data, uint16_t r_size)
  29          {
  30   1        uint16_t i;
  31   1      
  32   1        switch (file)
  33   1        {
  34   2        case MID_FDS_FILE_SET:
  35   2          eeprom_select(0);
  36   2          for (i = 0; i < r_size; i++)
  37   2          {
  38   3            r_data[i] = eeprom_read_byte(0, i); //??????
  39   3          }
  40   2          break;
  41   2        case MID_FDS_FILE_PWD:
  42   2          eeprom_select(0);
  43   2          for (i = 0; i < r_size; i++)
  44   2          {
  45   3            r_data[i] = eeprom_read_byte(0, i + 24); //??????
  46   3          }
  47   2          break;
  48   2      #ifdef __LOCK_FP_SUPPORT__
  49   2        case MID_FDS_FILE_FP:
  50   2          eeprom_select(1);
  51   2          eeprom_nvr_read_page(r_data, 0, 0, r_size);
  52   2          break;
  53   2      #endif
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/05/2021 16:00:16 PAGE 2   

  54   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
  55   2        case MID_FDS_FILE_RF:
  56   2          eeprom_select(1);
  57   2          eeprom_nvr_read_page(r_data, 1, 0, r_size);
  58   2          break;
  59   2      #endif
  60   2        default:
  61   2          break;
  62   2        }
  63   1      }
  64          
  65          static RET_VAL mmi_dq_fds_write(mid_fds_file_id file, uint8_t *w_data, uint16_t w_size)
  66          {
  67   1        uint16_t i;
  68   1        ErrStatus ret;
  69   1        eeprom_erase_time(9);
  70   1        switch (file)
  71   1        {
  72   2        case MID_FDS_FILE_SET:
  73   2        {
  74   3          uint8_t *w_data2 = (uint8_t *)g_dq_fs_pwd;
  75   3          uint16_t w_size2 = sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_NUM;
  76   3          eeprom_select(0);
  77   3          eeprom_erase_page(0); //????1K
  78   3          for (i = 0; i < w_size; i++)
  79   3          {
  80   4            ret = eeprom_write_byte(0, i, w_data[i]); //??????
  81   4            if (ret == ERROR)
  82   4            {
  83   5              //printf("mmi_dq_fds_write  error  %d\n",i);
  84   5              return RET_FAIL;
  85   5            }
  86   4          }
  87   3          for (i = 0; i < w_size2; i++)
  88   3          {
  89   4            ret = eeprom_write_byte(0, i + 24, w_data2[i]); //??????
  90   4            if (ret == ERROR)
  91   4            {
  92   5              //printf("mmi_dq_fds_write  error  %d\n",i);
  93   5              return RET_FAIL;
  94   5            }
  95   4          }
  96   3        }
  97   2        break;
  98   2        case MID_FDS_FILE_PWD:
  99   2        {
 100   3          uint8_t *w_data2 = (uint8_t *)&g_dq_fs_init_set;
 101   3          uint16_t w_size2 = sizeof(mmi_fs_setting);
 102   3          eeprom_select(0);
 103   3          eeprom_erase_page(0); //????1K
 104   3          for (i = 0; i < w_size2; i++)
 105   3          {
 106   4            ret = eeprom_write_byte(0, i, w_data2[i]); //??????
 107   4            if (ret == ERROR)
 108   4            {
 109   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 110   5              return RET_FAIL;
 111   5            }
 112   4          }
 113   3          for (i = 0; i < w_size; i++)
 114   3          {
 115   4            ret = eeprom_write_byte(0, i + 24, w_data[i]); //??????
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/05/2021 16:00:16 PAGE 3   

 116   4            if (ret == ERROR)
 117   4            {
 118   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 119   5              return RET_FAIL;
 120   5            }
 121   4          }
 122   3        }
 123   2        break;
 124   2      #ifdef __LOCK_FP_SUPPORT__
 125   2        case MID_FDS_FILE_FP:
 126   2          eeprom_select(1);
 127   2          eeprom_erase_page(0); //????512byte
 128   2          for (i = 0; i < w_size; i++)
 129   2          {
 130   3            ret = eeprom_write_byte(0, i, w_data[i]);
 131   3            if (ret == ERROR)
 132   3            {
 133   4              //printf("mmi_dq_fds_write  error  %d\n",i);
 134   4              return RET_FAIL;
 135   4            }
 136   3          }
 137   2          break;
 138   2      #endif
 139   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 140   2        case MID_FDS_FILE_RF:
 141   2          eeprom_select(1);
 142   2          eeprom_erase_page(1); //????512byte
 143   2          for (i = 0; i < w_size; i++)
 144   2          {
 145   3            ret = eeprom_write_byte(1, i, w_data[i]);
 146   3            if (ret == ERROR)
 147   3            {
 148   4              //printf("mmi_dq_fds_write  error  %d\n",i);
 149   4              return RET_FAIL;
 150   4            }
 151   3          }
 152   2          break;
 153   2      #endif
 154   2        default:
 155   2          return RET_FAIL;
 156   2        }
 157   1        //printf("mmi_dq_fds_write  suc\n");
 158   1        return RET_SUCESS;
 159   1      }
 160          
 161          /*
 162          parameter: 
 163            none
 164          return :
 165            none
 166          */
 167          void mmi_dq_fs_init(void)
 168          {
 169   1        mmi_dq_fds_read(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 170   1        if (FDS_INIT_LOCK_SUC == g_dq_fs_init_set.init_flag || FDS_INIT_APP_SUC == g_dq_fs_init_set.init_flag)
 171   1        {
 172   2          unsigned char i = 0;
 173   2          mmi_dq_fds_read(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_N
             -UM);
 174   2      #ifdef __LOCK_FP_SUPPORT__
 175   2          mmi_dq_fds_read(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM);
 176   2      #endif
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/05/2021 16:00:16 PAGE 4   

 177   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 178   2          mmi_dq_fds_read(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MAX
             -_NUM);
 179   2      #endif
 180   2          if (g_dq_fs_init_set.admin_status > 0)
 181   2          {
 182   3            for (; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 183   3            {
 184   4              if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
 185   4                break;
 186   4            }
 187   3            if (i >= MMI_DQ_FS_PWD_MAX_NUM)
 188   3            {
 189   4              g_dq_fs_init_set.admin_status = 0;
 190   4              mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 191   4            }
 192   3          }
 193   2        }
 194   1        else
 195   1        {
 196   2          //printf("mmi_dq_fs_init init error");
 197   2          memset(g_dq_fs_pwd, 0xFF, sizeof(g_dq_fs_pwd));
 198   2          mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_
             -NUM);
 199   2      
 200   2      #ifdef __LOCK_FP_SUPPORT__
 201   2          memset(g_dq_fs_fp, 0xFF, sizeof(g_dq_fs_fp));
 202   2          mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM)
             -;
 203   2      
 204   2          mmi_dq_fp_empty();
 205   2      #endif
 206   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 207   2          memset(g_dq_fs_rfid, 0xFF, sizeof(g_dq_fs_rfid));
 208   2          mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MA
             -X_NUM);
 209   2      #endif
 210   2          g_dq_fs_init_set.init_flag = FDS_INIT_LOCK_SUC;
 211   2          g_dq_fs_init_set.open_pro_sound = 1;
 212   2          g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 213   2          g_dq_fs_init_set.admin_status = 0;
 214   2          g_dq_fs_init_set.factory_flag = 0;
 215   2          g_dq_fs_init_set.wifi_flag = 0;
 216   2          mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 217   2        }
 218   1      }
 219          
 220          /**
 221            * @brief  ????????
 222            * @param  none
 223            * @return none
 224            * @note   none
 225            * @see    none
 226            */
 227          RET_VAL mmi_dq_fs_clr_set(void)
 228          {
 229   1        g_dq_fs_init_set.open_pro_sound = 1;
 230   1        g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 231   1      
 232   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 233   1      }
 234          
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/05/2021 16:00:16 PAGE 5   

 235          /**
 236            * @brief  ??¦Ë?????
 237            * @param  none
 238            * @return none
 239            * @note   none
 240            * @see    none
 241            */
 242          RET_VAL mmi_dq_fs_reset(void)
 243          {
 244   1        memset(g_dq_fs_pwd, 0xFF, sizeof(g_dq_fs_pwd));
 245   1        mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_N
             -UM);
 246   1      #ifdef __LOCK_FP_SUPPORT__
 247   1        memset(g_dq_fs_fp, 0xFF, sizeof(g_dq_fs_fp));
 248   1        mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM);
 249   1      
 250   1        mmi_dq_fp_empty();
 251   1      #endif
 252   1      #ifdef __LOCK_RFID_CARD_SUPPORT__
 253   1        memset(g_dq_fs_rfid, 0xFF, sizeof(g_dq_fs_rfid));
 254   1        mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MAX
             -_NUM);
 255   1      #endif
 256   1        g_dq_fs_init_set.init_flag = FDS_INIT_LOCK_SUC;
 257   1        g_dq_fs_init_set.open_pro_sound = 1;
 258   1        g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 259   1        g_dq_fs_init_set.admin_status = 0;
 260   1        g_dq_fs_init_set.wifi_flag = 0;
 261   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 262   1      }
 263          
 264          /*
 265          parameter: 
 266            none
 267          return :
 268            none
 269          */
 270          void mmi_dq_fs_pwd_string_to_byte(unsigned char *input_pwd, unsigned char pwd_len, unsigned char *output_p
             -wd)
 271          {
 272   1        unsigned char i = 0;
 273   1        unsigned char bit_l = 0;
 274   1        unsigned char bit_h = 0;
 275   1      
 276   1        for (i = 0; i < pwd_len; i++)
 277   1        {
 278   2          bit_l = *(input_pwd + i) & 0x0F;
 279   2          i++;
 280   2          if (i < pwd_len)
 281   2            bit_h = *(input_pwd + i) & 0x0F;
 282   2          else
 283   2            bit_h = 0xF;
 284   2          *output_pwd++ = bit_l << 4 | bit_h;
 285   2        }
 286   1        return;
 287   1      }
 288          /*
 289          parameter: 
 290            none
 291          return :
 292            none
 293          */
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/05/2021 16:00:16 PAGE 6   

 294          void mmi_dq_fs_pwd_byte_to_string(unsigned char *input_pwd, unsigned char *output_pwd)
 295          {
 296   1        unsigned char i = 0;
 297   1        unsigned char pwd = 0;
 298   1        for (i = 0; i < 4; i++)
 299   1        {
 300   2          pwd = *(input_pwd + i);
 301   2          if (pwd == 0xFF)
 302   2            break;
 303   2          else
 304   2            *output_pwd++ = (pwd & 0xF0) >> 4;
 305   2          if ((pwd & 0x0F) == 0x0F)
 306   2            break;
 307   2          else
 308   2          {
 309   3            *output_pwd++ = pwd & 0x0F;
 310   3          }
 311   2        }
 312   1        return;
 313   1      }
 314          
 315          /*
 316          parameter: 
 317            none
 318          return :
 319            none
 320          */
 321          unsigned char mmi_dq_fs_get_pwd_unuse_index(void)
 322          {
 323   1        unsigned char i = 0;
 324   1      
 325   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 326   1        {
 327   2          if (g_dq_fs_pwd[i].flag == 0xFF)
 328   2            break;
 329   2        }
 330   1      
 331   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 332   1          return i;
 333   1        else
 334   1          return 0xFF;
 335   1      }
 336          
 337          /*
 338          parameter: 
 339            none
 340          return :
 341            none
 342          */
 343          unsigned char mmi_dq_fs_check_input_pwd(unsigned char *input_pwd, unsigned char len, fds_use_type type)
 344          {
 345   1        unsigned char i = 0;
 346   1        unsigned char k = 0;
 347   1        unsigned char password[4];
 348   1        unsigned char ret_val = 0xFF;
 349   1      
 350   1        memset(password, 0xFF, sizeof(password));
 351   1        mmi_dq_fs_pwd_string_to_byte(input_pwd, len, password);
 352   1      
 353   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 354   1        {
 355   2          if (g_dq_fs_pwd[i].flag != 0xFF)
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/05/2021 16:00:16 PAGE 7   

 356   2          {
 357   3            for (k = 0; k < 4; k++)
 358   3            {
 359   4              if (password[k] != g_dq_fs_pwd[i].key_pwd[k])
 360   4                break;
 361   4            }
 362   3            if (k == 4)
 363   3            {
 364   4              break;
 365   4            }
 366   3          }
 367   2        }
 368   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 369   1        {
 370   2          if ((g_dq_fs_pwd[i].flag == type) || (type == FDS_USE_TYPE_ALL))
 371   2            ret_val = i;
 372   2          else
 373   2            ret_val = 0xFF;
 374   2        }
 375   1        else
 376   1          ret_val = 0xFF;
 377   1      
 378   1        return ret_val;
 379   1      }
 380          
 381          /*
 382          parameter: 
 383            none
 384          return :
 385            none
 386          */
 387          RET_VAL mmi_dq_fs_set_pwd(unsigned char *pwd, unsigned char pwd_size, fds_use_type type)
 388          {
 389   1        unsigned char i = 0xFF;
 390   1        unsigned char password[4];
 391   1      
 392   1        if (type == FDS_USE_TYPE_ADMIN)
 393   1        {
 394   2          for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 395   2          {
 396   3            if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
 397   3              break;
 398   3          }
 399   2        }
 400   1        if (i >= MMI_DQ_FS_PWD_MAX_NUM)
 401   1        {
 402   2          for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 403   2          {
 404   3            if (g_dq_fs_pwd[i].flag == 0xFF)
 405   3              break;
 406   3          }
 407   2        }
 408   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 409   1        {
 410   2          memset(password, 0xFF, sizeof(password));
 411   2          //g_dq_fs_pwd[i].index = i;
 412   2          mmi_dq_fs_pwd_string_to_byte(pwd, pwd_size, password);
 413   2          memcpy((char *)g_dq_fs_pwd[i].key_pwd, (const char *)password, 4);
 414   2          g_dq_fs_pwd[i].flag = type;
 415   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_P
             -WD_MAX_NUM);
 416   2        }
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/05/2021 16:00:16 PAGE 8   

 417   1        return RET_FAIL;
 418   1      }
 419          
 420          /*
 421          parameter: 
 422            none
 423          return :
 424            none
 425          */
 426          RET_VAL mmi_dq_fs_del_pwd(unsigned char index, fds_use_type type)
 427          {
 428   1        if (index < MMI_DQ_FS_PWD_MAX_NUM && g_dq_fs_pwd[index].flag == type)
 429   1        {
 430   2          g_dq_fs_pwd[index].flag = FDS_USE_TYPE_INVALID;
 431   2          //g_dq_fs_pwd[index].index = 0xFF;
 432   2          memset(g_dq_fs_pwd[index].key_pwd, 0xFF, sizeof(g_dq_fs_pwd[index].key_pwd));
 433   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_P
             -WD_MAX_NUM);
 434   2        }
 435   1        return RET_FAIL;
 436   1      }
 437          
 438          /*
 439          parameter: 
 440            none
 441          return :
 442            none
 443          */
 444          RET_VAL mmi_dq_fs_clr_pwd(void)
 445          {
 446   1        unsigned char i = 0;
 447   1      
 448   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 449   1        {
 450   2          if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_USER)
 451   2          {
 452   3            g_dq_fs_pwd[i].flag = FDS_USE_TYPE_INVALID;
 453   3            //g_dq_fs_pwd[i].index = 0xFF;
 454   3            memset(g_dq_fs_pwd[i].key_pwd, 0xFF, sizeof(g_dq_fs_pwd[i].key_pwd));
 455   3          }
 456   2        }
 457   1        return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PW
             -D_MAX_NUM);
 458   1      }
 459          
 460          #if defined(__LOCK_FP_SUPPORT__)
 461          /*
 462          parameter: 
 463            none
 464          return :
 465            none
 466          */
 467          unsigned char mmi_dq_fs_get_fp_unuse_index(void)
 468          {
 469   1        unsigned char i = 2;
 470   1      
 471   1        for (; i < MMI_DQ_FS_FP_MAX_NUM; i++)
 472   1        {
 473   2          if (g_dq_fs_fp[i].fp_index == 0xFF)
 474   2            break;
 475   2        }
 476   1        if (i >= MMI_DQ_FS_FP_MAX_NUM)
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/05/2021 16:00:16 PAGE 9   

 477   1          return 0xFF;
 478   1        return i;
 479   1      }
 480          
 481          /*
 482          parameter: 
 483            none
 484          return :
 485            none
 486          */
 487          RET_VAL mmi_dq_fs_check_fp(unsigned char fp_index, fds_use_type type)
 488          {
 489   1        if ((fp_index < MMI_DQ_FS_FP_MAX_NUM) && (g_dq_fs_fp[fp_index].fp_index == fp_index) && ((g_dq_fs_fp[fp_i
             -ndex].flag == type) || (type == FDS_USE_TYPE_ALL)))
 490   1          return RET_SUCESS;
 491   1        else
 492   1          return RET_FAIL;
 493   1      }
 494          
 495          /*
 496          parameter: 
 497            none
 498          return :
 499            none
 500          */
 501          RET_VAL mmi_dq_fs_set_fp(unsigned char fs_index, fds_use_type type)
 502          {
 503   1        g_dq_fs_fp[fs_index].fp_index = fs_index;
 504   1        g_dq_fs_fp[fs_index].flag = type;
 505   1        return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MA
             -X_NUM);
 506   1      }
 507          
 508          /*
 509          parameter: 
 510            none
 511          return :
 512            none
 513          */
 514          RET_VAL mmi_dq_fs_del_fp(unsigned char fp_index, fds_use_type type)
 515          {
 516   1        if (mmi_dq_fs_check_fp(fp_index, type) == RET_SUCESS)
 517   1        {
 518   2          g_dq_fs_fp[fp_index].flag = FDS_USE_TYPE_INVALID;
 519   2          g_dq_fs_fp[fp_index].fp_index = 0xFF;
 520   2          return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_M
             -AX_NUM);
 521   2        }
 522   1        return RET_FAIL;
 523   1      }
 524          
 525          /*
 526          parameter: 
 527            none
 528          return :
 529            none
 530          */
 531          RET_VAL mmi_dq_fs_clr_fp(void)
 532          {
 533   1        unsigned char i = 0;
 534   1        unsigned short fp_ret = 0;
 535   1      
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/05/2021 16:00:16 PAGE 10  

 536   1        for (i = 0; i < MMI_DQ_FS_FP_MAX_NUM; i++)
 537   1        {
 538   2          if (g_dq_fs_fp[i].flag != FDS_USE_TYPE_ADMIN)
 539   2          {
 540   3            if (g_dq_fs_fp[i].fp_index != 0xFF)
 541   3            {
 542   4              fp_ret = mmi_dq_fp_delete(g_dq_fs_fp[i].fp_index);
 543   4              if (fp_ret == 0)
 544   4              {
 545   5                g_dq_fs_fp[i].flag = FDS_USE_TYPE_INVALID;
 546   5                g_dq_fs_fp[i].fp_index = 0xFF;
 547   5              }
 548   4            }
 549   3          }
 550   2        }
 551   1        return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MA
             -X_NUM);
 552   1      }
 553          
 554          #endif
 555          
 556          #ifdef __LOCK_RFID_CARD_SUPPORT__
 557          
 558          /*
 559          parameter: 
 560            none
 561          return :
 562            none
 563          */
 564          unsigned char mmi_dq_fs_get_rfid_unuse_index(void)
 565          {
 566   1        unsigned char i = 0;
 567   1      
 568   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 569   1        {
 570   2          if (g_dq_fs_rfid[i].index == 0xFF)
 571   2            break;
 572   2        }
 573   1      
 574   1        if (i >= MMI_DQ_FS_RFID_MAX_NUM)
 575   1          return 0xFF;
 576   1        return i;
 577   1      }
 578          
 579          /*
 580          parameter: 
 581            none
 582          return :
 583            none
 584          */
 585          unsigned char mmi_dq_fs_check_rfid(unsigned char *sec_data, fds_use_type type)
 586          {
 587   1        unsigned char i = 0, j = 0;
 588   1      
 589   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 590   1        {
 591   2          for (j = 0; j < RFID_SEC_DATA_LEN; j++)
 592   2          {
 593   3            if (g_dq_fs_rfid[i].sec_data[j] != sec_data[j])
 594   3              break;
 595   3          }
 596   2          if (j == RFID_SEC_DATA_LEN)
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/05/2021 16:00:16 PAGE 11  

 597   2            break;
 598   2        }
 599   1        if (i < MMI_DQ_FS_RFID_MAX_NUM && ((g_dq_fs_rfid[i].flag == type) || (type == FDS_USE_TYPE_ALL)))
 600   1        {
 601   2          return i;
 602   2        }
 603   1        else
 604   1        {
 605   2          return 0xFF;
 606   2        }
 607   1      }
 608          
 609          /*
 610          parameter: 
 611            none
 612          return :
 613            none
 614          */
 615          RET_VAL mmi_dq_fs_set_rfid(unsigned char *sec_data, fds_use_type type)
 616          {
 617   1        unsigned char i = 0, j = 0;
 618   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 619   1        {
 620   2          if (g_dq_fs_rfid[i].index == 0xFF)
 621   2            break;
 622   2        }
 623   1        if (i < MMI_DQ_FS_RFID_MAX_NUM)
 624   1        {
 625   2          g_dq_fs_rfid[i].index = i;
 626   2          g_dq_fs_rfid[i].flag = type;
 627   2          for (j = 0; j < RFID_SEC_DATA_LEN; j++)
 628   2          {
 629   3            g_dq_fs_rfid[i].sec_data[j] = sec_data[j];
 630   3          }
 631   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_
             -RFID_MAX_NUM);
 632   2        }
 633   1        return RET_FAIL;
 634   1      }
 635          
 636          /*
 637          parameter: 
 638            none
 639          return :
 640            none
 641          */
 642          RET_VAL mmi_dq_fs_del_rfid(unsigned char rfid_index)
 643          {
 644   1        if (rfid_index < MMI_DQ_FS_RFID_MAX_NUM && g_dq_fs_rfid[rfid_index].index == rfid_index)
 645   1        {
 646   2          g_dq_fs_rfid[rfid_index].index = 0xFF;
 647   2          g_dq_fs_rfid[rfid_index].flag = FDS_USE_TYPE_INVALID;
 648   2          memset(g_dq_fs_rfid[rfid_index].sec_data, 0xFF, sizeof(g_dq_fs_rfid[rfid_index].sec_data));
 649   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_
             -RFID_MAX_NUM);
 650   2        }
 651   1        return RET_FAIL;
 652   1      }
 653          
 654          /*
 655          parameter: 
 656            none
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/05/2021 16:00:16 PAGE 12  

 657          return :
 658            none
 659          */
 660          RET_VAL mmi_dq_fs_clr_rfid(void)
 661          {
 662   1        unsigned char i = 0;
 663   1      
 664   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 665   1        {
 666   2          g_dq_fs_rfid[i].flag = FDS_USE_TYPE_INVALID;
 667   2          g_dq_fs_rfid[i].index = 0xFF;
 668   2          memset(g_dq_fs_rfid[i].sec_data, 0xFF, sizeof(g_dq_fs_rfid[i].sec_data));
 669   2        }
 670   1        return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_R
             -FID_MAX_NUM);
 671   1      }
 672          
 673          #endif
 674          
 675          /*
 676          parameter: 
 677            none
 678          return :
 679            none
 680          */
 681          RET_VAL mmi_dq_fs_set_open_mode(sys_open_mode mode)
 682          {
 683   1        if (g_dq_fs_init_set.open_mode == mode)
 684   1          return RET_SUCESS;
 685   1      
 686   1        g_dq_fs_init_set.open_mode = mode;
 687   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 688   1      }
 689          /*
 690          parameter: 
 691            none
 692          return :
 693            none
 694          */
 695          sys_open_mode mmi_dq_fs_get_open_mode(void)
 696          {
 697   1        return g_dq_fs_init_set.open_mode;
 698   1      }
 699          
 700          /*
 701          parameter: 
 702            none
 703          return :
 704            none
 705          */
 706          RET_VAL mmi_dq_fs_set_pro_sound(unsigned char flag)
 707          {
 708   1        if (g_dq_fs_init_set.open_pro_sound == flag)
 709   1          return RET_SUCESS;
 710   1      
 711   1        g_dq_fs_init_set.open_pro_sound = flag;
 712   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 713   1      }
 714          
 715          /*
 716          parameter: 
 717            none
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/05/2021 16:00:16 PAGE 13  

 718          return :
 719            none
 720          */
 721          unsigned char mmi_dq_fs_get_pro_sound_state(void)
 722          {
 723   1        return g_dq_fs_init_set.open_pro_sound;
 724   1      }
 725          
 726          /*
 727          parameter: 
 728            none
 729          return :
 730            none
 731          */
 732          unsigned char mmi_dq_fs_get_init_flag(void)
 733          {
 734   1        return g_dq_fs_init_set.init_flag;
 735   1      }
 736          
 737          /*
 738          parameter: 
 739            none
 740          return :
 741            none
 742          */
 743          RET_VAL mmi_dq_fs_set_init_flag(unsigned char flag)
 744          {
 745   1        g_dq_fs_init_set.init_flag = flag;
 746   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 747   1      }
 748          
 749          /*
 750          parameter: 
 751            none
 752          return :
 753            none
 754          */
 755          RET_VAL mmi_dq_fs_set_factory_flag(unsigned char flag)
 756          {
 757   1        g_dq_fs_init_set.factory_flag = flag;
 758   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 759   1      }
 760          
 761          /*
 762          parameter: 
 763            none
 764          return :
 765            none
 766          */
 767          unsigned char mmi_dq_fs_get_factory_flag(void)
 768          {
 769   1        return g_dq_fs_init_set.factory_flag;
 770   1      }
 771          
 772          /*
 773          parameter: 
 774            none
 775          return :
 776            none
 777          */
 778          unsigned char mmi_dq_fs_get_admin_status(void)
 779          {
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/05/2021 16:00:16 PAGE 14  

 780   1        return g_dq_fs_init_set.admin_status;
 781   1      }
 782          
 783          /*
 784          parameter: 
 785            none
 786          return :
 787            none
 788          */
 789          RET_VAL mmi_dq_fs_set_admin_status(unsigned char status)
 790          {
 791   1        g_dq_fs_init_set.admin_status = status;
 792   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 793   1      }
 794          
 795          /*
 796          parameter: 
 797            none
 798          return :
 799            none
 800          */
 801          RET_VAL mmi_dq_fs_set_wifi_setting(unsigned char flag)
 802          {
 803   1        g_dq_fs_init_set.wifi_flag = flag;
 804   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 805   1      }
 806          
 807          /*
 808          parameter: 
 809            none
 810          return :
 811            none
 812          */
 813          unsigned char mmi_dq_fs_get_wifi_setting(void)
 814          {
 815   1        return g_dq_fs_init_set.wifi_flag;
 816   1      }
 817          
 818          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3490    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    744      68
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
