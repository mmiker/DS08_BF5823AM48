C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MMI_FS
OBJECT MODULE PLACED IN .\output\mmi_fs.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE mmi_src\mmi_fs.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;.\
                    -Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd_rfi
                    -d;.\mmi_inc) DEBUG PRINT(.\list\mmi_fs.lst) TABS(2) OBJECT(.\output\mmi_fs.obj)

line level    source

   1          #ifndef __MMI_FS_C__
   2          #define __MMI_FS_C__
   3          
   4          #include "mmi_fs.h"
   5          #include "mmi_sys.h"
   6          #include "mcu02_sfr.h"
   7          #include "mcu02_eeprom.h"
   8          #include "string.h"
   9          #include <stdio.h>
  10          #include "dqiot_drv.h"
  11          
  12          #include "mmi_fps.h"
  13          #include "mmi_ms.h"
  14          #include "dq_otp.h"
  15          #ifdef __LOCK_VIRTUAL_PASSWORD__
              #include "dq_sdk_main.h"
              #endif
  18          #ifdef __LOCK_DECODE_SUPPORT__
  19          #include "mmi_decode.h"
  20          #endif
  21          
  22          unsigned char get_index = 0xff;
  23          
  24          mmi_fs_setting data g_dq_fs_init_set;
  25          
  26          #define MMI_DQ_FS_PWD_MAX_NUM 100
  27          mmi_fs_pwd g_dq_fs_pwd[MMI_DQ_FS_PWD_MAX_NUM];
  28          
  29          #if defined(__LOCK_FP_SUPPORT__)
              #define MMI_DQ_FS_FP_MAX_NUM 30
              mmi_fs_fp g_dq_fs_fp[MMI_DQ_FS_FP_MAX_NUM];
              #endif
  33          
  34          #ifdef __LOCK_RFID_CARD_SUPPORT__
  35          #define MMI_DQ_FS_RFID_MAX_NUM 10
  36          mmi_fs_rfid g_dq_fs_rfid[MMI_DQ_FS_RFID_MAX_NUM];
  37          #endif
  38          
  39          #define FP_ADMIN_NUM 2
  40          #define FP_110_NUM 3
  41          
  42          #define PWD_ADMIN_NUM 1
  43          #define PWD_110_NUM 1
  44          
  45          static void mmi_dq_fds_read(mid_fds_file_id file, uint8_t *r_data, uint16_t r_size)
  46          {
  47   1        uint16_t i;
  48   1      
  49   1        switch (file)
  50   1        {
  51   2        case MID_FDS_FILE_SET:
  52   2          eeprom_select(0);
  53   2          for (i = 0; i < r_size; i++)
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 2   

  54   2          {
  55   3            r_data[i] = eeprom_read_byte(0, i); //读第一页
  56   3          }
  57   2          break;
  58   2        case MID_FDS_FILE_PWD:
  59   2          eeprom_select(0);
  60   2          for (i = 0; i < r_size; i++)
  61   2          {
  62   3            r_data[i] = eeprom_read_byte(0, i + 24); //读第一页
  63   3          }
  64   2          break;
  65   2      #ifdef __LOCK_FP_SUPPORT__
                case MID_FDS_FILE_FP:
                  eeprom_select(1);
                  eeprom_nvr_read_page(r_data, 0, 0, r_size);
                  break;
              #endif
  71   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
  72   2        case MID_FDS_FILE_RF:
  73   2          eeprom_select(1);
  74   2          eeprom_nvr_read_page(r_data, 1, 0, r_size);
  75   2          break;
  76   2      #endif
  77   2      #ifdef __LOCK_DECODE_SUPPORT__
  78   2        case MID_FDS_FILE_DECODE:
  79   2          eeprom_select(0);
  80   2          for (i = 0; i < r_size; i++)
  81   2          {
  82   3            r_data[i] = eeprom_read_byte(0, i + 532); //读第一页
  83   3          }
  84   2          break;
  85   2      #endif
  86   2        default:
  87   2          break;
  88   2        }
  89   1      }
  90          
  91          static RET_VAL mmi_dq_fds_write(mid_fds_file_id file, uint8_t *w_data, uint16_t w_size)
  92          {
  93   1        uint16_t i;
  94   1        ErrStatus ret;
  95   1        eeprom_erase_time(9);
  96   1        switch (file)
  97   1        {
  98   2        case MID_FDS_FILE_SET:
  99   2        {
 100   3          uint8_t *w_data2 = (uint8_t *)g_dq_fs_pwd;
 101   3          uint16_t w_size2 = sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_NUM;
 102   3          eeprom_select(0);
 103   3          eeprom_erase_page(0); //擦除1K
 104   3          for (i = 0; i < w_size; i++)
 105   3          {
 106   4            ret = eeprom_write_byte(0, i, w_data[i]); //读第一页
 107   4            if (ret == ERROR)
 108   4            {
 109   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 110   5              return RET_FAIL;
 111   5            }
 112   4          }
 113   3          for (i = 0; i < w_size2; i++)
 114   3          {
 115   4            ret = eeprom_write_byte(0, i + 24, w_data2[i]); //读第一页
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 3   

 116   4            if (ret == ERROR)
 117   4            {
 118   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 119   5              return RET_FAIL;
 120   5            }
 121   4          }
 122   3        }
 123   2        break;
 124   2        case MID_FDS_FILE_PWD:
 125   2        {
 126   3          uint8_t *w_data2 = (uint8_t *)&g_dq_fs_init_set;
 127   3          uint16_t w_size2 = sizeof(mmi_fs_setting);
 128   3          eeprom_select(0);
 129   3          eeprom_erase_page(0); //擦除1K
 130   3          for (i = 0; i < w_size2; i++)
 131   3          {
 132   4            ret = eeprom_write_byte(0, i, w_data2[i]); //读第一页
 133   4            if (ret == ERROR)
 134   4            {
 135   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 136   5              return RET_FAIL;
 137   5            }
 138   4          }
 139   3          for (i = 0; i < w_size; i++)
 140   3          {
 141   4            ret = eeprom_write_byte(0, i + 24, w_data[i]); //读第一页
 142   4            if (ret == ERROR)
 143   4            {
 144   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 145   5              return RET_FAIL;
 146   5            }
 147   4          }
 148   3        }
 149   2        break;
 150   2      #ifdef __LOCK_FP_SUPPORT__
                case MID_FDS_FILE_FP:
                  eeprom_select(1);
                  eeprom_erase_page(0); //擦除512byte
                  for (i = 0; i < w_size; i++)
                  {
                    ret = eeprom_write_byte(0, i, w_data[i]);
                    if (ret == ERROR)
                    {
                      //printf("mmi_dq_fds_write  error  %d\n",i);
                      return RET_FAIL;
                    }
                  }
                  break;
              #endif
 165   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 166   2        case MID_FDS_FILE_RF:
 167   2          eeprom_select(1);
 168   2          eeprom_erase_page(1); //擦除512byte
 169   2          for (i = 0; i < w_size; i++)
 170   2          {
 171   3            ret = eeprom_write_byte(1, i, w_data[i]);
 172   3            if (ret == ERROR)
 173   3            {
 174   4              //printf("mmi_dq_fds_write  error  %d\n",i);
 175   4              return RET_FAIL;
 176   4            }
 177   3          }
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 4   

 178   2          break;
 179   2      #endif
 180   2      #ifdef __LOCK_DECODE_SUPPORT__
 181   2        case MID_FDS_FILE_DECODE:
 182   2        {
 183   3          uint8_t *w_data2 = (uint8_t *)&g_dq_fs_init_set;
 184   3          uint16_t w_size2 = sizeof(mmi_fs_setting);
 185   3          uint8_t *w_data3 = (uint8_t *)g_dq_fs_pwd;
 186   3          uint16_t w_size3 = sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_NUM;
 187   3          eeprom_select(0);
 188   3          eeprom_erase_page(0); //擦除1K
 189   3          for (i = 0; i < w_size2; i++)
 190   3          {
 191   4            ret = eeprom_write_byte(0, i, w_data2[i]); //读第一页
 192   4            if (ret == ERROR)
 193   4            {
 194   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 195   5              return RET_FAIL;
 196   5            }
 197   4          }
 198   3          for (i = 0; i < w_size3; i++)
 199   3          {
 200   4            ret = eeprom_write_byte(0, i + 24, w_data3[i]); //读第一页
 201   4            if (ret == ERROR)
 202   4            {
 203   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 204   5              return RET_FAIL;
 205   5            }
 206   4          }
 207   3          for (i = 0; i < w_size; i++)
 208   3          {
 209   4            ret = eeprom_write_byte(0, i + 532, w_data[i]); //读第一页
 210   4            if (ret == ERROR)
 211   4            {
 212   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 213   5              return RET_FAIL;
 214   5            }
 215   4          }
 216   3        }
 217   2        break;
 218   2      #endif
 219   2        default:
 220   2          return RET_FAIL;
 221   2        }
 222   1        //printf("mmi_dq_fds_write  suc\n");
 223   1        return RET_SUCESS;
 224   1      }
 225          
 226          /*
 227          parameter: 
 228            none
 229          return :
 230            none
 231          */
 232          void mmi_dq_fs_init(void)
 233          {
 234   1        mmi_dq_fds_read(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 235   1        if (FDS_INIT_LOCK_SUC == g_dq_fs_init_set.init_flag || FDS_INIT_APP_SUC == g_dq_fs_init_set.init_flag)
 236   1        {
 237   2          unsigned char i = 0;
 238   2          mmi_dq_fds_read(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_N
             -UM);
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 5   

 239   2      #ifdef __LOCK_FP_SUPPORT__
                  mmi_dq_fds_read(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM);
              #endif
 242   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 243   2          mmi_dq_fds_read(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MAX
             -_NUM);
 244   2      #endif
 245   2          if (g_dq_fs_init_set.admin_status > 0)
 246   2          {
 247   3            for (; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 248   3            {
 249   4              if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
 250   4                break;
 251   4            }
 252   3            if (i >= MMI_DQ_FS_PWD_MAX_NUM)
 253   3            {
 254   4              g_dq_fs_init_set.admin_status = 0;
 255   4              mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 256   4            }
 257   3          }
 258   2        }
 259   1        else
 260   1        {
 261   2          //printf("mmi_dq_fs_init init error");
 262   2          memset(g_dq_fs_pwd, 0xFF, sizeof(g_dq_fs_pwd));
 263   2          mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_
             -NUM);
 264   2      
 265   2      #ifdef __LOCK_FP_SUPPORT__
                  memset(g_dq_fs_fp, 0xFF, sizeof(g_dq_fs_fp));
                  mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM)
             -;
              
                  mmi_dq_fp_empty();
              #endif
 271   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 272   2          memset(g_dq_fs_rfid, 0xFF, sizeof(g_dq_fs_rfid));
 273   2          mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MA
             -X_NUM);
 274   2      #endif
 275   2          g_dq_fs_init_set.init_flag = FDS_INIT_LOCK_SUC;
 276   2          g_dq_fs_init_set.open_pro_sound = 1;
 277   2          g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 278   2          g_dq_fs_init_set.admin_status = 0;
 279   2          g_dq_fs_init_set.factory_flag = 0;
 280   2          g_dq_fs_init_set.wifi_flag = 0;
 281   2          mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 282   2        }
 283   1      }
 284          
 285          /**
 286            * @brief  手动初始化
 287            * @param  none
 288            * @return none
 289            * @note   none
 290            * @see    none
 291            */
 292          RET_VAL mmi_dq_fs_clr_set(void)
 293          {
 294   1        g_dq_fs_init_set.open_pro_sound = 1;
 295   1        g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 296   1      
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 6   

 297   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 298   1      }
 299          
 300          /**
 301            * @brief  复位初始化
 302            * @param  none
 303            * @return none
 304            * @note   none
 305            * @see    none
 306            */
 307          RET_VAL mmi_dq_fs_reset(void)
 308          {
 309   1        memset(g_dq_fs_pwd, 0xFF, sizeof(g_dq_fs_pwd));
 310   1        mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_N
             -UM);
 311   1      #ifdef __LOCK_FP_SUPPORT__
                memset(g_dq_fs_fp, 0xFF, sizeof(g_dq_fs_fp));
                mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM);
              
                mmi_dq_fp_empty();
              #endif
 317   1      #ifdef __LOCK_RFID_CARD_SUPPORT__
 318   1        memset(g_dq_fs_rfid, 0xFF, sizeof(g_dq_fs_rfid));
 319   1        mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MAX
             -_NUM);
 320   1      #endif
 321   1        g_dq_fs_init_set.init_flag = FDS_INIT_LOCK_SUC;
 322   1        g_dq_fs_init_set.open_pro_sound = 1;
 323   1        g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 324   1        g_dq_fs_init_set.admin_status = 0;
 325   1        g_dq_fs_init_set.wifi_flag = 0;
 326   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 327   1      }
 328          
 329          /*
 330          parameter: 
 331            none
 332          return :
 333            none
 334          */
 335          void mmi_dq_fs_pwd_string_to_byte(unsigned char *input_pwd, unsigned char pwd_len, unsigned char *output_p
             -wd)
 336          {
 337   1        unsigned char i = 0;
 338   1        unsigned char bit_l = 0;
 339   1        unsigned char bit_h = 0;
 340   1      
 341   1        for (i = 0; i < pwd_len; i++)
 342   1        {
 343   2          bit_l = *(input_pwd + i) & 0x0F;
 344   2          i++;
 345   2          if (i < pwd_len)
 346   2            bit_h = *(input_pwd + i) & 0x0F;
 347   2          else
 348   2            bit_h = 0xF;
 349   2          *output_pwd++ = bit_l << 4 | bit_h;
 350   2        }
 351   1        return;
 352   1      }
 353          /*
 354          parameter: 
 355            none
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 7   

 356          return :
 357            none
 358          */
 359          unsigned char mmi_dq_fs_pwd_byte_to_string(unsigned char *input_pwd, unsigned char *output_pwd)
 360          {
 361   1        unsigned char i = 0;
 362   1        unsigned char pwd = 0;
 363   1        unsigned char len = 0;
 364   1        for (i = 0; i < 4; i++)
 365   1        {
 366   2          pwd = *(input_pwd + i);
 367   2          if (pwd == 0xFF)
 368   2            break;
 369   2          else
 370   2          {
 371   3            *output_pwd++ = (pwd & 0xF0) >> 4;
 372   3            len++;
 373   3          }
 374   2          if ((pwd & 0x0F) == 0x0F)
 375   2            break;
 376   2          else
 377   2          {
 378   3            *output_pwd++ = pwd & 0x0F;
 379   3            len++;
 380   3          }
 381   2        }
 382   1        return len;
 383   1      }
 384          
 385          /*
 386          parameter: 
 387            none
 388          return :
 389            none
 390          */
 391          unsigned char mmi_dq_fs_get_pwd_unuse_index(void)
 392          {
 393   1        unsigned char i = PWD_ADMIN_NUM;
 394   1      #ifdef __LOCK_110_SUPPORT__
 395   1        i += PWD_110_NUM;
 396   1      #endif
 397   1        for (; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 398   1        {
 399   2          if (g_dq_fs_pwd[i].flag == 0xFF)
 400   2            break;
 401   2        }
 402   1      
 403   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 404   1          return i;
 405   1        else
 406   1          return 0xFF;
 407   1      }
 408          
 409          /*
 410          parameter: 
 411            none
 412          return :
 413            none
 414          */
 415          unsigned char mmi_dq_fs_check_input_pwd(unsigned char *input_pwd, unsigned char len, fds_use_type type)
 416          {
 417   1        unsigned char i = 0;
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 8   

 418   1        unsigned char k = 0;
 419   1        unsigned char password[4];
 420   1        unsigned char ret_val = 0xFF;
 421   1      
 422   1        memset(password, 0xFF, sizeof(password));
 423   1        mmi_dq_fs_pwd_string_to_byte(input_pwd, len, password);
 424   1      
 425   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 426   1        {
 427   2          if (g_dq_fs_pwd[i].flag != 0xFF)
 428   2          {
 429   3            for (k = 0; k < 4; k++)
 430   3            {
 431   4              if (password[k] != g_dq_fs_pwd[i].key_pwd[k])
 432   4                break;
 433   4            }
 434   3            if (k == 4)
 435   3            {
 436   4              break;
 437   4            }
 438   3          }
 439   2        }
 440   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 441   1        {
 442   2          if ((g_dq_fs_pwd[i].flag == type) || (type == FDS_USE_TYPE_ALL))
 443   2            ret_val = i;
 444   2          else
 445   2            ret_val = 0xFF;
 446   2        }
 447   1        else
 448   1          ret_val = 0xFF;
 449   1      
 450   1        return ret_val;
 451   1      }
 452          
 453          /*
 454          parameter: 
 455            none
 456          return :
 457            none
 458          */
 459          unsigned char mmi_dq_fs_check_input_pwd_for_open(unsigned char *input_pwd, unsigned char len)
 460          {
 461   1        unsigned char i = 0, n = 0;
 462   1        unsigned char k, j;
 463   1        unsigned char password[8];
 464   1        unsigned char passlen = 0;
 465   1        unsigned char ret_val = 0xFF;
 466   1      
 467   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 468   1        {
 469   2          if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_INVALID)
 470   2            continue;
 471   2          memset(password, 0xFF, sizeof(password));
 472   2          passlen = mmi_dq_fs_pwd_byte_to_string(g_dq_fs_pwd[i].key_pwd, password);
 473   2          for (k = 0; k + passlen <= len; k++)
 474   2          {
 475   3            for (j = 0; j < passlen; j++)
 476   3            {
 477   4              if (password[j] != input_pwd[k + j])
 478   4                break;
 479   4            }
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 9   

 480   3            if (j == passlen)
 481   3              break;
 482   3          }
 483   2          if (j == passlen)
 484   2            break;
 485   2        }
 486   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 487   1        {
 488   2          //printf("check input return i: %d",(unsigned int)i);
 489   2          get_index = i;
 490   2          return i;
 491   2        }
 492   1        else
 493   1        {
 494   2          unsigned char adminword[8];
 495   2          unsigned char checkCode_out[8];
 496   2          unsigned char pass = 0;
 497   2          memset(adminword, 0xFF, sizeof(adminword));
 498   2          passlen = mmi_dq_fs_pwd_byte_to_string(g_dq_fs_pwd[0].key_pwd, adminword);
 499   2          for (i = 0; i < 8; i++)
 500   2          {
 501   3            if (adminword[i] == 0xFF)
 502   3              adminword[i] = 0;
 503   3            else
 504   3              adminword[i] += '0';
 505   3      
 506   3            if (input_pwd[i] == 0xFF)
 507   3              password[i] = 0;
 508   3            else
 509   3              password[i] = input_pwd[i] + '0';
 510   3          }
 511   2          pass = dq_check_otp((char *)password, (char *)adminword, g_dq_fs_init_set.check_data, checkCode_out);
 512   2          if (pass > 0)
 513   2          {
 514   3            memcpy(g_dq_fs_init_set.check_data, checkCode_out, 8);
 515   3            mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 516   3            return 0xFE;
 517   3          }
 518   2        }
 519   1        //printf("check input return 0xFF");
 520   1        return 0xFF;
 521   1      }
 522          
 523          /*
 524          parameter: 
 525            none
 526          return :
 527            none
 528          */
 529          RET_VAL mmi_dq_fs_set_pwd(unsigned char *pwd, unsigned char pwd_size, fds_use_type type)
 530          {
 531   1        unsigned char i = 0;
 532   1        unsigned char password[4];
 533   1      
 534   1        if (type == FDS_USE_TYPE_ADMIN)
 535   1          i = 0;
 536   1      #ifdef __LOCK_110_SUPPORT__
 537   1        else if (type == FDS_USE_TYPE_110)
 538   1          i = 1;
 539   1      #endif
 540   1        else
 541   1        {
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 10  

 542   2      #ifdef __LOCK_110_SUPPORT__
 543   2          i = PWD_ADMIN_NUM + PWD_110_NUM;
 544   2      #else
                  i = PWD_ADMIN_NUM;
              #endif
 547   2          for (; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 548   2          {
 549   3            if (g_dq_fs_pwd[i].flag == 0xFF)
 550   3              break;
 551   3          }
 552   2        }
 553   1      
 554   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 555   1        {
 556   2          get_index = i;
 557   2          memset(password, 0xFF, sizeof(password));
 558   2          //g_dq_fs_pwd[i].index = i;
 559   2          mmi_dq_fs_pwd_string_to_byte(pwd, pwd_size, password);
 560   2          memcpy((char *)g_dq_fs_pwd[i].key_pwd, (const char *)password, 4);
 561   2          g_dq_fs_pwd[i].flag = type;
 562   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_P
             -WD_MAX_NUM);
 563   2        }
 564   1        return RET_FAIL;
 565   1      }
 566          
 567          /*
 568          parameter: 
 569            none
 570          return :
 571            none
 572          */
 573          RET_VAL mmi_dq_fs_del_pwd(unsigned char index, fds_use_type type)
 574          {
 575   1        if (index < MMI_DQ_FS_PWD_MAX_NUM && g_dq_fs_pwd[index].flag == type)
 576   1        {
 577   2          g_dq_fs_pwd[index].flag = FDS_USE_TYPE_INVALID;
 578   2          //g_dq_fs_pwd[index].index = 0xFF;
 579   2          memset(g_dq_fs_pwd[index].key_pwd, 0xFF, sizeof(g_dq_fs_pwd[index].key_pwd));
 580   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_P
             -WD_MAX_NUM);
 581   2        }
 582   1        return RET_FAIL;
 583   1      }
 584          
 585          /*
 586          parameter: 
 587            none
 588          return :
 589            none
 590          */
 591          RET_VAL mmi_dq_fs_clr_pwd(void)
 592          {
 593   1        unsigned char i = PWD_ADMIN_NUM;
 594   1      #ifdef __LOCK_110_SUPPORT__
 595   1        i += PWD_110_NUM;
 596   1      #endif
 597   1        for (; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 598   1        {
 599   2          if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_USER)
 600   2          {
 601   3            g_dq_fs_pwd[i].flag = FDS_USE_TYPE_INVALID;
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 11  

 602   3            //g_dq_fs_pwd[i].index = 0xFF;
 603   3            memset(g_dq_fs_pwd[i].key_pwd, 0xFF, sizeof(g_dq_fs_pwd[i].key_pwd));
 604   3          }
 605   2        }
 606   1        return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PW
             -D_MAX_NUM);
 607   1      }
 608          
 609          #if defined(__LOCK_DECODE_SUPPORT__)
 610          /**
 611            * @brief  解码记录flash
 612            * @param  type 用户类型
 613            * @return status
 614            * @note   none
 615            * @see    none
 616            */
 617          RET_VAL mmi_dq_fs_set_decode(fds_use_type type)
 618          {
 619   1        if (type == FDS_USE_TYPE_ADMIN)
 620   1          return mmi_dq_fds_write(MID_FDS_FILE_DECODE, (unsigned char *)&get_decode, sizeof(get_decode));
 621   1        else
 622   1          return RET_FAIL;
 623   1      }
 624          
 625          // unsigned char mmi_dq_fs_check_input_decode(unsigned char *input_pwd, unsigned char len, fds_use_type ty
             -pe)
 626          // {
 627          //  unsigned char i = 0;
 628          //  unsigned char k = 0;
 629          //  unsigned char decode[5];
 630          //  unsigned char ret_val = 0xFF;
 631          
 632          //  memset(decode, 0xFF, sizeof(decode));
 633          //  mmi_dq_fs_pwd_string_to_byte(input_pwd, len, decode);
 634          
 635          //  for (i = 0; i < MMI_DQ_FS_DECODE_MAX_NUM; i++)
 636          //  {
 637          //    if (g_dq_fs_decode[i].flag != 0xFF)
 638          //    {
 639          //      for (k = 0; k < 5; k++)
 640          //      {
 641          //        if (decode[k] != g_dq_fs_decode[i].decode[k])
 642          //          break;
 643          //      }
 644          //      if (k == 5)
 645          //      {
 646          //        break;
 647          //      }
 648          //    }
 649          //  }
 650          //  if (i < MMI_DQ_FS_DECODE_MAX_NUM)
 651          //  {
 652          //    if ((g_dq_fs_decode[i].flag == type) || (type == FDS_USE_TYPE_ADMIN))
 653          //      ret_val = i;
 654          //    else
 655          //      ret_val = 0xFF;
 656          //  }
 657          //  else
 658          //    ret_val = 0xFF;
 659          
 660          //  return ret_val;
 661          // }
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 12  

 662          
 663          // RET_VAL mmi_dq_fs_del_decode(unsigned char index, fds_use_type type)
 664          // {
 665          //  if (index < MMI_DQ_FS_DECODE_MAX_NUM && g_dq_fs_decode[index].flag == type)
 666          //  {
 667          //    g_dq_fs_decode[index].flag = FDS_USE_TYPE_INVALID;
 668          //    //g_dq_fs_pwd[index].index = 0xFF;
 669          //    memset(g_dq_fs_decode[index].decode, 0xFF, sizeof(g_dq_fs_decode[index].decode));
 670          //    return mmi_dq_fds_write(MID_FDS_FILE_DECODE, (unsigned char *)g_dq_fs_decode, sizeof(mmi_fs_decode) *
             - MMI_DQ_FS_DECODE_MAX_NUM);
 671          //  }
 672          //  return RET_FAIL;
 673          // }
 674          
 675          // RET_VAL mmi_dq_fs_clr_decode(void)
 676          // {
 677          //  unsigned char i = 0;
 678          
 679          //  for (; i < MMI_DQ_FS_DECODE_MAX_NUM; i++)
 680          //  {
 681          //    if (g_dq_fs_decode[i].flag == FDS_USE_TYPE_ADMIN)
 682          //    {
 683          //      g_dq_fs_decode[i].flag = FDS_USE_TYPE_INVALID;
 684          //      // g_dq_fs_pwd[i].index = 0xFF;
 685          //      memset(g_dq_fs_decode[i].decode, 0xFF, sizeof(g_dq_fs_decode[i].decode));
 686          //    }
 687          //  }
 688          
 689          //  return mmi_dq_fds_write(MID_FDS_FILE_DECODE, (unsigned char *)g_dq_fs_decode, sizeof(mmi_fs_decode) * 
             -MMI_DQ_FS_DECODE_MAX_NUM);
 690          // }
 691          
 692          #endif
 693          
 694          #if defined(__LOCK_FP_SUPPORT__)
              /*
              parameter: 
                none
              return :
                none
              */
              unsigned char mmi_dq_fs_get_fp_unuse_index(void)
              {
                unsigned char i = FP_ADMIN_NUM;
              #ifdef __LOCK_110_SUPPORT__
                i += FP_110_NUM;
              #endif
                for (; i < MMI_DQ_FS_FP_MAX_NUM; i++)
                {
                  if (g_dq_fs_fp[i].fp_index == 0xFF)
                    break;
                }
                if (i >= MMI_DQ_FS_FP_MAX_NUM)
                  return 0xFF;
                return i;
              }
              
              #ifdef __LOCK_110_SUPPORT__
              /*
              parameter: 
                none
              return :
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 13  

                none
              */
              unsigned char mmi_dq_fs_get_fp_110_unuse_index(void)
              {
                unsigned char i = FP_ADMIN_NUM;
                unsigned char j = 0;
              
                for (; j < FP_110_NUM; j++)
                {
                  if (g_dq_fs_fp[i + j].fp_index == 0xFF)
                    break;
                }
                if (j >= FP_110_NUM)
                  return 0xFF;
                return i + j;
              }
              #endif
              
              /*
              parameter: 
                none
              return :
                none
              */
              RET_VAL mmi_dq_fs_check_fp(unsigned char fp_index, fds_use_type type)
              {
                if ((fp_index < MMI_DQ_FS_FP_MAX_NUM) && (g_dq_fs_fp[fp_index].fp_index == fp_index) && ((g_dq_fs_fp[fp_i
             -ndex].flag == type) || (type == FDS_USE_TYPE_ALL)))
                  return RET_SUCESS;
                else
                  return RET_FAIL;
              }
              
              /*
              parameter: 
                none
              return :
                none
              */
              RET_VAL mmi_dq_fs_set_fp(unsigned char fs_index, fds_use_type type)
              {
                g_dq_fs_fp[fs_index].fp_index = fs_index;
                g_dq_fs_fp[fs_index].flag = type;
                return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MA
             -X_NUM);
              }
              
              /*
              parameter: 
                none
              return :
                none
              */
              RET_VAL mmi_dq_fs_del_fp(unsigned char fp_index, fds_use_type type)
              {
                if (mmi_dq_fs_check_fp(fp_index, type) == RET_SUCESS)
                {
                  g_dq_fs_fp[fp_index].flag = FDS_USE_TYPE_INVALID;
                  g_dq_fs_fp[fp_index].fp_index = 0xFF;
                  return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_M
             -AX_NUM);
                }
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 14  

                return RET_FAIL;
              }
              
              /*
              parameter: 
                none
              return :
                none
              */
              RET_VAL mmi_dq_fs_clr_fp(void)
              {
                unsigned char i = FP_ADMIN_NUM;
                unsigned short fp_ret = 0;
              #ifdef __LOCK_110_SUPPORT__
                i += FP_110_NUM;
              #endif
                for (; i < MMI_DQ_FS_FP_MAX_NUM; i++)
                {
                  if (g_dq_fs_fp[i].fp_index != 0xFF)
                  {
                    fp_ret = mmi_dq_fp_delete(g_dq_fs_fp[i].fp_index);
                    if (fp_ret == 0)
                    {
                      g_dq_fs_fp[i].flag = FDS_USE_TYPE_INVALID;
                      g_dq_fs_fp[i].fp_index = 0xFF;
                    }
                  }
                }
                return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MA
             -X_NUM);
              }
              
              #endif
 813          
 814          #ifdef __LOCK_RFID_CARD_SUPPORT__
 815          
 816          /*
 817          parameter: 
 818            none
 819          return :
 820            none
 821          */
 822          unsigned char mmi_dq_fs_get_rfid_unuse_index(void)
 823          {
 824   1        unsigned char i = 0;
 825   1      
 826   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 827   1        {
 828   2          if (g_dq_fs_rfid[i].index == 0xFF)
 829   2            break;
 830   2        }
 831   1      
 832   1        if (i >= MMI_DQ_FS_RFID_MAX_NUM)
 833   1          return 0xFF;
 834   1        return i;
 835   1      }
 836          
 837          /*
 838          parameter: 
 839            none
 840          return :
 841            none
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 15  

 842          */
 843          unsigned char mmi_dq_fs_check_rfid(unsigned char *sec_data, fds_use_type type)
 844          {
 845   1        unsigned char i = 0, j = 0;
 846   1      
 847   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 848   1        {
 849   2          for (j = 0; j < RFID_SEC_DATA_LEN; j++)
 850   2          {
 851   3            if (g_dq_fs_rfid[i].sec_data[j] != sec_data[j])
 852   3              break;
 853   3          }
 854   2          if (j == RFID_SEC_DATA_LEN)
 855   2            break;
 856   2        }
 857   1        if (i < MMI_DQ_FS_RFID_MAX_NUM && ((g_dq_fs_rfid[i].flag == type) || (type == FDS_USE_TYPE_ALL)))
 858   1        {
 859   2          return i;
 860   2        }
 861   1        else
 862   1        {
 863   2          return 0xFF;
 864   2        }
 865   1      }
 866          
 867          /*
 868          parameter: 
 869            none
 870          return :
 871            none
 872          */
 873          RET_VAL mmi_dq_fs_set_rfid(unsigned char *sec_data, fds_use_type type)
 874          {
 875   1        unsigned char i = 0, j = 0;
 876   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 877   1        {
 878   2          if (g_dq_fs_rfid[i].index == 0xFF)
 879   2            break;
 880   2        }
 881   1        if (i < MMI_DQ_FS_RFID_MAX_NUM)
 882   1        {
 883   2          get_index = i;
 884   2          g_dq_fs_rfid[i].index = i;
 885   2          g_dq_fs_rfid[i].flag = type;
 886   2          for (j = 0; j < RFID_SEC_DATA_LEN; j++)
 887   2          {
 888   3            g_dq_fs_rfid[i].sec_data[j] = sec_data[j];
 889   3          }
 890   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_
             -RFID_MAX_NUM);
 891   2        }
 892   1        return RET_FAIL;
 893   1      }
 894          
 895          /*
 896          parameter: 
 897            none
 898          return :
 899            none
 900          */
 901          RET_VAL mmi_dq_fs_del_rfid(unsigned char rfid_index)
 902          {
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 16  

 903   1        if (rfid_index < MMI_DQ_FS_RFID_MAX_NUM && g_dq_fs_rfid[rfid_index].index == rfid_index)
 904   1        {
 905   2          g_dq_fs_rfid[rfid_index].index = 0xFF;
 906   2          g_dq_fs_rfid[rfid_index].flag = FDS_USE_TYPE_INVALID;
 907   2          memset(g_dq_fs_rfid[rfid_index].sec_data, 0xFF, sizeof(g_dq_fs_rfid[rfid_index].sec_data));
 908   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_
             -RFID_MAX_NUM);
 909   2        }
 910   1        return RET_FAIL;
 911   1      }
 912          
 913          /*
 914          parameter: 
 915            none
 916          return :
 917            none
 918          */
 919          RET_VAL mmi_dq_fs_clr_rfid(void)
 920          {
 921   1        unsigned char i = 0;
 922   1      
 923   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 924   1        {
 925   2          g_dq_fs_rfid[i].flag = FDS_USE_TYPE_INVALID;
 926   2          g_dq_fs_rfid[i].index = 0xFF;
 927   2          memset(g_dq_fs_rfid[i].sec_data, 0xFF, sizeof(g_dq_fs_rfid[i].sec_data));
 928   2        }
 929   1        return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_R
             -FID_MAX_NUM);
 930   1      }
 931          
 932          #endif
 933          
 934          #ifdef __LOCK_DECODE_SUPPORT__
 935          /**
 936            * @brief  检查发flash是否为空
 937            * @param  none
 938            * @return status
 939            * @note   none
 940            * @see    none
 941            */
 942          unsigned char mmi_dq_fs_get_decode_unuse_index(void)
 943          {
 944   1        unsigned char i;
 945   1        unsigned char getdata[66];
 946   1      
 947   1        memset(&getdata, 0xff, sizeof(getdata));
 948   1        mmi_dq_fds_read(MID_FDS_FILE_DECODE, getdata, 66);
 949   1      
 950   1        dqiot_drv_uart0A_init();
 951   1        for (i = 0; i < 66; i++)
 952   1          printf("getdata is %d\n", (int)getdata[i]);
 953   1        dqiot_drv_uart0B_init();
 954   1      
 955   1        for (i = 0; i < 66; i++)
 956   1        {
 957   2          if (getdata[i] == 0xFF)
 958   2            return 0;
 959   2        }
 960   1      
 961   1        return 0xFF;
 962   1      }
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 17  

 963          #endif
 964          
 965          /*
 966          parameter: 
 967            none
 968          return :
 969            none
 970          */
 971          RET_VAL mmi_dq_fs_set_open_mode(sys_open_mode mode)
 972          {
 973   1        if (g_dq_fs_init_set.open_mode == mode)
 974   1          return RET_SUCESS;
 975   1      
 976   1        g_dq_fs_init_set.open_mode = mode;
 977   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 978   1      }
 979          /*
 980          parameter: 
 981            none
 982          return :
 983            none
 984          */
 985          sys_open_mode mmi_dq_fs_get_open_mode(void)
 986          {
 987   1        return g_dq_fs_init_set.open_mode;
 988   1      }
 989          
 990          /*
 991          parameter: 
 992            none
 993          return :
 994            none
 995          */
 996          RET_VAL mmi_dq_fs_set_pro_sound(unsigned char flag)
 997          {
 998   1        if (g_dq_fs_init_set.open_pro_sound == flag)
 999   1          return RET_SUCESS;
1000   1      
1001   1        g_dq_fs_init_set.open_pro_sound = flag;
1002   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
1003   1      }
1004          
1005          /*
1006          parameter: 
1007            none
1008          return :
1009            none
1010          */
1011          unsigned char mmi_dq_fs_get_pro_sound_state(void)
1012          {
1013   1        return g_dq_fs_init_set.open_pro_sound;
1014   1      }
1015          
1016          /*
1017          parameter: 
1018            none
1019          return :
1020            none
1021          */
1022          unsigned char mmi_dq_fs_get_init_flag(void)
1023          {
1024   1        return g_dq_fs_init_set.init_flag;
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 18  

1025   1      }
1026          
1027          /*
1028          parameter: 
1029            none
1030          return :
1031            none
1032          */
1033          RET_VAL mmi_dq_fs_set_init_flag(unsigned char flag)
1034          {
1035   1        g_dq_fs_init_set.init_flag = flag;
1036   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
1037   1      }
1038          
1039          /*
1040          parameter: 
1041            none
1042          return :
1043            none
1044          */
1045          RET_VAL mmi_dq_fs_set_factory_flag(unsigned char flag)
1046          {
1047   1        g_dq_fs_init_set.factory_flag = flag;
1048   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
1049   1      }
1050          
1051          /*
1052          parameter: 
1053            none
1054          return :
1055            none
1056          */
1057          unsigned char mmi_dq_fs_get_factory_flag(void)
1058          {
1059   1        return g_dq_fs_init_set.factory_flag;
1060   1      }
1061          
1062          /*
1063          parameter: 
1064            none
1065          return :
1066            none
1067          */
1068          unsigned char mmi_dq_fs_get_admin_status(void)
1069          {
1070   1        return g_dq_fs_init_set.admin_status;
1071   1      }
1072          
1073          /*
1074          parameter: 
1075            none
1076          return :
1077            none
1078          */
1079          RET_VAL mmi_dq_fs_set_admin_status(unsigned char status)
1080          {
1081   1        g_dq_fs_init_set.admin_status = status;
1082   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
1083   1      }
1084          
1085          #if 0
              /*
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 19  

              parameter: 
                none
              return :
                none
              */
              RET_VAL mmi_dq_fs_set_wifi_setting(unsigned char flag)
              {
                g_dq_fs_init_set.wifi_flag = flag;
                return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
              }
              
              /*
              parameter: 
                none
              return :
                none
              */
              unsigned char mmi_dq_fs_get_wifi_setting(void)
              {
                return g_dq_fs_init_set.wifi_flag;
              }
              #endif
1109          
1110          /*
1111          parameter: 
1112            none
1113          return :
1114            none
1115          */
1116          RET_VAL mmi_dq_fs_set_business_flag(unsigned char flag)
1117          {
1118   1      #if 1
1119   1        if (flag != g_dq_fs_init_set.business_flag)
1120   1        {
1121   2          g_dq_fs_init_set.business_flag = flag;
1122   2          return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
1123   2        }
1124   1      #else
                g_dq_fs_init_set.business_flag = flag;
              #endif
1127   1        return RET_SUCESS;
1128   1      }
1129          
1130          /*
1131          parameter: 
1132            none
1133          return :
1134            none
1135          */
1136          unsigned char mmi_dq_fs_get_business_flag(void)
1137          {
1138   1        return g_dq_fs_init_set.business_flag;
1139   1      }
1140          
1141          /************************************************************************************
1142           *                     Own function                     *
1143           ************************************************************************************/
1144          #ifdef __LOCK_VIRTUAL_PASSWORD__
              #ifdef __LOCK_VIRTUAL_PASSWORD__
              uint8_t input_empty_pwd_len = 0;
              unsigned char mmi_dq_fs_check_input_pwd_from_app(unsigned char *input_pwd, unsigned char len)
              {
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 20  

                unsigned char ret_val = 0xFF;
                unsigned char admin_pwd[4];
                unsigned char admin_password[8];
                uint8_t admin_len = 0;
                uint8_t i, k;
              
              #ifdef __LOCK_USE_MALLOC__
                uint8_t ret;
                g_dq_fs_pwd = (mmi_fs_pwd *)mmi_dq_fs_get_storage(DQ_FS_MEM_PWD, &ret);
              #endif
              
                memset(admin_password, 0xFF, 8);
                for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
                {
                  if (g_dq_fs_pwd[i].flag != 0xFF && g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
                  {
                    for (k = 0; k < 4; k++)
                    {
                      admin_pwd[k] = g_dq_fs_pwd[i].key_pwd[k];
                    }
                    break;
                  }
                }
              #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_PWD, (void **)&g_dq_fs_pwd);
              #endif
              
                mmi_dq_fs_pwd_byte_to_string(admin_pwd, admin_password);
                for (i = 0; i < 8; i++)
                {
                  if (admin_password[i] == 0xFF)
                    break;
                }
                admin_len = i;
                if (len >= admin_len)
                {
                  for (i = 0; i <= len - admin_len; i++)
                  {
                    for (k = 0; k < admin_len; k++)
                    {
                      if (input_pwd[i + k] != admin_password[k])
                        break;
                    }
                    if (k == admin_len)
                    {
                      // dq_otp_add_temp_open_log(0, DQ_OPEN_LOG_ADMIN_PASSWORD, admin_pwd, 4);
                      // mmi_dq_fs_check_input_pwd_from_app_cb(1);
                      return 0;
                    }
                  }
                }
              
                if (len == 8)
                  input_empty_pwd_len = 1;
                else
                  input_empty_pwd_len = 0;
              
                for (i = 9; i >= 6; i--)
                {
                  if (len < i)
                    continue;
                  for (k = 0; k <= len - i; k++)
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 21  

                  {
                    unsigned char password[5];
                    memset(password, 0xFF, sizeof(password));
                    // mmi_dq_fs_pwd_string_to_byte(input_pwd + k, i, password);
                    // ret_val = dq_otp_check_password_for_open(password, i);
                    if (ret_val != 0)
                    {
                      return 0;
                    }
                  }
                }
              
                //  mmi_dq_ms_idle_input_with_app_result(0xFF);
              
                return 0;
              }
              
              #else
              unsigned char mmi_dq_fs_check_input_pwd_from_app(unsigned char *input_pwd, unsigned char len)
              {
                unsigned char password[5];
                unsigned char ret_val = 0xFF;
              
                memset(password, 0xFF, sizeof(password));
                mmi_dq_fs_pwd_string_to_byte(input_pwd, len, password);
              
                if (len <= MMI_KEY_MAX_INPUT_NUM)
                {
                  ret_val = mmi_dq_fs_check_input_pwd(input_pwd, len, (fds_pwd_type)FDS_USE_TYPE_ADMIN);
                  if (ret_val != 0xFF)
                  {
                    ret_val = 1;
                    dq_otp_add_temp_open_log(0, DQ_OPEN_LOG_ADMIN_PASSWORD, password, 5);
                    mmi_dq_fs_check_input_pwd_from_app_cb(ret_val);
                    return 0;
                  }
                }
              
                dq_otp_check_password_for_open(password, len);
              
                return 0;
              }
              #endif
              
              //extern void mmi_dq_ms_idle_input_with_app_result(unsigned char ret_val);
              void mmi_dq_fs_check_input_pwd_from_app_cb(unsigned char ret_val)
              {
                if (ret_val != 1 && ret_val != 2 && ret_val != 4 && ret_val != 5 && ret_val != 6)
                  ret_val = 0xFF;
              
                if (ret_val != 0xFF && ret_val != 4 && ret_val != 6)
                  printfS("mmi_dq_fs_check_input_pwd_from_app", "right");
                else
                  printfS("mmi_dq_fs_check_input_pwd_from_app", "wrong");
              
              #ifdef __LOCK_VIRTUAL_PASSWORD__
              
                  // if (ret_val != 0xFF)
                  //  mmi_dq_ms_idle_input_with_app_result(ret_val);
              #else
                mmi_dq_ms_idle_input_with_app_result(ret_val);
              #endif
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/28/2021 10:45:55 PAGE 22  

              }
              
              unsigned char mmi_dq_fs_app_init_sucess(void)
              {
                if (g_dq_fs_init_set.init_flag == FDS_INIT_APP_SUC)
                  return 1;
                else
                  return 0;
              }
              
              #endif //__LOCK_VIRTUAL_PASSWORD__
1284          /************************************************************************************
1285           *                     End function                     *
1286           ************************************************************************************/
1287          
1288          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4072    ----
   CONSTANT SIZE    =     15    ----
   XDATA SIZE       =    641     175
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     15    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
