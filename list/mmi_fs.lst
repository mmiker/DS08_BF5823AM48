C51 COMPILER V9.59.0.0   MMI_FS                                                            03/12/2021 12:09:38 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MMI_FS
OBJECT MODULE PLACED IN .\output\mmi_fs.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE mmi_src\mmi_fs.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;.\
                    -Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd_rfi
                    -d;.\mmi_inc) DEBUG PRINT(.\list\mmi_fs.lst) TABS(2) OBJECT(.\output\mmi_fs.obj)

line level    source

   1          #ifndef __MMI_FS_C__
   2          #define __MMI_FS_C__
   3          
   4          #include "mmi_fs.h"
   5          #include "mmi_sys.h"
   6          #include "mcu02_sfr.h"
   7          #include "mcu02_eeprom.h"
   8          #include "string.h"
   9          // #include <stdio.h>
  10          
  11          #include "mmi_fps.h"
  12          #include "mmi_ms.h"
  13          #include "dq_otp.h"
  14          
  15          mmi_fs_setting data g_dq_fs_init_set;
  16          
  17          #define MMI_DQ_FS_PWD_MAX_NUM 100
  18          mmi_fs_pwd g_dq_fs_pwd[MMI_DQ_FS_PWD_MAX_NUM];
  19          
  20          #if defined(__LOCK_FP_SUPPORT__)
  21          #define MMI_DQ_FS_FP_MAX_NUM 30
  22          mmi_fs_fp g_dq_fs_fp[MMI_DQ_FS_FP_MAX_NUM];
  23          #endif
  24          
  25          #ifdef __LOCK_RFID_CARD_SUPPORT__
  26          #define MMI_DQ_FS_RFID_MAX_NUM 10
  27          mmi_fs_rfid g_dq_fs_rfid[MMI_DQ_FS_RFID_MAX_NUM];
  28          #endif
  29          
  30          #define FP_ADMIN_NUM 2
  31          #define FP_110_NUM 3
  32          
  33          #define PWD_ADMIN_NUM 1
  34          #define PWD_110_NUM 1
  35          
  36          static void mmi_dq_fds_read(mid_fds_file_id file, uint8_t *r_data, uint16_t r_size)
  37          {
  38   1        uint16_t i;
  39   1      
  40   1        switch (file)
  41   1        {
  42   2          case MID_FDS_FILE_SET:
  43   2            eeprom_select(0);
  44   2            for(i = 0; i < r_size; i++)
  45   2            {
  46   3              r_data[i] = eeprom_read_byte(0,i);//读第一页
  47   3            }
  48   2            break;
  49   2          case MID_FDS_FILE_PWD:
  50   2            eeprom_select(0);
  51   2            for(i = 0; i < r_size; i++)
  52   2            {
  53   3              r_data[i] = eeprom_read_byte(0,i+24);//读第一页
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/12/2021 12:09:38 PAGE 2   

  54   3            }
  55   2            break;
  56   2      #ifdef __LOCK_FP_SUPPORT__
  57   2        case MID_FDS_FILE_FP:
  58   2          eeprom_select(1);
  59   2          eeprom_nvr_read_page(r_data, 0, 0, r_size);
  60   2          break;
  61   2      #endif
  62   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
  63   2        case MID_FDS_FILE_RF:
  64   2          eeprom_select(1);
  65   2          eeprom_nvr_read_page(r_data, 1, 0, r_size);
  66   2          break;
  67   2      #endif
  68   2        default:
  69   2          break;
  70   2        }
  71   1      }
  72          
  73          static RET_VAL mmi_dq_fds_write(mid_fds_file_id file, uint8_t *w_data, uint16_t w_size)
  74          {
  75   1        uint16_t i;
  76   1        ErrStatus ret;
  77   1        eeprom_erase_time(9);
  78   1        switch (file)
  79   1        {
  80   2          case MID_FDS_FILE_SET:
  81   2            {
  82   3              uint8_t* w_data2 = (uint8_t *)g_dq_fs_pwd;
  83   3              uint16_t w_size2 = sizeof(mmi_fs_pwd)*MMI_DQ_FS_PWD_MAX_NUM;
  84   3              eeprom_select(0);
  85   3              eeprom_erase_page(0);//擦除1K
  86   3              for(i = 0; i < w_size; i++)
  87   3              {
  88   4                ret = eeprom_write_byte(0,i,w_data[i]);//读第一页
  89   4                if(ret==ERROR) 
  90   4                {
  91   5                  //printf("mmi_dq_fds_write  error  %d\n",i);
  92   5                  return RET_FAIL;
  93   5                }
  94   4              }
  95   3              for(i = 0; i < w_size2; i++)
  96   3              {
  97   4                ret = eeprom_write_byte(0,i+24,w_data2[i]);//读第一页
  98   4                if(ret==ERROR) 
  99   4                {
 100   5                  //printf("mmi_dq_fds_write  error  %d\n",i);
 101   5                  return RET_FAIL;
 102   5                }
 103   4              }
 104   3            }
 105   2            break;
 106   2          case MID_FDS_FILE_PWD:
 107   2            {
 108   3              uint8_t* w_data2 = (uint8_t *)&g_dq_fs_init_set;
 109   3              uint16_t w_size2 = sizeof(mmi_fs_setting);
 110   3              eeprom_select(0);
 111   3              eeprom_erase_page(0);//擦除1K
 112   3              for(i = 0; i < w_size2; i++)
 113   3              {
 114   4                ret = eeprom_write_byte(0,i,w_data2[i]);//读第一页
 115   4                if(ret==ERROR) 
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/12/2021 12:09:38 PAGE 3   

 116   4                {
 117   5                  //printf("mmi_dq_fds_write  error  %d\n",i);
 118   5                  return RET_FAIL;
 119   5                }
 120   4              }
 121   3              for(i = 0; i < w_size; i++)
 122   3              {
 123   4                ret = eeprom_write_byte(0,i+24,w_data[i]);//读第一页
 124   4                if(ret==ERROR) 
 125   4                {
 126   5                  //printf("mmi_dq_fds_write  error  %d\n",i);
 127   5                  return RET_FAIL;
 128   5                }
 129   4              }
 130   3            }
 131   2            break;
 132   2      #ifdef __LOCK_FP_SUPPORT__
 133   2          case MID_FDS_FILE_FP:
 134   2            eeprom_select(1);
 135   2            eeprom_erase_page(0);//擦除512byte
 136   2            for(i = 0; i < w_size; i++)
 137   2            {
 138   3              ret = eeprom_write_byte(0,i,w_data[i]);
 139   3              if(ret==ERROR) 
 140   3              {
 141   4                //printf("mmi_dq_fds_write  error  %d\n",i);
 142   4                return RET_FAIL;
 143   4              }
 144   3            }
 145   2            break;
 146   2      #endif
 147   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 148   2          case MID_FDS_FILE_RF:
 149   2            eeprom_select(1);
 150   2            eeprom_erase_page(1);//擦除512byte
 151   2            for(i = 0; i < w_size; i++)
 152   2            {
 153   3              ret = eeprom_write_byte(1,i,w_data[i]);
 154   3              if(ret==ERROR) 
 155   3              {
 156   4                //printf("mmi_dq_fds_write  error  %d\n",i);
 157   4                return RET_FAIL;
 158   4              }
 159   3            }
 160   2            break;
 161   2      #endif
 162   2        default:
 163   2          return RET_FAIL;
 164   2        }
 165   1        //printf("mmi_dq_fds_write  suc\n");
 166   1        return RET_SUCESS;
 167   1      }
 168          
 169          /*
 170          parameter: 
 171            none
 172          return :
 173            none
 174          */
 175          void mmi_dq_fs_init(void)
 176          {
 177   1        mmi_dq_fds_read(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/12/2021 12:09:38 PAGE 4   

 178   1        if (FDS_INIT_LOCK_SUC == g_dq_fs_init_set.init_flag || FDS_INIT_APP_SUC == g_dq_fs_init_set.init_flag)
 179   1        {
 180   2          unsigned char i = 0;
 181   2          mmi_dq_fds_read(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_N
             -UM);
 182   2      #ifdef __LOCK_FP_SUPPORT__
 183   2          mmi_dq_fds_read(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM);
 184   2      #endif
 185   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 186   2          mmi_dq_fds_read(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MAX
             -_NUM);
 187   2      #endif
 188   2          if (g_dq_fs_init_set.admin_status > 0)
 189   2          {
 190   3            for (; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 191   3            {
 192   4              if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
 193   4                break;
 194   4            }
 195   3            if (i >= MMI_DQ_FS_PWD_MAX_NUM)
 196   3            {
 197   4              g_dq_fs_init_set.admin_status = 0;
 198   4              mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 199   4            }
 200   3          }
 201   2        }
 202   1        else
 203   1        {
 204   2          //printf("mmi_dq_fs_init init error");
 205   2          memset(g_dq_fs_pwd, 0xFF, sizeof(g_dq_fs_pwd));
 206   2          mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_
             -NUM);
 207   2      
 208   2      #ifdef __LOCK_FP_SUPPORT__
 209   2          memset(g_dq_fs_fp, 0xFF, sizeof(g_dq_fs_fp));
 210   2          mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM)
             -;
 211   2      
 212   2          mmi_dq_fp_empty();
 213   2      #endif
 214   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 215   2          memset(g_dq_fs_rfid, 0xFF, sizeof(g_dq_fs_rfid));
 216   2          mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MA
             -X_NUM);
 217   2      #endif
 218   2          g_dq_fs_init_set.init_flag = FDS_INIT_LOCK_SUC;
 219   2          g_dq_fs_init_set.open_pro_sound = 1;
 220   2          g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 221   2          g_dq_fs_init_set.admin_status = 0;
 222   2          g_dq_fs_init_set.factory_flag = 0;
 223   2          g_dq_fs_init_set.wifi_flag = 0;
 224   2          mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 225   2        }
 226   1      }
 227          
 228          /**
 229            * @brief  手动初始化
 230            * @param  none
 231            * @return none
 232            * @note   none
 233            * @see    none
 234            */
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/12/2021 12:09:38 PAGE 5   

 235          RET_VAL mmi_dq_fs_clr_set(void)
 236          {
 237   1        g_dq_fs_init_set.open_pro_sound = 1;
 238   1        g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 239   1      
 240   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 241   1      }
 242          
 243          /**
 244            * @brief  复位初始化
 245            * @param  none
 246            * @return none
 247            * @note   none
 248            * @see    none
 249            */
 250          RET_VAL mmi_dq_fs_reset(void)
 251          {
 252   1        memset(g_dq_fs_pwd, 0xFF, sizeof(g_dq_fs_pwd));
 253   1        mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_N
             -UM);
 254   1      #ifdef __LOCK_FP_SUPPORT__
 255   1        memset(g_dq_fs_fp, 0xFF, sizeof(g_dq_fs_fp));
 256   1        mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM);
 257   1      
 258   1        mmi_dq_fp_empty();
 259   1      #endif
 260   1      #ifdef __LOCK_RFID_CARD_SUPPORT__
 261   1        memset(g_dq_fs_rfid, 0xFF, sizeof(g_dq_fs_rfid));
 262   1        mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MAX
             -_NUM);
 263   1      #endif
 264   1        g_dq_fs_init_set.init_flag = FDS_INIT_LOCK_SUC;
 265   1        g_dq_fs_init_set.open_pro_sound = 1;
 266   1        g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 267   1        g_dq_fs_init_set.admin_status = 0;
 268   1        g_dq_fs_init_set.wifi_flag = 0;
 269   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 270   1      }
 271          
 272          /*
 273          parameter: 
 274            none
 275          return :
 276            none
 277          */
 278          void mmi_dq_fs_pwd_string_to_byte(unsigned char *input_pwd, unsigned char pwd_len, unsigned char *output_p
             -wd)
 279          {
 280   1        unsigned char i = 0;
 281   1        unsigned char bit_l = 0;
 282   1        unsigned char bit_h = 0;
 283   1      
 284   1        for (i = 0; i < pwd_len; i++)
 285   1        {
 286   2          bit_l = *(input_pwd + i) & 0x0F;
 287   2          i++;
 288   2          if (i < pwd_len)
 289   2            bit_h = *(input_pwd + i) & 0x0F;
 290   2          else
 291   2            bit_h = 0xF;
 292   2          *output_pwd++ = bit_l << 4 | bit_h;
 293   2        }
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/12/2021 12:09:38 PAGE 6   

 294   1        return;
 295   1      }
 296          /*
 297          parameter: 
 298            none
 299          return :
 300            none
 301          */
 302          unsigned char mmi_dq_fs_pwd_byte_to_string(unsigned char *input_pwd,unsigned char *output_pwd)
 303          {
 304   1        unsigned char i = 0;
 305   1        unsigned char pwd = 0;
 306   1        unsigned char len = 0;
 307   1        for(i=0;i<4;i++)
 308   1        {
 309   2          pwd = *(input_pwd + i);
 310   2          if (pwd == 0xFF)
 311   2            break;
 312   2          else 
 313   2          {
 314   3            *output_pwd++ = (pwd&0xF0)>>4;
 315   3            len++;
 316   3          }
 317   2          if((pwd&0x0F) == 0x0F)
 318   2            break;
 319   2          else
 320   2          {
 321   3            *output_pwd++ = pwd&0x0F;
 322   3            len++;
 323   3          }
 324   2        }
 325   1        return len;
 326   1      }
 327          
 328          /*
 329          parameter: 
 330            none
 331          return :
 332            none
 333          */
 334          unsigned char mmi_dq_fs_get_pwd_unuse_index(void)
 335          {
 336   1        unsigned char i = PWD_ADMIN_NUM;
 337   1      #ifdef __LOCK_110_SUPPORT__
 338   1        i+=PWD_110_NUM;
 339   1      #endif
 340   1        for(;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 341   1        {
 342   2          if (g_dq_fs_pwd[i].flag == 0xFF)
 343   2            break;
 344   2        }
 345   1      
 346   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 347   1          return i;
 348   1        else
 349   1          return 0xFF;
 350   1      }
 351          
 352          /*
 353          parameter: 
 354            none
 355          return :
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/12/2021 12:09:38 PAGE 7   

 356            none
 357          */
 358          unsigned char mmi_dq_fs_check_input_pwd(unsigned char *input_pwd, unsigned char len, fds_use_type type)
 359          {
 360   1        unsigned char i = 0;
 361   1        unsigned char k = 0;
 362   1        unsigned char password[4];
 363   1        unsigned char ret_val = 0xFF;
 364   1      
 365   1        memset(password, 0xFF, sizeof(password));
 366   1        mmi_dq_fs_pwd_string_to_byte(input_pwd, len, password);
 367   1      
 368   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 369   1        {
 370   2          if (g_dq_fs_pwd[i].flag != 0xFF)
 371   2          {
 372   3            for (k = 0; k < 4; k++)
 373   3            {
 374   4              if (password[k] != g_dq_fs_pwd[i].key_pwd[k])
 375   4                break;
 376   4            }
 377   3            if (k == 4)
 378   3            {
 379   4              break;
 380   4            }
 381   3          }
 382   2        }
 383   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 384   1        {
 385   2          if ((g_dq_fs_pwd[i].flag == type) || (type == FDS_USE_TYPE_ALL))
 386   2            ret_val = i;
 387   2          else
 388   2            ret_val = 0xFF;
 389   2        }
 390   1        else
 391   1          ret_val = 0xFF;
 392   1      
 393   1        return ret_val;
 394   1      }
 395          
 396          /*
 397          parameter: 
 398            none
 399          return :
 400            none
 401          */
 402          unsigned char mmi_dq_fs_check_input_pwd_for_open(unsigned char *input_pwd,unsigned char len)
 403          {
 404   1        unsigned char i = 0,n = 0;
 405   1        unsigned char k,j;
 406   1        unsigned char password[8];
 407   1        unsigned char passlen = 0;
 408   1        unsigned char ret_val = 0xFF;
 409   1        
 410   1        for(i=0;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 411   1        {
 412   2          if(g_dq_fs_pwd[i].flag == FDS_USE_TYPE_INVALID)
 413   2            continue;
 414   2          memset(password,0xFF,sizeof(password));
 415   2          passlen = mmi_dq_fs_pwd_byte_to_string(g_dq_fs_pwd[i].key_pwd,password);
 416   2          for(k = 0;k+passlen <= len; k++)
 417   2          {
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/12/2021 12:09:38 PAGE 8   

 418   3            for(j=0;j<passlen;j++)
 419   3            {
 420   4              if(password[j] != input_pwd[k+j])
 421   4                break;
 422   4            }
 423   3            if(j==passlen)
 424   3              break;
 425   3          }
 426   2          if(j == passlen)
 427   2            break;
 428   2        }
 429   1        if(i<MMI_DQ_FS_PWD_MAX_NUM)
 430   1        {
 431   2          //printf("check input return i: %d",(unsigned int)i);
 432   2          return i;
 433   2        }
 434   1        else
 435   1        {
 436   2          unsigned char adminword[8];
 437   2          unsigned char checkCode_out[8];
 438   2          unsigned char pass = 0;
 439   2          memset(adminword,0xFF,sizeof(adminword));
 440   2          passlen = mmi_dq_fs_pwd_byte_to_string(g_dq_fs_pwd[0].key_pwd,adminword);
 441   2          for(i=0;i<8;i++)
 442   2          {
 443   3            if(adminword[i]==0xFF)
 444   3              adminword[i] = 0;
 445   3            else
 446   3              adminword[i] += '0';
 447   3      
 448   3            if(input_pwd[i]==0xFF)
 449   3              password[i] = 0;
 450   3            else
 451   3              password[i] = input_pwd[i] + '0';
 452   3          }
 453   2          pass = dq_check_otp((char *)password,(char *)adminword,g_dq_fs_init_set.check_data,checkCode_out);
 454   2          if(pass > 0)
 455   2          {
 456   3            memcpy(g_dq_fs_init_set.check_data,checkCode_out,8);
 457   3            mmi_dq_fds_write(MID_FDS_FILE_SET,(unsigned char *)&g_dq_fs_init_set,sizeof(mmi_fs_setting));
 458   3            return 0xFE;
 459   3          }
 460   2        }
 461   1        //printf("check input return 0xFF");
 462   1        return 0xFF;
 463   1      }
 464          
 465          /*
 466          parameter: 
 467            none
 468          return :
 469            none
 470          */
 471          RET_VAL mmi_dq_fs_set_pwd(unsigned char *pwd,unsigned char pwd_size,fds_use_type type)
 472          {
 473   1        unsigned char i = 0;
 474   1        unsigned char password[4];
 475   1      
 476   1        if(type == FDS_USE_TYPE_ADMIN)
 477   1          i = 0;
 478   1      #ifdef __LOCK_110_SUPPORT__
 479   1        else if(type == FDS_USE_TYPE_110)
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/12/2021 12:09:38 PAGE 9   

 480   1          i = 1;
 481   1      #endif
 482   1        else
 483   1        {
 484   2      #ifdef __LOCK_110_SUPPORT__
 485   2          i = PWD_ADMIN_NUM+PWD_110_NUM;
 486   2      #else
                  i = PWD_ADMIN_NUM;
              #endif
 489   2          for(;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 490   2          {
 491   3            if (g_dq_fs_pwd[i].flag == 0xFF)
 492   3              break;
 493   3          }
 494   2        }
 495   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 496   1        {
 497   2          memset(password, 0xFF, sizeof(password));
 498   2          //g_dq_fs_pwd[i].index = i;
 499   2          mmi_dq_fs_pwd_string_to_byte(pwd, pwd_size, password);
 500   2          memcpy((char *)g_dq_fs_pwd[i].key_pwd, (const char *)password, 4);
 501   2          g_dq_fs_pwd[i].flag = type;
 502   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_P
             -WD_MAX_NUM);
 503   2        }
 504   1        return RET_FAIL;
 505   1      }
 506          
 507          /*
 508          parameter: 
 509            none
 510          return :
 511            none
 512          */
 513          RET_VAL mmi_dq_fs_del_pwd(unsigned char index, fds_use_type type)
 514          {
 515   1        if (index < MMI_DQ_FS_PWD_MAX_NUM && g_dq_fs_pwd[index].flag == type)
 516   1        {
 517   2          g_dq_fs_pwd[index].flag = FDS_USE_TYPE_INVALID;
 518   2          //g_dq_fs_pwd[index].index = 0xFF;
 519   2          memset(g_dq_fs_pwd[index].key_pwd, 0xFF, sizeof(g_dq_fs_pwd[index].key_pwd));
 520   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_P
             -WD_MAX_NUM);
 521   2        }
 522   1        return RET_FAIL;
 523   1      }
 524          
 525          /*
 526          parameter: 
 527            none
 528          return :
 529            none
 530          */
 531          RET_VAL mmi_dq_fs_clr_pwd(void)
 532          {
 533   1        unsigned char i = PWD_ADMIN_NUM;
 534   1      #ifdef __LOCK_110_SUPPORT__
 535   1        i += PWD_110_NUM;
 536   1      #endif
 537   1        for(;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 538   1        {
 539   2          if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_USER)
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/12/2021 12:09:38 PAGE 10  

 540   2          {
 541   3            g_dq_fs_pwd[i].flag = FDS_USE_TYPE_INVALID;
 542   3            //g_dq_fs_pwd[i].index = 0xFF;
 543   3            memset(g_dq_fs_pwd[i].key_pwd, 0xFF, sizeof(g_dq_fs_pwd[i].key_pwd));
 544   3          }
 545   2        }
 546   1        return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PW
             -D_MAX_NUM);
 547   1      }
 548          
 549          #if defined(__LOCK_FP_SUPPORT__)
 550          /*
 551          parameter: 
 552            none
 553          return :
 554            none
 555          */
 556          unsigned char mmi_dq_fs_get_fp_unuse_index(void)
 557          {
 558   1        unsigned char i = FP_ADMIN_NUM;
 559   1      #ifdef __LOCK_110_SUPPORT__
 560   1        i += FP_110_NUM;
 561   1      #endif
 562   1        for(;i<MMI_DQ_FS_FP_MAX_NUM;i++)
 563   1        {
 564   2          if (g_dq_fs_fp[i].fp_index == 0xFF)
 565   2            break;
 566   2        }
 567   1        if (i >= MMI_DQ_FS_FP_MAX_NUM)
 568   1          return 0xFF;
 569   1        return i;
 570   1      }
 571          
 572          #ifdef __LOCK_110_SUPPORT__
 573          /*
 574          parameter: 
 575            none
 576          return :
 577            none
 578          */
 579          unsigned char mmi_dq_fs_get_fp_110_unuse_index(void)
 580          {
 581   1        unsigned char i = FP_ADMIN_NUM;
 582   1        unsigned char j = 0;
 583   1      
 584   1        for(;j<FP_110_NUM;j++)
 585   1        {
 586   2          if(g_dq_fs_fp[i+j].fp_index == 0xFF)
 587   2            break;
 588   2        }
 589   1        if(j>=FP_110_NUM)
 590   1          return 0xFF;
 591   1        return i+j;
 592   1      }
 593          #endif
 594          
 595          /*
 596          parameter: 
 597            none
 598          return :
 599            none
 600          */
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/12/2021 12:09:38 PAGE 11  

 601          RET_VAL mmi_dq_fs_check_fp(unsigned char fp_index, fds_use_type type)
 602          {
 603   1        if ((fp_index < MMI_DQ_FS_FP_MAX_NUM) && (g_dq_fs_fp[fp_index].fp_index == fp_index) && ((g_dq_fs_fp[fp_i
             -ndex].flag == type) || (type == FDS_USE_TYPE_ALL)))
 604   1          return RET_SUCESS;
 605   1        else
 606   1          return RET_FAIL;
 607   1      }
 608          
 609          /*
 610          parameter: 
 611            none
 612          return :
 613            none
 614          */
 615          RET_VAL mmi_dq_fs_set_fp(unsigned char fs_index, fds_use_type type)
 616          {
 617   1        g_dq_fs_fp[fs_index].fp_index = fs_index;
 618   1        g_dq_fs_fp[fs_index].flag = type;
 619   1        return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MA
             -X_NUM);
 620   1      }
 621          
 622          /*
 623          parameter: 
 624            none
 625          return :
 626            none
 627          */
 628          RET_VAL mmi_dq_fs_del_fp(unsigned char fp_index, fds_use_type type)
 629          {
 630   1        if (mmi_dq_fs_check_fp(fp_index, type) == RET_SUCESS)
 631   1        {
 632   2          g_dq_fs_fp[fp_index].flag = FDS_USE_TYPE_INVALID;
 633   2          g_dq_fs_fp[fp_index].fp_index = 0xFF;
 634   2          return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_M
             -AX_NUM);
 635   2        }
 636   1        return RET_FAIL;
 637   1      }
 638          
 639          /*
 640          parameter: 
 641            none
 642          return :
 643            none
 644          */
 645          RET_VAL mmi_dq_fs_clr_fp(void)
 646          {
 647   1        unsigned char i = FP_ADMIN_NUM;
 648   1        unsigned short fp_ret = 0;
 649   1      #ifdef __LOCK_110_SUPPORT__
 650   1        i += FP_110_NUM;
 651   1      #endif
 652   1        for(;i<MMI_DQ_FS_FP_MAX_NUM;i++)
 653   1        {
 654   2          if(g_dq_fs_fp[i].fp_index != 0xFF)
 655   2          {
 656   3            fp_ret = mmi_dq_fp_delete(g_dq_fs_fp[i].fp_index);
 657   3            if(fp_ret == 0)
 658   3            {
 659   4              g_dq_fs_fp[i].flag = FDS_USE_TYPE_INVALID;
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/12/2021 12:09:38 PAGE 12  

 660   4              g_dq_fs_fp[i].fp_index = 0xFF;
 661   4            }
 662   3          }
 663   2        }
 664   1        return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp)*MMI_DQ_FS_FP_MAX_
             -NUM);
 665   1      }
 666          
 667          #endif
 668          
 669          #ifdef __LOCK_RFID_CARD_SUPPORT__
 670          
 671          /*
 672          parameter: 
 673            none
 674          return :
 675            none
 676          */
 677          unsigned char mmi_dq_fs_get_rfid_unuse_index(void)
 678          {
 679   1        unsigned char i = 0;
 680   1      
 681   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 682   1        {
 683   2          if (g_dq_fs_rfid[i].index == 0xFF)
 684   2            break;
 685   2        }
 686   1      
 687   1        if (i >= MMI_DQ_FS_RFID_MAX_NUM)
 688   1          return 0xFF;
 689   1        return i;
 690   1      }
 691          
 692          /*
 693          parameter: 
 694            none
 695          return :
 696            none
 697          */
 698          unsigned char mmi_dq_fs_check_rfid(unsigned char *sec_data, fds_use_type type)
 699          {
 700   1        unsigned char i = 0, j = 0;
 701   1      
 702   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 703   1        {
 704   2          for (j = 0; j < RFID_SEC_DATA_LEN; j++)
 705   2          {
 706   3            if (g_dq_fs_rfid[i].sec_data[j] != sec_data[j])
 707   3              break;
 708   3          }
 709   2          if (j == RFID_SEC_DATA_LEN)
 710   2            break;
 711   2        }
 712   1        if (i < MMI_DQ_FS_RFID_MAX_NUM && ((g_dq_fs_rfid[i].flag == type) || (type == FDS_USE_TYPE_ALL)))
 713   1        {
 714   2          return i;
 715   2        }
 716   1        else
 717   1        {
 718   2          return 0xFF;
 719   2        }
 720   1      }
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/12/2021 12:09:38 PAGE 13  

 721          
 722          /*
 723          parameter: 
 724            none
 725          return :
 726            none
 727          */
 728          RET_VAL mmi_dq_fs_set_rfid(unsigned char *sec_data, fds_use_type type)
 729          {
 730   1        unsigned char i = 0, j = 0;
 731   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 732   1        {
 733   2          if (g_dq_fs_rfid[i].index == 0xFF)
 734   2            break;
 735   2        }
 736   1        if (i < MMI_DQ_FS_RFID_MAX_NUM)
 737   1        {
 738   2          g_dq_fs_rfid[i].index = i;
 739   2          g_dq_fs_rfid[i].flag = type;
 740   2          for (j = 0; j < RFID_SEC_DATA_LEN; j++)
 741   2          {
 742   3            g_dq_fs_rfid[i].sec_data[j] = sec_data[j];
 743   3          }
 744   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_
             -RFID_MAX_NUM);
 745   2        }
 746   1        return RET_FAIL;
 747   1      }
 748          
 749          /*
 750          parameter: 
 751            none
 752          return :
 753            none
 754          */
 755          RET_VAL mmi_dq_fs_del_rfid(unsigned char rfid_index)
 756          {
 757   1        if (rfid_index < MMI_DQ_FS_RFID_MAX_NUM && g_dq_fs_rfid[rfid_index].index == rfid_index)
 758   1        {
 759   2          g_dq_fs_rfid[rfid_index].index = 0xFF;
 760   2          g_dq_fs_rfid[rfid_index].flag = FDS_USE_TYPE_INVALID;
 761   2          memset(g_dq_fs_rfid[rfid_index].sec_data, 0xFF, sizeof(g_dq_fs_rfid[rfid_index].sec_data));
 762   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_
             -RFID_MAX_NUM);
 763   2        }
 764   1        return RET_FAIL;
 765   1      }
 766          
 767          /*
 768          parameter: 
 769            none
 770          return :
 771            none
 772          */
 773          RET_VAL mmi_dq_fs_clr_rfid(void)
 774          {
 775   1        unsigned char i = 0;
 776   1      
 777   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 778   1        {
 779   2          g_dq_fs_rfid[i].flag = FDS_USE_TYPE_INVALID;
 780   2          g_dq_fs_rfid[i].index = 0xFF;
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/12/2021 12:09:38 PAGE 14  

 781   2          memset(g_dq_fs_rfid[i].sec_data, 0xFF, sizeof(g_dq_fs_rfid[i].sec_data));
 782   2        }
 783   1        return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_R
             -FID_MAX_NUM);
 784   1      }
 785          
 786          #endif
 787          
 788          /*
 789          parameter: 
 790            none
 791          return :
 792            none
 793          */
 794          RET_VAL mmi_dq_fs_set_open_mode(sys_open_mode mode)
 795          {
 796   1        if (g_dq_fs_init_set.open_mode == mode)
 797   1          return RET_SUCESS;
 798   1      
 799   1        g_dq_fs_init_set.open_mode = mode;
 800   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 801   1        
 802   1      }
 803          /*
 804          parameter: 
 805            none
 806          return :
 807            none
 808          */
 809          sys_open_mode mmi_dq_fs_get_open_mode(void)
 810          {
 811   1        return g_dq_fs_init_set.open_mode;
 812   1      }
 813          
 814          /*
 815          parameter: 
 816            none
 817          return :
 818            none
 819          */
 820          RET_VAL mmi_dq_fs_set_pro_sound(unsigned char flag)
 821          {
 822   1        if (g_dq_fs_init_set.open_pro_sound == flag)
 823   1          return RET_SUCESS;
 824   1      
 825   1        g_dq_fs_init_set.open_pro_sound = flag;
 826   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 827   1      }
 828          
 829          /*
 830          parameter: 
 831            none
 832          return :
 833            none
 834          */
 835          unsigned char mmi_dq_fs_get_pro_sound_state(void)
 836          {
 837   1        return g_dq_fs_init_set.open_pro_sound;
 838   1      }
 839          
 840          /*
 841          parameter: 
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/12/2021 12:09:38 PAGE 15  

 842            none
 843          return :
 844            none
 845          */
 846          unsigned char mmi_dq_fs_get_init_flag(void)
 847          {
 848   1        return g_dq_fs_init_set.init_flag;
 849   1      }
 850          
 851          /*
 852          parameter: 
 853            none
 854          return :
 855            none
 856          */
 857          RET_VAL mmi_dq_fs_set_init_flag(unsigned char flag)
 858          {
 859   1        g_dq_fs_init_set.init_flag = flag;
 860   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 861   1      }
 862          
 863          /*
 864          parameter: 
 865            none
 866          return :
 867            none
 868          */
 869          RET_VAL mmi_dq_fs_set_factory_flag(unsigned char flag)
 870          {
 871   1        g_dq_fs_init_set.factory_flag = flag;
 872   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 873   1      }
 874          
 875          /*
 876          parameter: 
 877            none
 878          return :
 879            none
 880          */
 881          unsigned char mmi_dq_fs_get_factory_flag(void)
 882          {
 883   1        return g_dq_fs_init_set.factory_flag;
 884   1      }
 885          
 886          /*
 887          parameter: 
 888            none
 889          return :
 890            none
 891          */
 892          unsigned char mmi_dq_fs_get_admin_status(void)
 893          {
 894   1        return g_dq_fs_init_set.admin_status;
 895   1      }
 896          
 897          /*
 898          parameter: 
 899            none
 900          return :
 901            none
 902          */
 903          RET_VAL mmi_dq_fs_set_admin_status(unsigned char status)
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/12/2021 12:09:38 PAGE 16  

 904          {
 905   1        g_dq_fs_init_set.admin_status = status;
 906   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 907   1      }
 908          
 909          #if 0
              /*
              parameter: 
                none
              return :
                none
              */
              RET_VAL mmi_dq_fs_set_wifi_setting(unsigned char flag)
              {
                g_dq_fs_init_set.wifi_flag = flag;
                return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
              }
              
              /*
              parameter: 
                none
              return :
                none
              */
              unsigned char mmi_dq_fs_get_wifi_setting(void)
              {
                return g_dq_fs_init_set.wifi_flag;
              }
              #endif
 933          
 934          
 935          
 936          /*
 937          parameter: 
 938            none
 939          return :
 940            none
 941          */
 942          RET_VAL mmi_dq_fs_set_business_flag(unsigned char flag)
 943          {
 944   1        #if 1
 945   1        if(flag != g_dq_fs_init_set.business_flag)
 946   1        {
 947   2          g_dq_fs_init_set.business_flag = flag;
 948   2          return mmi_dq_fds_write(MID_FDS_FILE_SET,(unsigned char *)&g_dq_fs_init_set,sizeof(mmi_fs_setting));
 949   2        }
 950   1        #else
                g_dq_fs_init_set.business_flag = flag;
                #endif
 953   1        return RET_SUCESS;
 954   1      }
 955          
 956          /*
 957          parameter: 
 958            none
 959          return :
 960            none
 961          */
 962          unsigned char mmi_dq_fs_get_business_flag(void)
 963          {
 964   1        return g_dq_fs_init_set.business_flag;
 965   1      }
C51 COMPILER V9.59.0.0   MMI_FS                                                            03/12/2021 12:09:38 PAGE 17  

 966          
 967          
 968          
 969          
 970          
 971          
 972          
 973          
 974          
 975          
 976          
 977          
 978          
 979          
 980          
 981          
 982          
 983          
 984          
 985          
 986          
 987          
 988          
 989          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4111    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    704     104
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     15    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
