C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MMI_FS
OBJECT MODULE PLACED IN .\output\mmi_fs.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE mmi_src\mmi_fs.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;.\
                    -Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd_rfi
                    -d;.\mmi_inc) DEBUG PRINT(.\list\mmi_fs.lst) TABS(2) OBJECT(.\output\mmi_fs.obj)

line level    source

   1          #ifndef __MMI_FS_C__
   2          #define __MMI_FS_C__
   3          
   4          #include "mmi_fs.h"
   5          #include "mmi_sys.h"
   6          #include "mcu02_sfr.h"
   7          #include "mcu02_eeprom.h"
   8          #include "string.h"
   9          // #include <stdio.h>
  10          
  11          #include "mmi_fps.h"
  12          #include "mmi_ms.h"
  13          #include "dq_otp.h"
  14          #ifdef __LOCK_VIRTUAL_PASSWORD__
              #include "dq_sdk_main.h"
              #endif
  17          
  18          extern void printfS(char *show, char *status);
  19          
  20          unsigned char get_index = 0xff;
  21          
  22          mmi_fs_setting data g_dq_fs_init_set;
  23          
  24          #define MMI_DQ_FS_PWD_MAX_NUM 100
  25          mmi_fs_pwd g_dq_fs_pwd[MMI_DQ_FS_PWD_MAX_NUM];
  26          
  27          #if defined(__LOCK_FP_SUPPORT__)
              #define MMI_DQ_FS_FP_MAX_NUM 30
              mmi_fs_fp g_dq_fs_fp[MMI_DQ_FS_FP_MAX_NUM];
              #endif
  31          
  32          #ifdef __LOCK_RFID_CARD_SUPPORT__
  33          #define MMI_DQ_FS_RFID_MAX_NUM 10
  34          mmi_fs_rfid g_dq_fs_rfid[MMI_DQ_FS_RFID_MAX_NUM];
  35          #endif
  36          
  37          #define FP_ADMIN_NUM 2
  38          #define FP_110_NUM 3
  39          
  40          #define PWD_ADMIN_NUM 1
  41          #define PWD_110_NUM 1
  42          
  43          static void mmi_dq_fds_read(mid_fds_file_id file, uint8_t *r_data, uint16_t r_size)
  44          {
  45   1        uint16_t i;
  46   1      
  47   1        switch (file)
  48   1        {
  49   2        case MID_FDS_FILE_SET:
  50   2          eeprom_select(0);
  51   2          for (i = 0; i < r_size; i++)
  52   2          {
  53   3            r_data[i] = eeprom_read_byte(0, i); //读第一页
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 2   

  54   3          }
  55   2          break;
  56   2        case MID_FDS_FILE_PWD:
  57   2          eeprom_select(0);
  58   2          for (i = 0; i < r_size; i++)
  59   2          {
  60   3            r_data[i] = eeprom_read_byte(0, i + 24); //读第一页
  61   3          }
  62   2          break;
  63   2      #ifdef __LOCK_FP_SUPPORT__
                case MID_FDS_FILE_FP:
                  eeprom_select(1);
                  eeprom_nvr_read_page(r_data, 0, 0, r_size);
                  break;
              #endif
  69   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
  70   2        case MID_FDS_FILE_RF:
  71   2          eeprom_select(1);
  72   2          eeprom_nvr_read_page(r_data, 1, 0, r_size);
  73   2          break;
  74   2      #endif
  75   2        default:
  76   2          break;
  77   2        }
  78   1      }
  79          
  80          static RET_VAL mmi_dq_fds_write(mid_fds_file_id file, uint8_t *w_data, uint16_t w_size)
  81          {
  82   1        uint16_t i;
  83   1        ErrStatus ret;
  84   1        eeprom_erase_time(9);
  85   1        switch (file)
  86   1        {
  87   2        case MID_FDS_FILE_SET:
  88   2        {
  89   3          uint8_t *w_data2 = (uint8_t *)g_dq_fs_pwd;
  90   3          uint16_t w_size2 = sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_NUM;
  91   3          eeprom_select(0);
  92   3          eeprom_erase_page(0); //擦除1K
  93   3          for (i = 0; i < w_size; i++)
  94   3          {
  95   4            ret = eeprom_write_byte(0, i, w_data[i]); //读第一页
  96   4            if (ret == ERROR)
  97   4            {
  98   5              //printf("mmi_dq_fds_write  error  %d\n",i);
  99   5              return RET_FAIL;
 100   5            }
 101   4          }
 102   3          for (i = 0; i < w_size2; i++)
 103   3          {
 104   4            ret = eeprom_write_byte(0, i + 24, w_data2[i]); //读第一页
 105   4            if (ret == ERROR)
 106   4            {
 107   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 108   5              return RET_FAIL;
 109   5            }
 110   4          }
 111   3        }
 112   2        break;
 113   2        case MID_FDS_FILE_PWD:
 114   2        {
 115   3          uint8_t *w_data2 = (uint8_t *)&g_dq_fs_init_set;
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 3   

 116   3          uint16_t w_size2 = sizeof(mmi_fs_setting);
 117   3          eeprom_select(0);
 118   3          eeprom_erase_page(0); //擦除1K
 119   3          for (i = 0; i < w_size2; i++)
 120   3          {
 121   4            ret = eeprom_write_byte(0, i, w_data2[i]); //读第一页
 122   4            if (ret == ERROR)
 123   4            {
 124   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 125   5              return RET_FAIL;
 126   5            }
 127   4          }
 128   3          for (i = 0; i < w_size; i++)
 129   3          {
 130   4            ret = eeprom_write_byte(0, i + 24, w_data[i]); //读第一页
 131   4            if (ret == ERROR)
 132   4            {
 133   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 134   5              return RET_FAIL;
 135   5            }
 136   4          }
 137   3        }
 138   2        break;
 139   2      #ifdef __LOCK_FP_SUPPORT__
                case MID_FDS_FILE_FP:
                  eeprom_select(1);
                  eeprom_erase_page(0); //擦除512byte
                  for (i = 0; i < w_size; i++)
                  {
                    ret = eeprom_write_byte(0, i, w_data[i]);
                    if (ret == ERROR)
                    {
                      //printf("mmi_dq_fds_write  error  %d\n",i);
                      return RET_FAIL;
                    }
                  }
                  break;
              #endif
 154   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 155   2        case MID_FDS_FILE_RF:
 156   2          eeprom_select(1);
 157   2          eeprom_erase_page(1); //擦除512byte
 158   2          for (i = 0; i < w_size; i++)
 159   2          {
 160   3            ret = eeprom_write_byte(1, i, w_data[i]);
 161   3            if (ret == ERROR)
 162   3            {
 163   4              //printf("mmi_dq_fds_write  error  %d\n",i);
 164   4              return RET_FAIL;
 165   4            }
 166   3          }
 167   2          break;
 168   2      #endif
 169   2        default:
 170   2          return RET_FAIL;
 171   2        }
 172   1        //printf("mmi_dq_fds_write  suc\n");
 173   1        return RET_SUCESS;
 174   1      }
 175          
 176          /*
 177          parameter: 
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 4   

 178            none
 179          return :
 180            none
 181          */
 182          void mmi_dq_fs_init(void)
 183          {
 184   1        mmi_dq_fds_read(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 185   1        if (FDS_INIT_LOCK_SUC == g_dq_fs_init_set.init_flag || FDS_INIT_APP_SUC == g_dq_fs_init_set.init_flag)
 186   1        {
 187   2          unsigned char i = 0;
 188   2          mmi_dq_fds_read(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_N
             -UM);
 189   2      #ifdef __LOCK_FP_SUPPORT__
                  mmi_dq_fds_read(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM);
              #endif
 192   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 193   2          mmi_dq_fds_read(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MAX
             -_NUM);
 194   2      #endif
 195   2          if (g_dq_fs_init_set.admin_status > 0)
 196   2          {
 197   3            for (; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 198   3            {
 199   4              if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
 200   4                break;
 201   4            }
 202   3            if (i >= MMI_DQ_FS_PWD_MAX_NUM)
 203   3            {
 204   4              g_dq_fs_init_set.admin_status = 0;
 205   4              mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 206   4            }
 207   3          }
 208   2        }
 209   1        else
 210   1        {
 211   2          //printf("mmi_dq_fs_init init error");
 212   2          memset(g_dq_fs_pwd, 0xFF, sizeof(g_dq_fs_pwd));
 213   2          mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_
             -NUM);
 214   2      
 215   2      #ifdef __LOCK_FP_SUPPORT__
                  memset(g_dq_fs_fp, 0xFF, sizeof(g_dq_fs_fp));
                  mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM)
             -;
              
                  mmi_dq_fp_empty();
              #endif
 221   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
 222   2          memset(g_dq_fs_rfid, 0xFF, sizeof(g_dq_fs_rfid));
 223   2          mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MA
             -X_NUM);
 224   2      #endif
 225   2          g_dq_fs_init_set.init_flag = FDS_INIT_LOCK_SUC;
 226   2          g_dq_fs_init_set.open_pro_sound = 1;
 227   2          g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 228   2          g_dq_fs_init_set.admin_status = 0;
 229   2          g_dq_fs_init_set.factory_flag = 0;
 230   2          g_dq_fs_init_set.wifi_flag = 0;
 231   2          mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 232   2        }
 233   1      }
 234          
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 5   

 235          /**
 236            * @brief  手动初始化
 237            * @param  none
 238            * @return none
 239            * @note   none
 240            * @see    none
 241            */
 242          RET_VAL mmi_dq_fs_clr_set(void)
 243          {
 244   1        g_dq_fs_init_set.open_pro_sound = 1;
 245   1        g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 246   1      
 247   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 248   1      }
 249          
 250          /**
 251            * @brief  复位初始化
 252            * @param  none
 253            * @return none
 254            * @note   none
 255            * @see    none
 256            */
 257          RET_VAL mmi_dq_fs_reset(void)
 258          {
 259   1        memset(g_dq_fs_pwd, 0xFF, sizeof(g_dq_fs_pwd));
 260   1        mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_N
             -UM);
 261   1      #ifdef __LOCK_FP_SUPPORT__
                memset(g_dq_fs_fp, 0xFF, sizeof(g_dq_fs_fp));
                mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM);
              
                mmi_dq_fp_empty();
              #endif
 267   1      #ifdef __LOCK_RFID_CARD_SUPPORT__
 268   1        memset(g_dq_fs_rfid, 0xFF, sizeof(g_dq_fs_rfid));
 269   1        mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MAX
             -_NUM);
 270   1      #endif
 271   1        g_dq_fs_init_set.init_flag = FDS_INIT_LOCK_SUC;
 272   1        g_dq_fs_init_set.open_pro_sound = 1;
 273   1        g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 274   1        g_dq_fs_init_set.admin_status = 0;
 275   1        g_dq_fs_init_set.wifi_flag = 0;
 276   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 277   1      }
 278          
 279          /*
 280          parameter: 
 281            none
 282          return :
 283            none
 284          */
 285          void mmi_dq_fs_pwd_string_to_byte(unsigned char *input_pwd, unsigned char pwd_len, unsigned char *output_p
             -wd)
 286          {
 287   1        unsigned char i = 0;
 288   1        unsigned char bit_l = 0;
 289   1        unsigned char bit_h = 0;
 290   1      
 291   1        for (i = 0; i < pwd_len; i++)
 292   1        {
 293   2          bit_l = *(input_pwd + i) & 0x0F;
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 6   

 294   2          i++;
 295   2          if (i < pwd_len)
 296   2            bit_h = *(input_pwd + i) & 0x0F;
 297   2          else
 298   2            bit_h = 0xF;
 299   2          *output_pwd++ = bit_l << 4 | bit_h;
 300   2        }
 301   1        return;
 302   1      }
 303          /*
 304          parameter: 
 305            none
 306          return :
 307            none
 308          */
 309          unsigned char mmi_dq_fs_pwd_byte_to_string(unsigned char *input_pwd, unsigned char *output_pwd)
 310          {
 311   1        unsigned char i = 0;
 312   1        unsigned char pwd = 0;
 313   1        unsigned char len = 0;
 314   1        for (i = 0; i < 4; i++)
 315   1        {
 316   2          pwd = *(input_pwd + i);
 317   2          if (pwd == 0xFF)
 318   2            break;
 319   2          else
 320   2          {
 321   3            *output_pwd++ = (pwd & 0xF0) >> 4;
 322   3            len++;
 323   3          }
 324   2          if ((pwd & 0x0F) == 0x0F)
 325   2            break;
 326   2          else
 327   2          {
 328   3            *output_pwd++ = pwd & 0x0F;
 329   3            len++;
 330   3          }
 331   2        }
 332   1        return len;
 333   1      }
 334          
 335          /*
 336          parameter: 
 337            none
 338          return :
 339            none
 340          */
 341          unsigned char mmi_dq_fs_get_pwd_unuse_index(void)
 342          {
 343   1        unsigned char i = PWD_ADMIN_NUM;
 344   1      #ifdef __LOCK_110_SUPPORT__
 345   1        i += PWD_110_NUM;
 346   1      #endif
 347   1        for (; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 348   1        {
 349   2          if (g_dq_fs_pwd[i].flag == 0xFF)
 350   2            break;
 351   2        }
 352   1      
 353   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 354   1          return i;
 355   1        else
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 7   

 356   1          return 0xFF;
 357   1      }
 358          
 359          /*
 360          parameter: 
 361            none
 362          return :
 363            none
 364          */
 365          unsigned char mmi_dq_fs_check_input_pwd(unsigned char *input_pwd, unsigned char len, fds_use_type type)
 366          {
 367   1        unsigned char i = 0;
 368   1        unsigned char k = 0;
 369   1        unsigned char password[4];
 370   1        unsigned char ret_val = 0xFF;
 371   1      
 372   1        memset(password, 0xFF, sizeof(password));
 373   1        mmi_dq_fs_pwd_string_to_byte(input_pwd, len, password);
 374   1      
 375   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 376   1        {
 377   2          if (g_dq_fs_pwd[i].flag != 0xFF)
 378   2          {
 379   3            for (k = 0; k < 4; k++)
 380   3            {
 381   4              if (password[k] != g_dq_fs_pwd[i].key_pwd[k])
 382   4                break;
 383   4            }
 384   3            if (k == 4)
 385   3            {
 386   4              break;
 387   4            }
 388   3          }
 389   2        }
 390   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 391   1        {
 392   2          if ((g_dq_fs_pwd[i].flag == type) || (type == FDS_USE_TYPE_ALL))
 393   2            ret_val = i;
 394   2          else
 395   2            ret_val = 0xFF;
 396   2        }
 397   1        else
 398   1          ret_val = 0xFF;
 399   1      
 400   1        return ret_val;
 401   1      }
 402          
 403          /*
 404          parameter: 
 405            none
 406          return :
 407            none
 408          */
 409          unsigned char mmi_dq_fs_check_input_pwd_for_open(unsigned char *input_pwd, unsigned char len)
 410          {
 411   1        unsigned char i = 0, n = 0;
 412   1        unsigned char k, j;
 413   1        unsigned char password[8];
 414   1        unsigned char passlen = 0;
 415   1        unsigned char ret_val = 0xFF;
 416   1      
 417   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 8   

 418   1        {
 419   2          if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_INVALID)
 420   2            continue;
 421   2          memset(password, 0xFF, sizeof(password));
 422   2          passlen = mmi_dq_fs_pwd_byte_to_string(g_dq_fs_pwd[i].key_pwd, password);
 423   2          for (k = 0; k + passlen <= len; k++)
 424   2          {
 425   3            for (j = 0; j < passlen; j++)
 426   3            {
 427   4              if (password[j] != input_pwd[k + j])
 428   4                break;
 429   4            }
 430   3            if (j == passlen)
 431   3              break;
 432   3          }
 433   2          if (j == passlen)
 434   2            break;
 435   2        }
 436   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 437   1        {
 438   2          //printf("check input return i: %d",(unsigned int)i);
 439   2          get_index = i;
 440   2          return i;
 441   2        }
 442   1        else
 443   1        {
 444   2          unsigned char adminword[8];
 445   2          unsigned char checkCode_out[8];
 446   2          unsigned char pass = 0;
 447   2          memset(adminword, 0xFF, sizeof(adminword));
 448   2          passlen = mmi_dq_fs_pwd_byte_to_string(g_dq_fs_pwd[0].key_pwd, adminword);
 449   2          for (i = 0; i < 8; i++)
 450   2          {
 451   3            if (adminword[i] == 0xFF)
 452   3              adminword[i] = 0;
 453   3            else
 454   3              adminword[i] += '0';
 455   3      
 456   3            if (input_pwd[i] == 0xFF)
 457   3              password[i] = 0;
 458   3            else
 459   3              password[i] = input_pwd[i] + '0';
 460   3          }
 461   2          pass = dq_check_otp((char *)password, (char *)adminword, g_dq_fs_init_set.check_data, checkCode_out);
 462   2          if (pass > 0)
 463   2          {
 464   3            memcpy(g_dq_fs_init_set.check_data, checkCode_out, 8);
 465   3            mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 466   3            return 0xFE;
 467   3          }
 468   2        }
 469   1        //printf("check input return 0xFF");
 470   1        return 0xFF;
 471   1      }
 472          
 473          /*
 474          parameter: 
 475            none
 476          return :
 477            none
 478          */
 479          RET_VAL mmi_dq_fs_set_pwd(unsigned char *pwd, unsigned char pwd_size, fds_use_type type)
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 9   

 480          {
 481   1        unsigned char i = 0;
 482   1        unsigned char password[4];
 483   1      
 484   1        if (type == FDS_USE_TYPE_ADMIN)
 485   1          i = 0;
 486   1      #ifdef __LOCK_110_SUPPORT__
 487   1        else if (type == FDS_USE_TYPE_110)
 488   1          i = 1;
 489   1      #endif
 490   1        else
 491   1        {
 492   2      #ifdef __LOCK_110_SUPPORT__
 493   2          i = PWD_ADMIN_NUM + PWD_110_NUM;
 494   2      #else
                  i = PWD_ADMIN_NUM;
              #endif
 497   2          for (; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 498   2          {
 499   3            if (g_dq_fs_pwd[i].flag == 0xFF)
 500   3              break;
 501   3          }
 502   2        }
 503   1      
 504   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 505   1        {
 506   2          get_index = i;
 507   2          memset(password, 0xFF, sizeof(password));
 508   2          //g_dq_fs_pwd[i].index = i;
 509   2          mmi_dq_fs_pwd_string_to_byte(pwd, pwd_size, password);
 510   2          memcpy((char *)g_dq_fs_pwd[i].key_pwd, (const char *)password, 4);
 511   2          g_dq_fs_pwd[i].flag = type;
 512   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_P
             -WD_MAX_NUM);
 513   2        }
 514   1        return RET_FAIL;
 515   1      }
 516          
 517          /*
 518          parameter: 
 519            none
 520          return :
 521            none
 522          */
 523          RET_VAL mmi_dq_fs_del_pwd(unsigned char index, fds_use_type type)
 524          {
 525   1        if (index < MMI_DQ_FS_PWD_MAX_NUM && g_dq_fs_pwd[index].flag == type)
 526   1        {
 527   2          g_dq_fs_pwd[index].flag = FDS_USE_TYPE_INVALID;
 528   2          //g_dq_fs_pwd[index].index = 0xFF;
 529   2          memset(g_dq_fs_pwd[index].key_pwd, 0xFF, sizeof(g_dq_fs_pwd[index].key_pwd));
 530   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_P
             -WD_MAX_NUM);
 531   2        }
 532   1        return RET_FAIL;
 533   1      }
 534          
 535          /*
 536          parameter: 
 537            none
 538          return :
 539            none
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 10  

 540          */
 541          RET_VAL mmi_dq_fs_clr_pwd(void)
 542          {
 543   1        unsigned char i = PWD_ADMIN_NUM;
 544   1      #ifdef __LOCK_110_SUPPORT__
 545   1        i += PWD_110_NUM;
 546   1      #endif
 547   1        for (; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 548   1        {
 549   2          if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_USER)
 550   2          {
 551   3            g_dq_fs_pwd[i].flag = FDS_USE_TYPE_INVALID;
 552   3            //g_dq_fs_pwd[i].index = 0xFF;
 553   3            memset(g_dq_fs_pwd[i].key_pwd, 0xFF, sizeof(g_dq_fs_pwd[i].key_pwd));
 554   3          }
 555   2        }
 556   1        return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PW
             -D_MAX_NUM);
 557   1      }
 558          
 559          #if defined(__LOCK_FP_SUPPORT__)
              /*
              parameter: 
                none
              return :
                none
              */
              unsigned char mmi_dq_fs_get_fp_unuse_index(void)
              {
                unsigned char i = FP_ADMIN_NUM;
              #ifdef __LOCK_110_SUPPORT__
                i += FP_110_NUM;
              #endif
                for (; i < MMI_DQ_FS_FP_MAX_NUM; i++)
                {
                  if (g_dq_fs_fp[i].fp_index == 0xFF)
                    break;
                }
                if (i >= MMI_DQ_FS_FP_MAX_NUM)
                  return 0xFF;
                return i;
              }
              
              #ifdef __LOCK_110_SUPPORT__
              /*
              parameter: 
                none
              return :
                none
              */
              unsigned char mmi_dq_fs_get_fp_110_unuse_index(void)
              {
                unsigned char i = FP_ADMIN_NUM;
                unsigned char j = 0;
              
                for (; j < FP_110_NUM; j++)
                {
                  if (g_dq_fs_fp[i + j].fp_index == 0xFF)
                    break;
                }
                if (j >= FP_110_NUM)
                  return 0xFF;
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 11  

                return i + j;
              }
              #endif
              
              /*
              parameter: 
                none
              return :
                none
              */
              RET_VAL mmi_dq_fs_check_fp(unsigned char fp_index, fds_use_type type)
              {
                if ((fp_index < MMI_DQ_FS_FP_MAX_NUM) && (g_dq_fs_fp[fp_index].fp_index == fp_index) && ((g_dq_fs_fp[fp_i
             -ndex].flag == type) || (type == FDS_USE_TYPE_ALL)))
                  return RET_SUCESS;
                else
                  return RET_FAIL;
              }
              
              /*
              parameter: 
                none
              return :
                none
              */
              RET_VAL mmi_dq_fs_set_fp(unsigned char fs_index, fds_use_type type)
              {
                g_dq_fs_fp[fs_index].fp_index = fs_index;
                g_dq_fs_fp[fs_index].flag = type;
                return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MA
             -X_NUM);
              }
              
              /*
              parameter: 
                none
              return :
                none
              */
              RET_VAL mmi_dq_fs_del_fp(unsigned char fp_index, fds_use_type type)
              {
                if (mmi_dq_fs_check_fp(fp_index, type) == RET_SUCESS)
                {
                  g_dq_fs_fp[fp_index].flag = FDS_USE_TYPE_INVALID;
                  g_dq_fs_fp[fp_index].fp_index = 0xFF;
                  return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_M
             -AX_NUM);
                }
                return RET_FAIL;
              }
              
              /*
              parameter: 
                none
              return :
                none
              */
              RET_VAL mmi_dq_fs_clr_fp(void)
              {
                unsigned char i = FP_ADMIN_NUM;
                unsigned short fp_ret = 0;
              #ifdef __LOCK_110_SUPPORT__
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 12  

                i += FP_110_NUM;
              #endif
                for (; i < MMI_DQ_FS_FP_MAX_NUM; i++)
                {
                  if (g_dq_fs_fp[i].fp_index != 0xFF)
                  {
                    fp_ret = mmi_dq_fp_delete(g_dq_fs_fp[i].fp_index);
                    if (fp_ret == 0)
                    {
                      g_dq_fs_fp[i].flag = FDS_USE_TYPE_INVALID;
                      g_dq_fs_fp[i].fp_index = 0xFF;
                    }
                  }
                }
                return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MA
             -X_NUM);
              }
              
              #endif
 678          
 679          #ifdef __LOCK_RFID_CARD_SUPPORT__
 680          
 681          /*
 682          parameter: 
 683            none
 684          return :
 685            none
 686          */
 687          unsigned char mmi_dq_fs_get_rfid_unuse_index(void)
 688          {
 689   1        unsigned char i = 0;
 690   1      
 691   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 692   1        {
 693   2          if (g_dq_fs_rfid[i].index == 0xFF)
 694   2            break;
 695   2        }
 696   1      
 697   1        if (i >= MMI_DQ_FS_RFID_MAX_NUM)
 698   1          return 0xFF;
 699   1        return i;
 700   1      }
 701          
 702          /*
 703          parameter: 
 704            none
 705          return :
 706            none
 707          */
 708          unsigned char mmi_dq_fs_check_rfid(unsigned char *sec_data, fds_use_type type)
 709          {
 710   1        unsigned char i = 0, j = 0;
 711   1      
 712   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 713   1        {
 714   2          for (j = 0; j < RFID_SEC_DATA_LEN; j++)
 715   2          {
 716   3            if (g_dq_fs_rfid[i].sec_data[j] != sec_data[j])
 717   3              break;
 718   3          }
 719   2          if (j == RFID_SEC_DATA_LEN)
 720   2            break;
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 13  

 721   2        }
 722   1        if (i < MMI_DQ_FS_RFID_MAX_NUM && ((g_dq_fs_rfid[i].flag == type) || (type == FDS_USE_TYPE_ALL)))
 723   1        {
 724   2          return i;
 725   2        }
 726   1        else
 727   1        {
 728   2          return 0xFF;
 729   2        }
 730   1      }
 731          
 732          /*
 733          parameter: 
 734            none
 735          return :
 736            none
 737          */
 738          RET_VAL mmi_dq_fs_set_rfid(unsigned char *sec_data, fds_use_type type)
 739          {
 740   1        unsigned char i = 0, j = 0;
 741   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 742   1        {
 743   2          if (g_dq_fs_rfid[i].index == 0xFF)
 744   2            break;
 745   2        }
 746   1        if (i < MMI_DQ_FS_RFID_MAX_NUM)
 747   1        {
 748   2          get_index = i;
 749   2          g_dq_fs_rfid[i].index = i;
 750   2          g_dq_fs_rfid[i].flag = type;
 751   2          for (j = 0; j < RFID_SEC_DATA_LEN; j++)
 752   2          {
 753   3            g_dq_fs_rfid[i].sec_data[j] = sec_data[j];
 754   3          }
 755   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_
             -RFID_MAX_NUM);
 756   2        }
 757   1        return RET_FAIL;
 758   1      }
 759          
 760          /*
 761          parameter: 
 762            none
 763          return :
 764            none
 765          */
 766          RET_VAL mmi_dq_fs_del_rfid(unsigned char rfid_index)
 767          {
 768   1        if (rfid_index < MMI_DQ_FS_RFID_MAX_NUM && g_dq_fs_rfid[rfid_index].index == rfid_index)
 769   1        {
 770   2          g_dq_fs_rfid[rfid_index].index = 0xFF;
 771   2          g_dq_fs_rfid[rfid_index].flag = FDS_USE_TYPE_INVALID;
 772   2          memset(g_dq_fs_rfid[rfid_index].sec_data, 0xFF, sizeof(g_dq_fs_rfid[rfid_index].sec_data));
 773   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_
             -RFID_MAX_NUM);
 774   2        }
 775   1        return RET_FAIL;
 776   1      }
 777          
 778          /*
 779          parameter: 
 780            none
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 14  

 781          return :
 782            none
 783          */
 784          RET_VAL mmi_dq_fs_clr_rfid(void)
 785          {
 786   1        unsigned char i = 0;
 787   1      
 788   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 789   1        {
 790   2          g_dq_fs_rfid[i].flag = FDS_USE_TYPE_INVALID;
 791   2          g_dq_fs_rfid[i].index = 0xFF;
 792   2          memset(g_dq_fs_rfid[i].sec_data, 0xFF, sizeof(g_dq_fs_rfid[i].sec_data));
 793   2        }
 794   1        return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_R
             -FID_MAX_NUM);
 795   1      }
 796          
 797          #endif
 798          
 799          /*
 800          parameter: 
 801            none
 802          return :
 803            none
 804          */
 805          RET_VAL mmi_dq_fs_set_open_mode(sys_open_mode mode)
 806          {
 807   1        if (g_dq_fs_init_set.open_mode == mode)
 808   1          return RET_SUCESS;
 809   1      
 810   1        g_dq_fs_init_set.open_mode = mode;
 811   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 812   1      }
 813          /*
 814          parameter: 
 815            none
 816          return :
 817            none
 818          */
 819          sys_open_mode mmi_dq_fs_get_open_mode(void)
 820          {
 821   1        return g_dq_fs_init_set.open_mode;
 822   1      }
 823          
 824          /*
 825          parameter: 
 826            none
 827          return :
 828            none
 829          */
 830          RET_VAL mmi_dq_fs_set_pro_sound(unsigned char flag)
 831          {
 832   1        if (g_dq_fs_init_set.open_pro_sound == flag)
 833   1          return RET_SUCESS;
 834   1      
 835   1        g_dq_fs_init_set.open_pro_sound = flag;
 836   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 837   1      }
 838          
 839          /*
 840          parameter: 
 841            none
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 15  

 842          return :
 843            none
 844          */
 845          unsigned char mmi_dq_fs_get_pro_sound_state(void)
 846          {
 847   1        return g_dq_fs_init_set.open_pro_sound;
 848   1      }
 849          
 850          /*
 851          parameter: 
 852            none
 853          return :
 854            none
 855          */
 856          unsigned char mmi_dq_fs_get_init_flag(void)
 857          {
 858   1        return g_dq_fs_init_set.init_flag;
 859   1      }
 860          
 861          /*
 862          parameter: 
 863            none
 864          return :
 865            none
 866          */
 867          RET_VAL mmi_dq_fs_set_init_flag(unsigned char flag)
 868          {
 869   1        g_dq_fs_init_set.init_flag = flag;
 870   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 871   1      }
 872          
 873          /*
 874          parameter: 
 875            none
 876          return :
 877            none
 878          */
 879          RET_VAL mmi_dq_fs_set_factory_flag(unsigned char flag)
 880          {
 881   1        g_dq_fs_init_set.factory_flag = flag;
 882   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 883   1      }
 884          
 885          /*
 886          parameter: 
 887            none
 888          return :
 889            none
 890          */
 891          unsigned char mmi_dq_fs_get_factory_flag(void)
 892          {
 893   1        return g_dq_fs_init_set.factory_flag;
 894   1      }
 895          
 896          /*
 897          parameter: 
 898            none
 899          return :
 900            none
 901          */
 902          unsigned char mmi_dq_fs_get_admin_status(void)
 903          {
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 16  

 904   1        return g_dq_fs_init_set.admin_status;
 905   1      }
 906          
 907          /*
 908          parameter: 
 909            none
 910          return :
 911            none
 912          */
 913          RET_VAL mmi_dq_fs_set_admin_status(unsigned char status)
 914          {
 915   1        g_dq_fs_init_set.admin_status = status;
 916   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 917   1      }
 918          
 919          #if 0
              /*
              parameter: 
                none
              return :
                none
              */
              RET_VAL mmi_dq_fs_set_wifi_setting(unsigned char flag)
              {
                g_dq_fs_init_set.wifi_flag = flag;
                return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
              }
              
              /*
              parameter: 
                none
              return :
                none
              */
              unsigned char mmi_dq_fs_get_wifi_setting(void)
              {
                return g_dq_fs_init_set.wifi_flag;
              }
              #endif
 943          
 944          /*
 945          parameter: 
 946            none
 947          return :
 948            none
 949          */
 950          RET_VAL mmi_dq_fs_set_business_flag(unsigned char flag)
 951          {
 952   1      #if 1
 953   1        if (flag != g_dq_fs_init_set.business_flag)
 954   1        {
 955   2          g_dq_fs_init_set.business_flag = flag;
 956   2          return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 957   2        }
 958   1      #else
                g_dq_fs_init_set.business_flag = flag;
              #endif
 961   1        return RET_SUCESS;
 962   1      }
 963          
 964          /*
 965          parameter: 
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 17  

 966            none
 967          return :
 968            none
 969          */
 970          unsigned char mmi_dq_fs_get_business_flag(void)
 971          {
 972   1        return g_dq_fs_init_set.business_flag;
 973   1      }
 974          
 975          /************************************************************************************
 976           *                     Own function                     *
 977           ************************************************************************************/
 978          #ifdef __LOCK_VIRTUAL_PASSWORD__
              #ifdef __LOCK_VIRTUAL_PASSWORD__
              uint8_t input_empty_pwd_len = 0;
              unsigned char mmi_dq_fs_check_input_pwd_from_app(unsigned char *input_pwd, unsigned char len)
              {
                unsigned char ret_val = 0xFF;
                unsigned char admin_pwd[4];
                unsigned char admin_password[8];
                uint8_t admin_len = 0;
                uint8_t i, k;
              
              #ifdef __LOCK_USE_MALLOC__
                uint8_t ret;
                g_dq_fs_pwd = (mmi_fs_pwd *)mmi_dq_fs_get_storage(DQ_FS_MEM_PWD, &ret);
              #endif
              
                memset(admin_password, 0xFF, 8);
                for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
                {
                  if (g_dq_fs_pwd[i].flag != 0xFF && g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
                  {
                    for (k = 0; k < 4; k++)
                    {
                      admin_pwd[k] = g_dq_fs_pwd[i].key_pwd[k];
                    }
                    break;
                  }
                }
              #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_PWD, (void **)&g_dq_fs_pwd);
              #endif
              
                mmi_dq_fs_pwd_byte_to_string(admin_pwd, admin_password);
                for (i = 0; i < 8; i++)
                {
                  if (admin_password[i] == 0xFF)
                    break;
                }
                admin_len = i;
                if (len >= admin_len)
                {
                  for (i = 0; i <= len - admin_len; i++)
                  {
                    for (k = 0; k < admin_len; k++)
                    {
                      if (input_pwd[i + k] != admin_password[k])
                        break;
                    }
                    if (k == admin_len)
                    {
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 18  

                      dq_otp_add_temp_open_log(0, DQ_OPEN_LOG_ADMIN_PASSWORD, admin_pwd, 4);
                      mmi_dq_fs_check_input_pwd_from_app_cb(1);
                      return 0;
                    }
                  }
                }
              
                if (len == 8)
                  input_empty_pwd_len = 1;
                else
                  input_empty_pwd_len = 0;
              
                for (i = 9; i >= 6; i--)
                {
                  if (len < i)
                    continue;
                  for (k = 0; k <= len - i; k++)
                  {
                    unsigned char password[5];
                    memset(password, 0xFF, sizeof(password));
                    mmi_dq_fs_pwd_string_to_byte(input_pwd + k, i, password);
                    ret_val = dq_otp_check_password_for_open(password, i);
                    if (ret_val != 0)
                    {
                      return 0;
                    }
                  }
                }
              
                mmi_dq_ms_idle_input_with_app_result(0xFF);
              
                return 0;
              }
              
              #else
              unsigned char mmi_dq_fs_check_input_pwd_from_app(unsigned char *input_pwd, unsigned char len)
              {
                unsigned char password[5];
                unsigned char ret_val = 0xFF;
              
                memset(password, 0xFF, sizeof(password));
                mmi_dq_fs_pwd_string_to_byte(input_pwd, len, password);
              
                if (len <= MMI_KEY_MAX_INPUT_NUM)
                {
                  ret_val = mmi_dq_fs_check_input_pwd(input_pwd, len, (fds_pwd_type)FDS_USE_TYPE_ADMIN);
                  if (ret_val != 0xFF)
                  {
                    ret_val = 1;
                    dq_otp_add_temp_open_log(0, DQ_OPEN_LOG_ADMIN_PASSWORD, password, 5);
                    mmi_dq_fs_check_input_pwd_from_app_cb(ret_val);
                    return 0;
                  }
                }
              
                dq_otp_check_password_for_open(password, len);
              
                return 0;
              }
              #endif
              
              extern void mmi_dq_ms_idle_input_with_app_result(unsigned char ret_val);
C51 COMPILER V9.59.0.0   MMI_FS                                                            04/23/2021 10:12:30 PAGE 19  

              void mmi_dq_fs_check_input_pwd_from_app_cb(unsigned char ret_val)
              {
                if (ret_val != 1 && ret_val != 2 && ret_val != 4 && ret_val != 5 && ret_val != 6)
                  ret_val = 0xFF;
              
                if (ret_val != 0xFF && ret_val != 4 && ret_val != 6)
                  printfS("mmi_dq_fs_check_input_pwd_from_app", "right");
                else
                  printfS("mmi_dq_fs_check_input_pwd_from_app", "wrong");
              
              #ifdef __LOCK_VIRTUAL_PASSWORD__
              
                if (ret_val != 0xFF)
                  mmi_dq_ms_idle_input_with_app_result(ret_val);
              #else
                mmi_dq_ms_idle_input_with_app_result(ret_val);
              #endif
              }
              
              unsigned char mmi_dq_fs_app_init_sucess(void)
              {
                if (g_dq_fs_init_set.init_flag == FDS_INIT_APP_SUC)
                  return 1;
                else
                  return 0;
              }
              
              #endif //__LOCK_VIRTUAL_PASSWORD__
1118          /************************************************************************************
1119           *                     End function                     *
1120           ************************************************************************************/
1121          
1122          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3487    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    641     103
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     15    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
