C51 COMPILER V9.59.0.0   MMI_FS                                                            02/22/2021 17:53:07 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MMI_FS
OBJECT MODULE PLACED IN .\output\mmi_fs.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE mmi_src\mmi_fs.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;.\
                    -Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd_rfi
                    -d;.\mmi_inc) DEBUG PRINT(.\list\mmi_fs.lst) TABS(2) OBJECT(.\output\mmi_fs.obj)

line level    source

   1          #ifndef __MMI_FS_C__
   2          #define __MMI_FS_C__
   3          
   4          #include "mmi_fs.h"
   5          #include "mmi_sys.h"
   6          #include "mcu02_sfr.h"
   7          #include "mcu02_eeprom.h"
   8          #include "string.h"
   9          //#include "stdio.h"
  10          
  11          #include "mmi_fps.h"
  12          
  13          mmi_fs_setting g_dq_fs_init_set;
  14          
  15          #define MMI_DQ_FS_PWD_MAX_NUM 100
  16          mmi_fs_pwd g_dq_fs_pwd[MMI_DQ_FS_PWD_MAX_NUM];
  17          
  18          #if defined(__LOCK_FP_SUPPORT__)
  19          #define MMI_DQ_FS_FP_MAX_NUM 50
  20          mmi_fs_fp g_dq_fs_fp[MMI_DQ_FS_FP_MAX_NUM];
  21          #endif
  22          
  23          #ifdef __LOCK_RFID_CARD_SUPPORT__
  24          #define MMI_DQ_FS_RFID_MAX_NUM 10
  25          mmi_fs_rfid g_dq_fs_rfid[MMI_DQ_FS_RFID_MAX_NUM];
  26          #endif
  27          
  28          static void mmi_dq_fds_read(mid_fds_file_id file, uint8_t *r_data, uint16_t r_size)
  29          {
  30   1        uint16_t i;
  31   1      
  32   1        switch (file)
  33   1        {
  34   2        case MID_FDS_FILE_SET:
  35   2          eeprom_select(0);
  36   2          for (i = 0; i < r_size; i++)
  37   2          {
  38   3            r_data[i] = eeprom_read_byte(0, i); //读第一页
  39   3          }
  40   2          break;
  41   2        case MID_FDS_FILE_PWD:
  42   2          eeprom_select(0);
  43   2          for (i = 0; i < r_size; i++)
  44   2          {
  45   3            r_data[i] = eeprom_read_byte(0, i + 24); //读第一页
  46   3          }
  47   2          break;
  48   2        case MID_FDS_FILE_FP:
  49   2          eeprom_select(1);
  50   2          eeprom_nvr_read_page(r_data, 0, 0, r_size);
  51   2          break;
  52   2        case MID_FDS_FILE_RF:
  53   2          eeprom_select(1);
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/22/2021 17:53:07 PAGE 2   

  54   2          eeprom_nvr_read_page(r_data, 1, 0, r_size);
  55   2          break;
  56   2        default:
  57   2          break;
  58   2        }
  59   1      }
  60          
  61          static RET_VAL mmi_dq_fds_write(mid_fds_file_id file, uint8_t *w_data, uint16_t w_size)
  62          {
  63   1        uint16_t i;
  64   1        ErrStatus ret;
  65   1        eeprom_erase_time(9);
  66   1        switch (file)
  67   1        {
  68   2        case MID_FDS_FILE_SET:
  69   2        {
  70   3          uint8_t *w_data2 = (uint8_t *)g_dq_fs_pwd;
  71   3          uint16_t w_size2 = sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_NUM;
  72   3          eeprom_select(0);
  73   3          eeprom_erase_page(0); //擦除1K
  74   3          for (i = 0; i < w_size; i++)
  75   3          {
  76   4            ret = eeprom_write_byte(0, i, w_data[i]); //读第一页
  77   4            if (ret == ERROR)
  78   4            {
  79   5              //printf("mmi_dq_fds_write  error  %d\n",i);
  80   5              return RET_FAIL;
  81   5            }
  82   4          }
  83   3          for (i = 0; i < w_size2; i++)
  84   3          {
  85   4            ret = eeprom_write_byte(0, i + 24, w_data2[i]); //读第一页
  86   4            if (ret == ERROR)
  87   4            {
  88   5              //printf("mmi_dq_fds_write  error  %d\n",i);
  89   5              return RET_FAIL;
  90   5            }
  91   4          }
  92   3        }
  93   2        break;
  94   2        case MID_FDS_FILE_PWD:
  95   2        {
  96   3          uint8_t *w_data2 = (uint8_t *)&g_dq_fs_init_set;
  97   3          uint16_t w_size2 = sizeof(mmi_fs_setting);
  98   3          eeprom_select(0);
  99   3          eeprom_erase_page(0); //擦除1K
 100   3          for (i = 0; i < w_size2; i++)
 101   3          {
 102   4            ret = eeprom_write_byte(0, i, w_data2[i]); //读第一页
 103   4            if (ret == ERROR)
 104   4            {
 105   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 106   5              return RET_FAIL;
 107   5            }
 108   4          }
 109   3          for (i = 0; i < w_size; i++)
 110   3          {
 111   4            ret = eeprom_write_byte(0, i + 24, w_data[i]); //读第一页
 112   4            if (ret == ERROR)
 113   4            {
 114   5              //printf("mmi_dq_fds_write  error  %d\n",i);
 115   5              return RET_FAIL;
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/22/2021 17:53:07 PAGE 3   

 116   5            }
 117   4          }
 118   3        }
 119   2        break;
 120   2        case MID_FDS_FILE_FP:
 121   2          eeprom_select(1);
 122   2          eeprom_erase_page(0); //擦除512byte
 123   2          for (i = 0; i < w_size; i++)
 124   2          {
 125   3            ret = eeprom_write_byte(0, i, w_data[i]);
 126   3            if (ret == ERROR)
 127   3            {
 128   4              //printf("mmi_dq_fds_write  error  %d\n",i);
 129   4              return RET_FAIL;
 130   4            }
 131   3          }
 132   2          break;
 133   2        case MID_FDS_FILE_RF:
 134   2          eeprom_select(1);
 135   2          eeprom_erase_page(1); //擦除512byte
 136   2          for (i = 0; i < w_size; i++)
 137   2          {
 138   3            ret = eeprom_write_byte(1, i, w_data[i]);
 139   3            if (ret == ERROR)
 140   3            {
 141   4              //printf("mmi_dq_fds_write  error  %d\n",i);
 142   4              return RET_FAIL;
 143   4            }
 144   3          }
 145   2          break;
 146   2        default:
 147   2          return RET_FAIL;
 148   2        }
 149   1        //printf("mmi_dq_fds_write  suc\n");
 150   1        return RET_SUCESS;
 151   1      }
 152          
 153          /*
 154          parameter: 
 155            none
 156          return :
 157            none
 158          */
 159          void mmi_dq_fs_init(void)
 160          {
 161   1        mmi_dq_fds_read(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 162   1        if (FDS_INIT_LOCK_SUC == g_dq_fs_init_set.init_flag || FDS_INIT_APP_SUC == g_dq_fs_init_set.init_flag)
 163   1        {
 164   2          unsigned char i = 0;
 165   2          mmi_dq_fds_read(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_N
             -UM);
 166   2          mmi_dq_fds_read(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM);
 167   2          mmi_dq_fds_read(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MAX
             -_NUM);
 168   2          if (g_dq_fs_init_set.admin_status > 0)
 169   2          {
 170   3            for (; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 171   3            {
 172   4              if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
 173   4                break;
 174   4            }
 175   3            if (i >= MMI_DQ_FS_PWD_MAX_NUM)
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/22/2021 17:53:07 PAGE 4   

 176   3            {
 177   4              g_dq_fs_init_set.admin_status = 0;
 178   4              mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 179   4            }
 180   3          }
 181   2        }
 182   1        else
 183   1        {
 184   2          //printf("mmi_dq_fs_init init error");
 185   2          memset(g_dq_fs_pwd, 0xFF, sizeof(g_dq_fs_pwd));
 186   2          mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_
             -NUM);
 187   2      
 188   2          memset(g_dq_fs_fp, 0xFF, sizeof(g_dq_fs_fp));
 189   2          mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM)
             -;
 190   2      
 191   2          mmi_dq_fp_empty();
 192   2      
 193   2          memset(g_dq_fs_rfid, 0xFF, sizeof(g_dq_fs_rfid));
 194   2          mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MA
             -X_NUM);
 195   2      
 196   2          g_dq_fs_init_set.init_flag = FDS_INIT_LOCK_SUC;
 197   2          g_dq_fs_init_set.open_pro_sound = 1;
 198   2          g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 199   2          g_dq_fs_init_set.admin_status = 0;
 200   2          g_dq_fs_init_set.factory_flag = 0;
 201   2          g_dq_fs_init_set.wifi_flag = 0;
 202   2          mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 203   2        }
 204   1      }
 205          
 206          /**
 207            * @brief  手动初始化
 208            * @param  none
 209            * @return none
 210            * @note   none
 211            * @see    none
 212            */
 213          RET_VAL mmi_dq_fs_clr_set(void)
 214          {
 215   1        g_dq_fs_init_set.open_pro_sound = 1;
 216   1        g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 217   1      
 218   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 219   1      }
 220          
 221          /**
 222            * @brief  复位初始化
 223            * @param  none
 224            * @return none
 225            * @note   none
 226            * @see    none
 227            */
 228          RET_VAL mmi_dq_fs_reset(void)
 229          {
 230   1        memset(g_dq_fs_pwd, 0xFF, sizeof(g_dq_fs_pwd));
 231   1        mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PWD_MAX_N
             -UM);
 232   1      
 233   1        memset(g_dq_fs_fp, 0xFF, sizeof(g_dq_fs_fp));
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/22/2021 17:53:07 PAGE 5   

 234   1        mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MAX_NUM);
 235   1      
 236   1        mmi_dq_fp_empty();
 237   1      
 238   1        memset(g_dq_fs_rfid, 0xFF, sizeof(g_dq_fs_rfid));
 239   1        mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_RFID_MAX
             -_NUM);
 240   1      
 241   1        g_dq_fs_init_set.init_flag = FDS_INIT_LOCK_SUC;
 242   1        g_dq_fs_init_set.open_pro_sound = 1;
 243   1        g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 244   1        g_dq_fs_init_set.admin_status = 0;
 245   1        g_dq_fs_init_set.wifi_flag = 0;
 246   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 247   1      }
 248          
 249          /*
 250          parameter: 
 251            none
 252          return :
 253            none
 254          */
 255          void mmi_dq_fs_pwd_string_to_byte(unsigned char *input_pwd, unsigned char pwd_len, unsigned char *output_p
             -wd)
 256          {
 257   1        unsigned char i = 0;
 258   1        unsigned char bit_l = 0;
 259   1        unsigned char bit_h = 0;
 260   1      
 261   1        for (i = 0; i < pwd_len; i++)
 262   1        {
 263   2          bit_l = *(input_pwd + i) & 0x0F;
 264   2          i++;
 265   2          if (i < pwd_len)
 266   2            bit_h = *(input_pwd + i) & 0x0F;
 267   2          else
 268   2            bit_h = 0xF;
 269   2          *output_pwd++ = bit_l << 4 | bit_h;
 270   2        }
 271   1        return;
 272   1      }
 273          /*
 274          parameter: 
 275            none
 276          return :
 277            none
 278          */
 279          void mmi_dq_fs_pwd_byte_to_string(unsigned char *input_pwd, unsigned char *output_pwd)
 280          {
 281   1        unsigned char i = 0;
 282   1        unsigned char pwd = 0;
 283   1        for (i = 0; i < 4; i++)
 284   1        {
 285   2          pwd = *(input_pwd + i);
 286   2          if (pwd == 0xFF)
 287   2            break;
 288   2          else
 289   2            *output_pwd++ = (pwd & 0xF0) >> 4;
 290   2          if ((pwd & 0x0F) == 0x0F)
 291   2            break;
 292   2          else
 293   2          {
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/22/2021 17:53:07 PAGE 6   

 294   3            *output_pwd++ = pwd & 0x0F;
 295   3          }
 296   2        }
 297   1        return;
 298   1      }
 299          
 300          /*
 301          parameter: 
 302            none
 303          return :
 304            none
 305          */
 306          unsigned char mmi_dq_fs_get_pwd_unuse_index(void)
 307          {
 308   1        unsigned char i = 0;
 309   1      
 310   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 311   1        {
 312   2          if (g_dq_fs_pwd[i].flag == 0xFF)
 313   2            break;
 314   2        }
 315   1      
 316   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 317   1          return i;
 318   1        else
 319   1          return 0xFF;
 320   1      }
 321          
 322          /*
 323          parameter: 
 324            none
 325          return :
 326            none
 327          */
 328          unsigned char mmi_dq_fs_check_input_pwd(unsigned char *input_pwd, unsigned char len, fds_use_type type)
 329          {
 330   1        unsigned char i = 0;
 331   1        unsigned char k = 0;
 332   1        unsigned char password[4];
 333   1        unsigned char ret_val = 0xFF;
 334   1      
 335   1        memset(password, 0xFF, sizeof(password));
 336   1        mmi_dq_fs_pwd_string_to_byte(input_pwd, len, password);
 337   1      
 338   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 339   1        {
 340   2          if (g_dq_fs_pwd[i].flag != 0xFF)
 341   2          {
 342   3            for (k = 0; k < 4; k++)
 343   3            {
 344   4              if (password[k] != g_dq_fs_pwd[i].key_pwd[k])
 345   4                break;
 346   4            }
 347   3            if (k == 4)
 348   3            {
 349   4              break;
 350   4            }
 351   3          }
 352   2        }
 353   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 354   1        {
 355   2          if ((g_dq_fs_pwd[i].flag == type) || (type == FDS_USE_TYPE_ALL))
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/22/2021 17:53:07 PAGE 7   

 356   2            ret_val = i;
 357   2          else
 358   2            ret_val = 0xFF;
 359   2        }
 360   1        else
 361   1          ret_val = 0xFF;
 362   1      
 363   1        return ret_val;
 364   1      }
 365          
 366          /*
 367          parameter: 
 368            none
 369          return :
 370            none
 371          */
 372          RET_VAL mmi_dq_fs_set_pwd(unsigned char *pwd, unsigned char pwd_size, fds_use_type type)
 373          {
 374   1        unsigned char i = 0xFF;
 375   1        unsigned char password[4];
 376   1      
 377   1        if (type == FDS_USE_TYPE_ADMIN)
 378   1        {
 379   2          for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 380   2          {
 381   3            if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
 382   3              break;
 383   3          }
 384   2        }
 385   1        if (i >= MMI_DQ_FS_PWD_MAX_NUM)
 386   1        {
 387   2          for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 388   2          {
 389   3            if (g_dq_fs_pwd[i].flag == 0xFF)
 390   3              break;
 391   3          }
 392   2        }
 393   1        if (i < MMI_DQ_FS_PWD_MAX_NUM)
 394   1        {
 395   2          memset(password, 0xFF, sizeof(password));
 396   2          //g_dq_fs_pwd[i].index = i;
 397   2          mmi_dq_fs_pwd_string_to_byte(pwd, pwd_size, password);
 398   2          memcpy((char *)g_dq_fs_pwd[i].key_pwd, (const char *)password, 4);
 399   2          g_dq_fs_pwd[i].flag = type;
 400   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_P
             -WD_MAX_NUM);
 401   2        }
 402   1        return RET_FAIL;
 403   1      }
 404          
 405          /*
 406          parameter: 
 407            none
 408          return :
 409            none
 410          */
 411          RET_VAL mmi_dq_fs_del_pwd(unsigned char index, fds_use_type type)
 412          {
 413   1        if (index < MMI_DQ_FS_PWD_MAX_NUM && g_dq_fs_pwd[index].flag == type)
 414   1        {
 415   2          g_dq_fs_pwd[index].flag = FDS_USE_TYPE_INVALID;
 416   2          //g_dq_fs_pwd[index].index = 0xFF;
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/22/2021 17:53:07 PAGE 8   

 417   2          memset(g_dq_fs_pwd[index].key_pwd, 0xFF, sizeof(g_dq_fs_pwd[index].key_pwd));
 418   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_P
             -WD_MAX_NUM);
 419   2        }
 420   1        return RET_FAIL;
 421   1      }
 422          
 423          /*
 424          parameter: 
 425            none
 426          return :
 427            none
 428          */
 429          RET_VAL mmi_dq_fs_clr_pwd(void)
 430          {
 431   1        unsigned char i = 0;
 432   1      
 433   1        for (i = 0; i < MMI_DQ_FS_PWD_MAX_NUM; i++)
 434   1        {
 435   2          if (g_dq_fs_pwd[i].flag == FDS_USE_TYPE_USER)
 436   2          {
 437   3            g_dq_fs_pwd[i].flag = FDS_USE_TYPE_INVALID;
 438   3            //g_dq_fs_pwd[i].index = 0xFF;
 439   3            memset(g_dq_fs_pwd[i].key_pwd, 0xFF, sizeof(g_dq_fs_pwd[i].key_pwd));
 440   3          }
 441   2        }
 442   1        return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd) * MMI_DQ_FS_PW
             -D_MAX_NUM);
 443   1      }
 444          
 445          #if defined(__LOCK_FP_SUPPORT__)
 446          /*
 447          parameter: 
 448            none
 449          return :
 450            none
 451          */
 452          unsigned char mmi_dq_fs_get_fp_unuse_index(void)
 453          {
 454   1        unsigned char i = 2;
 455   1      
 456   1        for (; i < MMI_DQ_FS_FP_MAX_NUM; i++)
 457   1        {
 458   2          if (g_dq_fs_fp[i].fp_index == 0xFF)
 459   2            break;
 460   2        }
 461   1        if (i >= MMI_DQ_FS_FP_MAX_NUM)
 462   1          return 0xFF;
 463   1        return i;
 464   1      }
 465          
 466          /*
 467          parameter: 
 468            none
 469          return :
 470            none
 471          */
 472          RET_VAL mmi_dq_fs_check_fp(unsigned char fp_index, fds_use_type type)
 473          {
 474   1        if ((fp_index < MMI_DQ_FS_FP_MAX_NUM) && (g_dq_fs_fp[fp_index].fp_index == fp_index) && ((g_dq_fs_fp[fp_i
             -ndex].flag == type) || (type == FDS_USE_TYPE_ALL)))
 475   1          return RET_SUCESS;
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/22/2021 17:53:07 PAGE 9   

 476   1        else
 477   1          return RET_FAIL;
 478   1      }
 479          
 480          /*
 481          parameter: 
 482            none
 483          return :
 484            none
 485          */
 486          RET_VAL mmi_dq_fs_set_fp(unsigned char fs_index, fds_use_type type)
 487          {
 488   1        g_dq_fs_fp[fs_index].fp_index = fs_index;
 489   1        g_dq_fs_fp[fs_index].flag = type;
 490   1        return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MA
             -X_NUM);
 491   1      }
 492          
 493          /*
 494          parameter: 
 495            none
 496          return :
 497            none
 498          */
 499          RET_VAL mmi_dq_fs_del_fp(unsigned char fp_index, fds_use_type type)
 500          {
 501   1        if (mmi_dq_fs_check_fp(fp_index, type) == RET_SUCESS)
 502   1        {
 503   2          g_dq_fs_fp[fp_index].flag = FDS_USE_TYPE_INVALID;
 504   2          g_dq_fs_fp[fp_index].fp_index = 0xFF;
 505   2          return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_M
             -AX_NUM);
 506   2        }
 507   1        return RET_FAIL;
 508   1      }
 509          
 510          /*
 511          parameter: 
 512            none
 513          return :
 514            none
 515          */
 516          RET_VAL mmi_dq_fs_clr_fp(void)
 517          {
 518   1        unsigned char i = 0;
 519   1        unsigned short fp_ret = 0;
 520   1      
 521   1        for (i = 0; i < MMI_DQ_FS_FP_MAX_NUM; i++)
 522   1        {
 523   2          if (g_dq_fs_fp[i].flag != FDS_USE_TYPE_ADMIN)
 524   2          {
 525   3            if (g_dq_fs_fp[i].fp_index != 0xFF)
 526   3            {
 527   4              fp_ret = mmi_dq_fp_delete(g_dq_fs_fp[i].fp_index);
 528   4              if (fp_ret == 0)
 529   4              {
 530   5                g_dq_fs_fp[i].flag = FDS_USE_TYPE_INVALID;
 531   5                g_dq_fs_fp[i].fp_index = 0xFF;
 532   5              }
 533   4            }
 534   3          }
 535   2        }
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/22/2021 17:53:07 PAGE 10  

 536   1      
 537   1        return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp) * MMI_DQ_FS_FP_MA
             -X_NUM);
 538   1      }
 539          
 540          #endif
 541          
 542          #ifdef __LOCK_RFID_CARD_SUPPORT__
 543          
 544          /*
 545          parameter: 
 546            none
 547          return :
 548            none
 549          */
 550          unsigned char mmi_dq_fs_get_rfid_unuse_index(void)
 551          {
 552   1        unsigned char i = 0;
 553   1      
 554   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 555   1        {
 556   2          if (g_dq_fs_rfid[i].index == 0xFF)
 557   2            break;
 558   2        }
 559   1      
 560   1        if (i >= MMI_DQ_FS_RFID_MAX_NUM)
 561   1          return 0xFF;
 562   1        return i;
 563   1      }
 564          
 565          /*
 566          parameter: 
 567            none
 568          return :
 569            none
 570          */
 571          unsigned char mmi_dq_fs_check_rfid(unsigned char *sec_data, fds_use_type type)
 572          {
 573   1        unsigned char i = 0, j = 0;
 574   1      
 575   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 576   1        {
 577   2          for (j = 0; j < RFID_SEC_DATA_LEN; j++)
 578   2          {
 579   3            if (g_dq_fs_rfid[i].sec_data[j] != sec_data[j])
 580   3              break;
 581   3          }
 582   2          if (j == RFID_SEC_DATA_LEN)
 583   2            break;
 584   2        }
 585   1        if (i < MMI_DQ_FS_RFID_MAX_NUM && ((g_dq_fs_rfid[i].flag == type) || (type == FDS_USE_TYPE_ALL)))
 586   1        {
 587   2          return i;
 588   2        }
 589   1        else
 590   1        {
 591   2          return 0xFF;
 592   2        }
 593   1      }
 594          
 595          /*
 596          parameter: 
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/22/2021 17:53:07 PAGE 11  

 597            none
 598          return :
 599            none
 600          */
 601          RET_VAL mmi_dq_fs_set_rfid(unsigned char *sec_data, fds_use_type type)
 602          {
 603   1        unsigned char i = 0, j = 0;
 604   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 605   1        {
 606   2          if (g_dq_fs_rfid[i].index == 0xFF)
 607   2            break;
 608   2        }
 609   1        if (i < MMI_DQ_FS_RFID_MAX_NUM)
 610   1        {
 611   2          g_dq_fs_rfid[i].index = i;
 612   2          g_dq_fs_rfid[i].flag = type;
 613   2          for (j = 0; j < RFID_SEC_DATA_LEN; j++)
 614   2          {
 615   3            g_dq_fs_rfid[i].sec_data[j] = sec_data[j];
 616   3          }
 617   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_
             -RFID_MAX_NUM);
 618   2        }
 619   1        return RET_FAIL;
 620   1      }
 621          
 622          /*
 623          parameter: 
 624            none
 625          return :
 626            none
 627          */
 628          RET_VAL mmi_dq_fs_del_rfid(unsigned char rfid_index)
 629          {
 630   1        if (rfid_index < MMI_DQ_FS_RFID_MAX_NUM && g_dq_fs_rfid[rfid_index].index == rfid_index)
 631   1        {
 632   2          g_dq_fs_rfid[rfid_index].index = 0xFF;
 633   2          g_dq_fs_rfid[rfid_index].flag = FDS_USE_TYPE_INVALID;
 634   2          memset(g_dq_fs_rfid[rfid_index].sec_data, 0xFF, sizeof(g_dq_fs_rfid[rfid_index].sec_data));
 635   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_
             -RFID_MAX_NUM);
 636   2        }
 637   1        return RET_FAIL;
 638   1      }
 639          
 640          /*
 641          parameter: 
 642            none
 643          return :
 644            none
 645          */
 646          RET_VAL mmi_dq_fs_clr_rfid(void)
 647          {
 648   1        unsigned char i = 0;
 649   1      
 650   1        for (i = 0; i < MMI_DQ_FS_RFID_MAX_NUM; i++)
 651   1        {
 652   2          g_dq_fs_rfid[i].flag = FDS_USE_TYPE_INVALID;
 653   2          g_dq_fs_rfid[i].index = 0xFF;
 654   2          memset(g_dq_fs_rfid[i].sec_data, 0xFF, sizeof(g_dq_fs_rfid[i].sec_data));
 655   2        }
 656   1        return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid) * MMI_DQ_FS_R
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/22/2021 17:53:07 PAGE 12  

             -FID_MAX_NUM);
 657   1      }
 658          
 659          #endif
 660          
 661          /*
 662          parameter: 
 663            none
 664          return :
 665            none
 666          */
 667          RET_VAL mmi_dq_fs_set_open_mode(sys_open_mode mode)
 668          {
 669   1        if (g_dq_fs_init_set.open_mode == mode)
 670   1          return RET_SUCESS;
 671   1      
 672   1        g_dq_fs_init_set.open_mode = mode;
 673   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 674   1      }
 675          /*
 676          parameter: 
 677            none
 678          return :
 679            none
 680          */
 681          sys_open_mode mmi_dq_fs_get_open_mode(void)
 682          {
 683   1        return g_dq_fs_init_set.open_mode;
 684   1      }
 685          
 686          /*
 687          parameter: 
 688            none
 689          return :
 690            none
 691          */
 692          RET_VAL mmi_dq_fs_set_pro_sound(unsigned char flag)
 693          {
 694   1        if (g_dq_fs_init_set.open_pro_sound == flag)
 695   1          return RET_SUCESS;
 696   1      
 697   1        g_dq_fs_init_set.open_pro_sound = flag;
 698   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 699   1      }
 700          
 701          /*
 702          parameter: 
 703            none
 704          return :
 705            none
 706          */
 707          unsigned char mmi_dq_fs_get_pro_sound_state(void)
 708          {
 709   1        return g_dq_fs_init_set.open_pro_sound;
 710   1      }
 711          
 712          /*
 713          parameter: 
 714            none
 715          return :
 716            none
 717          */
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/22/2021 17:53:07 PAGE 13  

 718          unsigned char mmi_dq_fs_get_init_flag(void)
 719          {
 720   1        return g_dq_fs_init_set.init_flag;
 721   1      }
 722          
 723          /*
 724          parameter: 
 725            none
 726          return :
 727            none
 728          */
 729          RET_VAL mmi_dq_fs_set_init_flag(unsigned char flag)
 730          {
 731   1        g_dq_fs_init_set.init_flag = flag;
 732   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 733   1      }
 734          
 735          /*
 736          parameter: 
 737            none
 738          return :
 739            none
 740          */
 741          RET_VAL mmi_dq_fs_set_factory_flag(unsigned char flag)
 742          {
 743   1        g_dq_fs_init_set.factory_flag = flag;
 744   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 745   1      }
 746          
 747          /*
 748          parameter: 
 749            none
 750          return :
 751            none
 752          */
 753          unsigned char mmi_dq_fs_get_factory_flag(void)
 754          {
 755   1        return g_dq_fs_init_set.factory_flag;
 756   1      }
 757          
 758          /*
 759          parameter: 
 760            none
 761          return :
 762            none
 763          */
 764          unsigned char mmi_dq_fs_get_admin_status(void)
 765          {
 766   1        return g_dq_fs_init_set.admin_status;
 767   1      }
 768          
 769          /*
 770          parameter: 
 771            none
 772          return :
 773            none
 774          */
 775          RET_VAL mmi_dq_fs_set_admin_status(unsigned char status)
 776          {
 777   1        g_dq_fs_init_set.admin_status = status;
 778   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 779   1      }
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/22/2021 17:53:07 PAGE 14  

 780          
 781          /*
 782          parameter: 
 783            none
 784          return :
 785            none
 786          */
 787          RET_VAL mmi_dq_fs_set_wifi_setting(unsigned char flag)
 788          {
 789   1        g_dq_fs_init_set.wifi_flag = flag;
 790   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 791   1      }
 792          
 793          /*
 794          parameter: 
 795            none
 796          return :
 797            none
 798          */
 799          unsigned char mmi_dq_fs_get_wifi_setting(void)
 800          {
 801   1        return g_dq_fs_init_set.wifi_flag;
 802   1      }
 803          
 804          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3548    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    750      68
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
