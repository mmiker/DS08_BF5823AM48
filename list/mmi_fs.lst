C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:34:47 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MMI_FS
OBJECT MODULE PLACED IN .\output\mmi_fs.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE mmi_src\mmi_fs.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;.\
                    -Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\byd_rfi
                    -d;.\mmi_inc) DEBUG PRINT(.\list\mmi_fs.lst) TABS(2) OBJECT(.\output\mmi_fs.obj)

line level    source

   1          #ifndef __MMI_FS_C__
   2          #define __MMI_FS_C__
   3          
   4          #include "mmi_fs.h"
   5          #include "mmi_sys.h"
   6          #include "mcu02_sfr.h"
   7          #include "mcu02_eeprom.h"
   8          #include "string.h"
   9          //#include "stdio.h"
  10          
  11          #include "mmi_fps.h"
  12          
  13          mmi_fs_setting g_dq_fs_init_set;
  14          
  15          #define MMI_DQ_FS_PWD_MAX_NUM 100
  16          mmi_fs_pwd    g_dq_fs_pwd[MMI_DQ_FS_PWD_MAX_NUM];
  17          
  18          #if defined(__LOCK_FP_SUPPORT__) 
  19          #define     MMI_DQ_FS_FP_MAX_NUM      50
  20          mmi_fs_fp   g_dq_fs_fp[MMI_DQ_FS_FP_MAX_NUM];
  21          #endif
  22          
  23          #ifdef __LOCK_RFID_CARD_SUPPORT__
  24          #define     MMI_DQ_FS_RFID_MAX_NUM      10
  25          mmi_fs_rfid   g_dq_fs_rfid[MMI_DQ_FS_RFID_MAX_NUM];
  26          #endif
  27          
  28          
  29          
  30          static void mmi_dq_fds_read(mid_fds_file_id file,  uint8_t* r_data ,uint16_t r_size)
  31          {
  32   1        uint16_t i;
  33   1      
  34   1        switch(file)
  35   1        {
  36   2          case MID_FDS_FILE_SET:
  37   2            eeprom_select(0);
  38   2            for(i = 0; i < r_size; i++)
  39   2            {
  40   3              r_data[i] = eeprom_read_byte(0,i);//¶ÁµÚÒ»Ò³
  41   3            }
  42   2            break;
  43   2          case MID_FDS_FILE_PWD:
  44   2            eeprom_select(0);
  45   2            for(i = 0; i < r_size; i++)
  46   2            {
  47   3              r_data[i] = eeprom_read_byte(0,i+24);//¶ÁµÚÒ»Ò³
  48   3            }
  49   2            break;
  50   2          case MID_FDS_FILE_FP:
  51   2            eeprom_select(1);
  52   2            eeprom_nvr_read_page(r_data,0,0,r_size);
  53   2            break;
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:34:47 PAGE 2   

  54   2          case MID_FDS_FILE_RF:
  55   2            eeprom_select(1);
  56   2              eeprom_nvr_read_page(r_data,1,0,r_size);
  57   2            break;
  58   2          default:
  59   2            break;
  60   2        }
  61   1      }
  62          
  63          static RET_VAL mmi_dq_fds_write(mid_fds_file_id file, uint8_t* w_data ,uint16_t w_size)
  64          {
  65   1        uint16_t i;
  66   1          ErrStatus ret;
  67   1        eeprom_erase_time(9);
  68   1        switch(file)
  69   1        {
  70   2          case MID_FDS_FILE_SET:
  71   2            {
  72   3              uint8_t* w_data2 = (uint8_t *)g_dq_fs_pwd;
  73   3              uint16_t w_size2 = sizeof(mmi_fs_pwd)*MMI_DQ_FS_PWD_MAX_NUM;
  74   3              eeprom_select(0);
  75   3              eeprom_erase_page(0);//²Á³ý1K
  76   3              for(i = 0; i < w_size; i++)
  77   3              {
  78   4                ret = eeprom_write_byte(0,i,w_data[i]);//¶ÁµÚÒ»Ò³
  79   4                if(ret==ERROR) 
  80   4                {
  81   5                  //printf("mmi_dq_fds_write  error  %d\n",i);
  82   5                  return RET_FAIL;
  83   5                }
  84   4              }
  85   3              for(i = 0; i < w_size2; i++)
  86   3              {
  87   4                ret = eeprom_write_byte(0,i+24,w_data2[i]);//¶ÁµÚÒ»Ò³
  88   4                if(ret==ERROR) 
  89   4                {
  90   5                  //printf("mmi_dq_fds_write  error  %d\n",i);
  91   5                  return RET_FAIL;
  92   5                }
  93   4              }
  94   3            }
  95   2            break;
  96   2          case MID_FDS_FILE_PWD:
  97   2            {
  98   3              uint8_t* w_data2 = (uint8_t *)&g_dq_fs_init_set;
  99   3              uint16_t w_size2 = sizeof(mmi_fs_setting);
 100   3              eeprom_select(0);
 101   3              eeprom_erase_page(0);//²Á³ý1K
 102   3              for(i = 0; i < w_size2; i++)
 103   3              {
 104   4                ret = eeprom_write_byte(0,i,w_data2[i]);//¶ÁµÚÒ»Ò³
 105   4                if(ret==ERROR) 
 106   4                {
 107   5                  //printf("mmi_dq_fds_write  error  %d\n",i);
 108   5                  return RET_FAIL;
 109   5                }
 110   4              }
 111   3              for(i = 0; i < w_size; i++)
 112   3              {
 113   4                ret = eeprom_write_byte(0,i+24,w_data[i]);//¶ÁµÚÒ»Ò³
 114   4                if(ret==ERROR) 
 115   4                {
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:34:47 PAGE 3   

 116   5                  //printf("mmi_dq_fds_write  error  %d\n",i);
 117   5                  return RET_FAIL;
 118   5                }
 119   4              }
 120   3            }
 121   2            break;
 122   2          case MID_FDS_FILE_FP:
 123   2            eeprom_select(1);
 124   2            eeprom_erase_page(0);//²Á³ý512byte
 125   2            for(i = 0; i < w_size; i++)
 126   2            {
 127   3              ret = eeprom_write_byte(0,i,w_data[i]);
 128   3              if(ret==ERROR) 
 129   3              {
 130   4                //printf("mmi_dq_fds_write  error  %d\n",i);
 131   4                return RET_FAIL;
 132   4              }
 133   3            }
 134   2            break;
 135   2          case MID_FDS_FILE_RF:
 136   2            eeprom_select(1);
 137   2            eeprom_erase_page(1);//²Á³ý512byte
 138   2            for(i = 0; i < w_size; i++)
 139   2            {
 140   3              ret = eeprom_write_byte(1,i,w_data[i]);
 141   3              if(ret==ERROR) 
 142   3              {
 143   4                //printf("mmi_dq_fds_write  error  %d\n",i);
 144   4                return RET_FAIL;
 145   4              }
 146   3            }
 147   2            break;
 148   2          default:
 149   2            return RET_FAIL;
 150   2        }
 151   1        //printf("mmi_dq_fds_write  suc\n");
 152   1        return RET_SUCESS;
 153   1      }
 154          
 155          
 156          
 157          /*
 158          parameter: 
 159            none
 160          return :
 161            none
 162          */
 163          void mmi_dq_fs_init(void)
 164          {
 165   1        mmi_dq_fds_read(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 166   1        if(FDS_INIT_LOCK_SUC == g_dq_fs_init_set.init_flag || FDS_INIT_APP_SUC == g_dq_fs_init_set.init_flag)
 167   1        {
 168   2          unsigned char i = 0;
 169   2          mmi_dq_fds_read(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd)*MMI_DQ_FS_PWD_MAX_NUM
             -);
 170   2          mmi_dq_fds_read(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp)*MMI_DQ_FS_FP_MAX_NUM);
 171   2          mmi_dq_fds_read(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid)*MMI_DQ_FS_RFID_MAX_N
             -UM);
 172   2          if(g_dq_fs_init_set.admin_status > 0)
 173   2          {
 174   3            for(;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 175   3            {
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:34:47 PAGE 4   

 176   4              if(g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
 177   4                break;
 178   4            }
 179   3            if(i>=MMI_DQ_FS_PWD_MAX_NUM)
 180   3            {
 181   4              g_dq_fs_init_set.admin_status = 0;
 182   4              mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 183   4            }
 184   3          }
 185   2        }
 186   1        else
 187   1        {
 188   2          //printf("mmi_dq_fs_init init error");
 189   2          memset(g_dq_fs_pwd,0xFF,sizeof(g_dq_fs_pwd));
 190   2          mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd, sizeof(mmi_fs_pwd)*MMI_DQ_FS_PWD_MAX_NU
             -M);
 191   2      
 192   2          memset(g_dq_fs_fp,0xFF,sizeof(g_dq_fs_fp));
 193   2          mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp)*MMI_DQ_FS_FP_MAX_NUM);
 194   2      
 195   2          mmi_dq_fp_empty();
 196   2      
 197   2          memset(g_dq_fs_rfid,0xFF,sizeof(g_dq_fs_rfid));
 198   2          mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid)*MMI_DQ_FS_RFID_MAX_
             -NUM);
 199   2      
 200   2          g_dq_fs_init_set.init_flag = FDS_INIT_LOCK_SUC;
 201   2          g_dq_fs_init_set.open_pro_sound = 1;
 202   2          g_dq_fs_init_set.open_mode = SYS_OPEN_MODE_SIN;
 203   2          g_dq_fs_init_set.admin_status = 0;
 204   2          g_dq_fs_init_set.factory_flag = 0;
 205   2          g_dq_fs_init_set.wifi_flag = 0;
 206   2          mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 207   2        }
 208   1      }
 209          
 210          
 211          
 212          
 213          /*
 214          parameter: 
 215            none
 216          return :
 217            none
 218          */
 219          void mmi_dq_fs_pwd_string_to_byte(unsigned char *input_pwd,unsigned char pwd_len,unsigned char *output_pwd
             -)
 220          {
 221   1        unsigned char i = 0;
 222   1        unsigned char bit_l = 0;
 223   1        unsigned char bit_h = 0;
 224   1      
 225   1        for(i=0;i<pwd_len;i++)
 226   1        {
 227   2          bit_l = *(input_pwd+i)&0x0F;
 228   2          i++;
 229   2          if(i < pwd_len)
 230   2            bit_h = *(input_pwd+i)&0x0F;
 231   2          else
 232   2            bit_h = 0xF;
 233   2          *output_pwd++ = bit_l<<4|bit_h;
 234   2        }
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:34:47 PAGE 5   

 235   1        return;
 236   1      }
 237          /*
 238          parameter: 
 239            none
 240          return :
 241            none
 242          */
 243          void mmi_dq_fs_pwd_byte_to_string(unsigned char *input_pwd,unsigned char *output_pwd)
 244          {
 245   1        unsigned char i = 0;
 246   1        unsigned char pwd = 0;
 247   1        for(i=0;i<4;i++)
 248   1        {
 249   2          pwd = *(input_pwd+i);
 250   2          if(pwd == 0xFF)
 251   2            break;
 252   2          else 
 253   2            *output_pwd++ = (pwd&0xF0)>>4;
 254   2          if((pwd&0x0F) == 0x0F)
 255   2            break;
 256   2          else
 257   2          {
 258   3            *output_pwd++ = pwd&0x0F;
 259   3          }
 260   2        }
 261   1        return;
 262   1      }
 263          
 264          /*
 265          parameter: 
 266            none
 267          return :
 268            none
 269          */
 270          unsigned char mmi_dq_fs_get_pwd_unuse_index(void)
 271          {
 272   1        unsigned char i = 0;
 273   1      
 274   1        for(i=0;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 275   1        {
 276   2          if(g_dq_fs_pwd[i].flag == 0xFF)
 277   2            break;
 278   2        }
 279   1      
 280   1        if(i<MMI_DQ_FS_PWD_MAX_NUM)
 281   1          return i;
 282   1        else
 283   1          return 0xFF;
 284   1      }
 285          
 286          /*
 287          parameter: 
 288            none
 289          return :
 290            none
 291          */
 292          unsigned char mmi_dq_fs_check_input_pwd(unsigned char *input_pwd,unsigned char len,fds_use_type type)
 293          {
 294   1        unsigned char i = 0;
 295   1        unsigned char k = 0;
 296   1        unsigned char password[4];
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:34:47 PAGE 6   

 297   1        unsigned char ret_val = 0xFF;
 298   1        
 299   1        memset(password,0xFF,sizeof(password));
 300   1        mmi_dq_fs_pwd_string_to_byte(input_pwd,len,password);
 301   1        
 302   1        for(i=0;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 303   1        {
 304   2          if(g_dq_fs_pwd[i].flag != 0xFF)
 305   2          {
 306   3            for(k=0;k<4;k++)
 307   3            {
 308   4              if(password[k] != g_dq_fs_pwd[i].key_pwd[k])
 309   4                break;
 310   4            }
 311   3            if(k == 4)
 312   3            {
 313   4              break;
 314   4            }
 315   3          }
 316   2        }
 317   1        if(i<MMI_DQ_FS_PWD_MAX_NUM)
 318   1        {
 319   2          if((g_dq_fs_pwd[i].flag == type)||(type == FDS_USE_TYPE_ALL))
 320   2            ret_val = i;
 321   2          else
 322   2            ret_val = 0xFF;
 323   2        }
 324   1        else
 325   1          ret_val = 0xFF;
 326   1        
 327   1        return ret_val;
 328   1      }
 329          
 330          /*
 331          parameter: 
 332            none
 333          return :
 334            none
 335          */
 336          RET_VAL mmi_dq_fs_set_pwd(unsigned char *pwd,unsigned char pwd_size,fds_use_type type)
 337          {
 338   1        unsigned char i = 0xFF;
 339   1        unsigned char password[4];
 340   1      
 341   1        if(type == FDS_USE_TYPE_ADMIN)
 342   1        {
 343   2          for(i=0;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 344   2          {
 345   3            if(g_dq_fs_pwd[i].flag == FDS_USE_TYPE_ADMIN)
 346   3              break;
 347   3          }
 348   2        }
 349   1        if(i >= MMI_DQ_FS_PWD_MAX_NUM)
 350   1        {
 351   2          for(i=0;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 352   2          {
 353   3            if(g_dq_fs_pwd[i].flag == 0xFF)
 354   3              break;
 355   3          }
 356   2        }
 357   1        if(i<MMI_DQ_FS_PWD_MAX_NUM)
 358   1        {
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:34:47 PAGE 7   

 359   2          memset(password,0xFF,sizeof(password));
 360   2          //g_dq_fs_pwd[i].index = i;
 361   2          mmi_dq_fs_pwd_string_to_byte(pwd,pwd_size,password);
 362   2          memcpy((char *)g_dq_fs_pwd[i].key_pwd,(const char *)password,4);
 363   2          g_dq_fs_pwd[i].flag = type;
 364   2          return  mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd,sizeof(mmi_fs_pwd)*MMI_DQ_FS_PWD_
             -MAX_NUM);
 365   2          
 366   2        }
 367   1        return RET_FAIL;
 368   1      }
 369          
 370          /*
 371          parameter: 
 372            none
 373          return :
 374            none
 375          */
 376          RET_VAL mmi_dq_fs_del_pwd(unsigned char index,fds_use_type type)
 377          {
 378   1        if(index < MMI_DQ_FS_PWD_MAX_NUM && g_dq_fs_pwd[index].flag == type)
 379   1        {
 380   2          g_dq_fs_pwd[index].flag = FDS_USE_TYPE_INVALID;
 381   2          //g_dq_fs_pwd[index].index = 0xFF;
 382   2          memset(g_dq_fs_pwd[index].key_pwd,0xFF,sizeof(g_dq_fs_pwd[index].key_pwd));
 383   2          return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd,sizeof(mmi_fs_pwd)*MMI_DQ_FS_PWD_
             -MAX_NUM);
 384   2        }
 385   1        return RET_FAIL;
 386   1      }
 387          
 388          /*
 389          parameter: 
 390            none
 391          return :
 392            none
 393          */
 394          RET_VAL mmi_dq_fs_clr_pwd(void)
 395          {
 396   1        unsigned char i = 0;
 397   1      
 398   1        for(i=0;i<MMI_DQ_FS_PWD_MAX_NUM;i++)
 399   1        {
 400   2          if(g_dq_fs_pwd[i].flag == FDS_USE_TYPE_USER)
 401   2          {
 402   3            g_dq_fs_pwd[i].flag = FDS_USE_TYPE_INVALID;
 403   3            //g_dq_fs_pwd[i].index = 0xFF;
 404   3            memset(g_dq_fs_pwd[i].key_pwd,0xFF,sizeof(g_dq_fs_pwd[i].key_pwd));
 405   3          }
 406   2        }
 407   1        return mmi_dq_fds_write(MID_FDS_FILE_PWD, (unsigned char *)g_dq_fs_pwd,sizeof(mmi_fs_pwd)*MMI_DQ_FS_PWD_M
             -AX_NUM);
 408   1      }
 409          
 410          
 411          #if defined (__LOCK_FP_SUPPORT__)
 412          /*
 413          parameter: 
 414            none
 415          return :
 416            none
 417          */
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:34:47 PAGE 8   

 418          unsigned char mmi_dq_fs_get_fp_unuse_index(void)
 419          {
 420   1        unsigned char i = 2;
 421   1        
 422   1        for(;i<MMI_DQ_FS_FP_MAX_NUM;i++)
 423   1        {
 424   2          if(g_dq_fs_fp[i].fp_index == 0xFF)
 425   2            break;
 426   2        }
 427   1        if(i>=MMI_DQ_FS_FP_MAX_NUM)
 428   1          return 0xFF;
 429   1        return i;
 430   1      }
 431          
 432          /*
 433          parameter: 
 434            none
 435          return :
 436            none
 437          */
 438          RET_VAL mmi_dq_fs_check_fp(unsigned char fp_index, fds_use_type type)
 439          {
 440   1        if((fp_index < MMI_DQ_FS_FP_MAX_NUM) && (g_dq_fs_fp[fp_index].fp_index == fp_index) && ((g_dq_fs_fp[fp_in
             -dex].flag == type)||(type == FDS_USE_TYPE_ALL)))
 441   1          return RET_SUCESS;
 442   1        else
 443   1          return RET_FAIL;
 444   1      }
 445          
 446          /*
 447          parameter: 
 448            none
 449          return :
 450            none
 451          */
 452          RET_VAL mmi_dq_fs_set_fp(unsigned char fs_index,fds_use_type type)
 453          {
 454   1        g_dq_fs_fp[fs_index].fp_index = fs_index;
 455   1        g_dq_fs_fp[fs_index].flag = type;
 456   1        return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp)*MMI_DQ_FS_FP_MAX_
             -NUM);
 457   1      }
 458          
 459          /*
 460          parameter: 
 461            none
 462          return :
 463            none
 464          */
 465          RET_VAL mmi_dq_fs_del_fp(unsigned char fp_index,fds_use_type type)
 466          {
 467   1        if(mmi_dq_fs_check_fp(fp_index,type) == RET_SUCESS)
 468   1        {
 469   2          g_dq_fs_fp[fp_index].flag = FDS_USE_TYPE_INVALID;
 470   2          g_dq_fs_fp[fp_index].fp_index = 0xFF;
 471   2          return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp)*MMI_DQ_FS_FP_MAX
             -_NUM);
 472   2        }
 473   1        return RET_FAIL;
 474   1      }
 475          
 476          /*
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:34:47 PAGE 9   

 477          parameter: 
 478            none
 479          return :
 480            none
 481          */
 482          RET_VAL mmi_dq_fs_clr_fp(void)
 483          {
 484   1        unsigned char i = 0;
 485   1        unsigned short fp_ret = 0;
 486   1      
 487   1        for(i=0;i<MMI_DQ_FS_FP_MAX_NUM;i++)
 488   1        {
 489   2          if(g_dq_fs_fp[i].flag != FDS_USE_TYPE_ADMIN)
 490   2          {
 491   3            if(g_dq_fs_fp[i].fp_index != 0xFF)
 492   3            {
 493   4              fp_ret = mmi_dq_fp_delete(g_dq_fs_fp[i].fp_index);
 494   4              if(fp_ret == 0)
 495   4              {
 496   5                g_dq_fs_fp[i].flag = FDS_USE_TYPE_INVALID;
 497   5                g_dq_fs_fp[i].fp_index = 0xFF;
 498   5              }
 499   4            }
 500   3          }
 501   2        }
 502   1      
 503   1        return mmi_dq_fds_write(MID_FDS_FILE_FP, (unsigned char *)g_dq_fs_fp, sizeof(mmi_fs_fp)*MMI_DQ_FS_FP_MAX_
             -NUM);
 504   1      }
 505          
 506          #endif
 507          
 508          
 509          #ifdef __LOCK_RFID_CARD_SUPPORT__
 510          
 511          /*
 512          parameter: 
 513            none
 514          return :
 515            none
 516          */
 517          unsigned char mmi_dq_fs_get_rfid_unuse_index(void)
 518          {
 519   1        unsigned char i = 0;
 520   1      
 521   1        for(i=0;i<MMI_DQ_FS_RFID_MAX_NUM;i++)
 522   1        {
 523   2          if(g_dq_fs_rfid[i].index == 0xFF)
 524   2            break;
 525   2        }
 526   1      
 527   1        if(i>=MMI_DQ_FS_RFID_MAX_NUM)
 528   1          return 0xFF;
 529   1        return i;
 530   1      }
 531          
 532          /*
 533          parameter: 
 534            none
 535          return :
 536            none
 537          */
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:34:47 PAGE 10  

 538          unsigned char mmi_dq_fs_check_rfid(unsigned char *sec_data, fds_use_type type)
 539          {
 540   1        unsigned char i = 0,j = 0;
 541   1        
 542   1        for(i=0;i<MMI_DQ_FS_RFID_MAX_NUM;i++)
 543   1        {
 544   2          for(j=0;j<RFID_SEC_DATA_LEN;j++)
 545   2          {
 546   3            if(g_dq_fs_rfid[i].sec_data[j] != sec_data[j])
 547   3              break;
 548   3          }
 549   2          if(j == RFID_SEC_DATA_LEN)
 550   2            break;
 551   2        }
 552   1        if(i<MMI_DQ_FS_RFID_MAX_NUM&&((g_dq_fs_rfid[i].flag == type)||(type == FDS_USE_TYPE_ALL)))
 553   1        {
 554   2          return i;
 555   2        }
 556   1        else
 557   1        {
 558   2          return 0xFF;
 559   2        }
 560   1      }
 561          
 562          /*
 563          parameter: 
 564            none
 565          return :
 566            none
 567          */
 568          RET_VAL mmi_dq_fs_set_rfid(unsigned char *sec_data, fds_use_type type)
 569          {
 570   1        unsigned char i = 0,j = 0;
 571   1        for(i=0;i<MMI_DQ_FS_RFID_MAX_NUM;i++)
 572   1        {
 573   2          if(g_dq_fs_rfid[i].index == 0xFF)
 574   2            break;
 575   2        }
 576   1        if(i < MMI_DQ_FS_RFID_MAX_NUM)
 577   1        {
 578   2          g_dq_fs_rfid[i].index = i;
 579   2          g_dq_fs_rfid[i].flag = type;
 580   2          for(j=0;j<RFID_SEC_DATA_LEN;j++)
 581   2          {
 582   3            g_dq_fs_rfid[i].sec_data[j] = sec_data[j];
 583   3          }
 584   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid)*MMI_DQ_FS_RF
             -ID_MAX_NUM);
 585   2        }
 586   1        return RET_FAIL;
 587   1      }
 588          
 589          /*
 590          parameter: 
 591            none
 592          return :
 593            none
 594          */
 595          RET_VAL mmi_dq_fs_del_rfid(unsigned char rfid_index)
 596          {
 597   1        if(rfid_index < MMI_DQ_FS_RFID_MAX_NUM && g_dq_fs_rfid[rfid_index].index == rfid_index)
 598   1        {
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:34:47 PAGE 11  

 599   2          g_dq_fs_rfid[rfid_index].index = 0xFF;
 600   2          g_dq_fs_rfid[rfid_index].flag = FDS_USE_TYPE_INVALID;
 601   2          memset(g_dq_fs_rfid[rfid_index].sec_data,0xFF,sizeof(g_dq_fs_rfid[rfid_index].sec_data));
 602   2          return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid)*MMI_DQ_FS_RF
             -ID_MAX_NUM);
 603   2        }
 604   1        return RET_FAIL;
 605   1      }
 606          
 607          
 608          /*
 609          parameter: 
 610            none
 611          return :
 612            none
 613          */
 614          RET_VAL mmi_dq_fs_clr_rfid(void)
 615          {
 616   1        unsigned char i = 0;
 617   1        
 618   1        for(i=0;i<MMI_DQ_FS_RFID_MAX_NUM;i++)
 619   1        {
 620   2          g_dq_fs_rfid[i].flag = FDS_USE_TYPE_INVALID;
 621   2          g_dq_fs_rfid[i].index = 0xFF;
 622   2          memset(g_dq_fs_rfid[i].sec_data,0xFF,sizeof(g_dq_fs_rfid[i].sec_data));
 623   2        }
 624   1        return mmi_dq_fds_write(MID_FDS_FILE_RF, (unsigned char *)g_dq_fs_rfid, sizeof(mmi_fs_rfid)*MMI_DQ_FS_RFI
             -D_MAX_NUM);
 625   1      }
 626          
 627          #endif
 628          
 629          /*
 630          parameter: 
 631            none
 632          return :
 633            none
 634          */
 635          RET_VAL mmi_dq_fs_set_open_mode(sys_open_mode mode)
 636          {
 637   1        if(g_dq_fs_init_set.open_mode == mode)
 638   1          return RET_SUCESS;
 639   1      
 640   1        g_dq_fs_init_set.open_mode = mode;
 641   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 642   1        
 643   1      }
 644          /*
 645          parameter: 
 646            none
 647          return :
 648            none
 649          */
 650          sys_open_mode mmi_dq_fs_get_open_mode(void)
 651          {
 652   1        return g_dq_fs_init_set.open_mode;
 653   1      }
 654          
 655          /*
 656          parameter: 
 657            none
 658          return :
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:34:47 PAGE 12  

 659            none
 660          */
 661          RET_VAL mmi_dq_fs_set_pro_sound(unsigned char flag)
 662          {
 663   1        if(g_dq_fs_init_set.open_pro_sound == flag)
 664   1          return RET_SUCESS;
 665   1        
 666   1        g_dq_fs_init_set.open_pro_sound = flag;
 667   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 668   1      
 669   1      }
 670          
 671          /*
 672          parameter: 
 673            none
 674          return :
 675            none
 676          */
 677          unsigned char mmi_dq_fs_get_pro_sound_state(void)
 678          {
 679   1        return g_dq_fs_init_set.open_pro_sound;
 680   1      }
 681          
 682          /*
 683          parameter: 
 684            none
 685          return :
 686            none
 687          */
 688          unsigned char mmi_dq_fs_get_init_flag(void)
 689          {
 690   1        return g_dq_fs_init_set.init_flag;
 691   1      }
 692          
 693          /*
 694          parameter: 
 695            none
 696          return :
 697            none
 698          */
 699          RET_VAL mmi_dq_fs_set_init_flag(unsigned char flag)
 700          {
 701   1        g_dq_fs_init_set.init_flag = flag;
 702   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 703   1      }
 704          
 705          /*
 706          parameter: 
 707            none
 708          return :
 709            none
 710          */
 711          RET_VAL mmi_dq_fs_set_factory_flag(unsigned char flag)
 712          {
 713   1        g_dq_fs_init_set.factory_flag= flag;
 714   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 715   1      }
 716          
 717          /*
 718          parameter: 
 719            none
 720          return :
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:34:47 PAGE 13  

 721            none
 722          */
 723          unsigned char mmi_dq_fs_get_factory_flag(void)
 724          {
 725   1        return g_dq_fs_init_set.factory_flag;
 726   1      }
 727          
 728          /*
 729          parameter: 
 730            none
 731          return :
 732            none
 733          */
 734          unsigned char mmi_dq_fs_get_admin_status(void)
 735          {
 736   1        return g_dq_fs_init_set.admin_status;
 737   1      }
 738          
 739          /*
 740          parameter: 
 741            none
 742          return :
 743            none
 744          */
 745          RET_VAL mmi_dq_fs_set_admin_status(unsigned char status)
 746          {
 747   1        g_dq_fs_init_set.admin_status = status;
 748   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 749   1      }
 750          
 751          /*
 752          parameter: 
 753            none
 754          return :
 755            none
 756          */
 757          RET_VAL mmi_dq_fs_set_wifi_setting(unsigned char flag)
 758          {
 759   1        g_dq_fs_init_set.wifi_flag = flag;
 760   1        return mmi_dq_fds_write(MID_FDS_FILE_SET, (unsigned char *)&g_dq_fs_init_set, sizeof(mmi_fs_setting));
 761   1      }
 762          
 763          /*
 764          parameter: 
 765            none
 766          return :
 767            none
 768          */
 769          unsigned char mmi_dq_fs_get_wifi_setting(void)
 770          {
 771   1        return g_dq_fs_init_set.wifi_flag;
 772   1      }
 773          
 774          
 775          
 776          
 777          
 778          
 779          
 780          
 781          
 782          
C51 COMPILER V9.59.0.0   MMI_FS                                                            02/19/2021 17:34:47 PAGE 14  

 783          
 784          
 785          
 786          
 787          
 788          
 789          
 790          
 791          
 792          
 793          
 794          
 795          
 796          
 797          
 798          
 799          
 800          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3385    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    750      68
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
