C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE DQ_SDK_MAIN
OBJECT MODULE PLACED IN .\output\dq_sdk_main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE mmi_src\dq_sdk_main.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\inclu
                    -de;.\Library\byd_standard_peripheral\include;.\byd_api\byd_key\include;.\byd_api\byd_mifare\include;.\byd_tool_comm;.\by
                    -d_rfid;.\mmi_inc) DEBUG PRINT(.\list\dq_sdk_main.lst) TABS(2) OBJECT(.\output\dq_sdk_main.obj)

line level    source

   1          #ifndef __DQ_SDK_MAIN_C__
   2          #define __DQ_SDK_MAIN_C__
   3          #include "mmi_feature.h"
   4          #ifdef __LOCK_VIRTUAL_PASSWORD__
   5          #include "dq_sdk_main.h"
   6          #include "dq_sdk_cb.h"
   7          #include "dq_sdk_crc.h"
   8          //#include "dq_sdk_aes.h"
   9          #include "mmi_decode.h"
  10          #include "mcu02_sfr.h"
  11          #include "mmi_time.h"
  12          
  13          #ifndef __WIN32_ENV_SUPPORT__
  14          // #include "nrf_log.h"
  15          #endif
  16          
  17          #ifdef __LOCK_USE_MALLOC__
              typedef enum
              {
                DQ_FS_MEM_INVALID,
                DQ_FS_MEM_PWD,
                DQ_FS_MEM_FP,
                DQ_FS_MEM_RFID,
                DQ_FS_MEM_APP_PWD,
                DQ_FS_MEM_APP_FP,
                DQ_FS_MEM_APP_RFID,
              } dq_fs_storage_type;
              
              void *mmi_dq_fs_get_storage(dq_fs_storage_type type, uint8_t *ret);
              uint8_t mmi_dq_fs_free_storage(dq_fs_storage_type type, void **p);
              
              #endif
  33          
  34          //const data
  35          #define DQ_OTP_AES_KEY_LEN 16
  36          #define DQ_OTP_CMD_NO_CRC_LENGTH 32
  37          
  38          //#define DQ_OTP_START_TIME_SEC   1546272000//2019.01.01.00.00
  39          
  40          static const uint8_t DQ_OTP_AES_GBL_KEY[] = {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0
             -x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c};
  41          
  42          static unsigned char DQ_OTP_SYS_TIME_GET = 0;
  43          
  44          static uint8_t g_dq_dfu_permit = 0;
  45          
  46          // typedef struct otp_exchg_num
  47          // {
  48          //  unsigned char num;
  49          //  unsigned char exchg_num[5];
  50          // } otp_exchg_num;
  51          
  52          typedef struct otp_base_setting_info
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 2   

  53          {
  54            unsigned char init_suc_flag;
  55            unsigned char reserve;
  56            unsigned char otp_dev_key[16];
  57            unsigned char otp_sec_key_8[4];
  58            unsigned char otp_exg_key_8[4];
  59            unsigned char otp_sec_key_9[5];
  60            unsigned char otp_exg_key_9[5];
  61            //unsigned short otp_empty_hour;
  62            otp_exchg_num g_pwd_signed_data[10];
  63            uint32_t otp_start_hour;
  64          } otp_base_setting_info;
  65          
  66          typedef struct otp_base_log_info
  67          {
  68            uint32_t sys_time;
  69            uint8_t app_pwd[5];
  70            uint8_t type;
  71            uint8_t sys_time_correct;
  72            uint8_t flag;
  73          } otp_base_log_info;
  74          
  75          typedef struct otp_base_lock_chg_info
  76          {
  77            unsigned char lock_pwd_chg_flag;
  78            unsigned char lock_fp_chg_flag;
  79            unsigned char lock_rf_chg_flag;
  80            unsigned char lock_log_chg_flag;
  81            unsigned char lock_opt_chg_flag;
  82            unsigned char lock_door_aud_flag;
  83            unsigned char lock_con_flag;
  84          } otp_base_lock_chg_info;
  85          
  86          //enum
  87          typedef enum
  88          {
  89            //init syn
  90            CMD_OTP_SYN_AES_16,   //0x00,0101
  91            CMD_OTP_SYN_SEC_8,    //0x01,0102
  92            CMD_OTP_SYN_SEC_9,    //0x02,0103
  93            CMD_OTP_SYN_START_TIME, //0x03,0104
  94            CMD_OTP_SYN_PWD_STR,  //0x04,0105
  95                        //ekey
  96            CMD_OTP_EKEY_OPEN_LOCK, //0x05,0201
  97                        //pwd
  98            CMD_OTP_USER_DEF_PWD, //0X06,//0211
  99            CMD_OTP_DEL_PWD,    //0x07,0212
 100            CMD_OTP_CLR_PWD,    //0x08,0213
 101            CMD_OTP_SYN_PWD,    //0214
 102            CMD_OTP_SYN_TEMP_PWD, //0215
 103          
 104            //fp
 105            CMD_OTP_ADD_FP, //0x09,0221
 106            CMD_OTP_DEL_FP, //0x0A,0222
 107            CMD_OTP_CLR_FP, //0x0B,0223
 108            CMD_OTP_SYN_FP, //0224
 109          
 110            //RFID
 111            CMD_OTP_ADD_RFID,    //0x0C,0231
 112            CMD_OTP_DEL_RFID,    //0x0D,0232
 113            CMD_OTP_CLR_RFID,    //0x0E,0233
 114            CMD_OTP_SYN_RFID,    //0234
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 3   

 115            CMD_OTP_ADD_RFID_BY_APP, //0235
 116                         //LOG
 117            CMD_OTP_UPDATE_LOG,    //0x0F,0301
 118          
 119            //lock info
 120            CMD_OTP_GET_LOCK_CONFIG,  //0x10,0401
 121            CMD_OTP_GET_LOCK_BASE_INFO, //0x11,0402
 122            CMD_OTP_CHK_ADMIN_STATUS, //0x12,0403
 123            CMD_OTP_VERY_ADMIN_STA,   //0x13,0404
 124            CMD_OTP_INIT_SUCESS,    //0x14,0405
 125            CMD_OTP_SYS_ENTER_DFU,    //0x16,0406
 126            CMD_OTP_GET_SYS_TIME,   //0x17,0407
 127            CMD_OTP_MAX_NUM,
 128          
 129            CMD_OTP_INVALID = 0xFF
 130          } OTP_TYPE;
 131          
 132          typedef enum
 133          {
 134            OTP_BASE_SUCESS = 0x00,
 135            OTP_BASE_FAIL = 0x01,
 136            OTP_BASE_ERR_UNKNOW = 0x02,
 137            OTP_BASE_BONDED = 0x03,
 138            OTP_BASE_UNBOND = 0x04,
 139            OTP_BASE_NO_MEM = 0x05,
 140            OTP_BASE_NOT_FOUND = 0x06,
 141            OTP_BASE_TYPE_ERROR = 0x07,
 142            OTP_BASE_EXIST = 0x08,
 143            OTP_BASE_NOT_PAIR = 0x09,
 144            OTP_BASE_FULL = 0x0A,
 145            OTP_BASE_EMPTY = 0x0B,
 146            OTP_BASE_TIMEOUT = 0x0C,
 147            OTP_BASE_HAND_EXIT = 0x0D,
 148            OTP_BASE_BUSY = 0x0E,
 149            OTP_BASE_USED = 0x0F,
 150            OTP_BASE_UNUSED = 0x10,
 151            OTP_BASE_WAIT_NEXT_CMD = 0x11,
 152            OTP_BASE_MUL_ERROR = 0x20,
 153            OTP_BASE_LOW_VBAT = 0x21,
 154            OTP_BASE_RET_INVALID,
 155          } OTP_BASE_RET;
 156          
 157          typedef enum
 158          {
 159            OTP_PWD_TYPE_PER = 0x01,
 160            OTP_PWD_TYPE_SIN = 0x02,
 161            OTP_PWD_TYPE_LIM = 0x03,
 162            OTP_PWD_TYPE_LOOP = 0x04,
 163            OTP_PWD_TYPE_CLR = 0x05,
 164            OTP_PWD_TYPE_INVALID = 0xFF
 165          } OTP_PWD_TYPE;
 166          
 167          typedef struct
 168          {
 169            unsigned char cmd_h;
 170            unsigned char cmd_l;
 171            OTP_TYPE cmd;
 172          } otp_cmd_info;
 173          
 174          const otp_cmd_info cmd_info[] =
 175            {
 176              {0x01, 0x01, CMD_OTP_SYN_AES_16},
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 4   

 177              {0x01, 0x02, CMD_OTP_SYN_SEC_8},
 178              {0x01, 0x03, CMD_OTP_SYN_SEC_9},
 179              {0x01, 0x04, CMD_OTP_SYN_START_TIME},
 180              {0x01, 0x05, CMD_OTP_SYN_PWD_STR},
 181          
 182              {0x02, 0x01, CMD_OTP_EKEY_OPEN_LOCK},
 183              {0x02, 0x11, CMD_OTP_USER_DEF_PWD},
 184              {0x02, 0x12, CMD_OTP_DEL_PWD},
 185              {0x02, 0x13, CMD_OTP_CLR_PWD},
 186              {0x02, 0x14, CMD_OTP_SYN_PWD},
 187              {0x02, 0x15, CMD_OTP_SYN_TEMP_PWD},
 188          
 189              {0x02, 0x21, CMD_OTP_ADD_FP},
 190              {0x02, 0x22, CMD_OTP_DEL_FP},
 191              {0x02, 0x23, CMD_OTP_CLR_FP},
 192              {0x02, 0x24, CMD_OTP_SYN_FP},
 193          
 194              {0x02, 0x31, CMD_OTP_ADD_RFID},
 195              {0x02, 0x32, CMD_OTP_DEL_RFID},
 196              {0x02, 0x33, CMD_OTP_CLR_RFID},
 197              {0x02, 0x34, CMD_OTP_SYN_RFID},
 198              {0x02, 0x35, CMD_OTP_ADD_RFID_BY_APP},
 199          
 200              {0x03, 0x01, CMD_OTP_UPDATE_LOG},
 201              {0x04, 0x01, CMD_OTP_GET_LOCK_CONFIG},
 202              {0x04, 0x02, CMD_OTP_GET_LOCK_BASE_INFO},
 203              {0x04, 0x03, CMD_OTP_CHK_ADMIN_STATUS},
 204              //lock
 205              {0x04, 0x04, CMD_OTP_VERY_ADMIN_STA},
 206              {0x04, 0x05, CMD_OTP_INIT_SUCESS},
 207              {0x04, 0x06, CMD_OTP_SYS_ENTER_DFU},
 208              {0x04, 0x07, CMD_OTP_GET_SYS_TIME},
 209          };
 210          
 211          //variable
 212          dq_otp_init_t g_dq_otp_init;
 213          
 214          otp_base_setting_info otp_set_info;
 215          #ifdef __LOCK_USE_MALLOC__
              otp_base_app_pwd_info *g_dq_app_pwd_info; //100
              
              otp_base_app_fp_info *g_dq_app_fp_info; //10
              otp_base_app_rfid_info *g_dq_app_rfid_info;
              #else
 221          otp_base_app_pwd_info g_dq_app_pwd_info[DQ_OTP_APP_PWD_NUM]; //100
 222          
 223          otp_base_app_fp_info g_dq_app_fp_info[DQ_OTP_APP_FP_NUM]; //10
 224          otp_base_app_rfid_info g_dq_app_rfid_info[DQ_OTP_APP_RFID_NUM];
 225          #endif
 226          otp_base_lock_chg_info g_dq_otp_lock_chg;
 227          otp_base_log_info otp_lock_log[DQ_OTP_LOG_NUM];
 228          otp_base_log_info otp_lock_temp_log[2];
 229          
 230          unsigned char otp_log_head, otp_log_end;
 231          
 232          //static uint16_t     serialId = 0;
 233          static uint8_t serialId = 0;
 234          
 235          static uint8_t dq_dev_key_flag = 0;
 236          static OTP_TYPE g_dq_otp_type = CMD_OTP_INVALID;
 237          //static unsigned char  g_dq_cmd_reply_data[DQ_OTP_CMD_NO_CRC_LENGTH/2];
 238          static OTP_BASE_RET g_dq_cmd_repleys_status;
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 5   

 239          //static uint8_t      g_dq_reset_index = 0;
 240          static uint16_t g_dq_fp_index = 0;
 241          static uint16_t g_dq_rfid_index = 0;
 242          static uint32_t g_dq_add_temp_start_time = 0;
 243          static uint32_t g_dq_add_temp_end_time = 0;
 244          
 245          static uint8_t g_dq_link_error = 0;
 246          
 247          #ifdef __WIN32_ENV_SUPPORT__
              static otp_exchg_num temp_pwd_signed_data[10] =
                {
                  0, {0x43, 0x16, 0x98, 0x25, 0x07}, 1, {0x26, 0x41, 0x53, 0x89, 0x70}, 2, {0x92, 0x35, 0x64, 0x70, 0x81},
             - 3, {0x72, 0x59, 0x03, 0x18, 0x46}, 4, {0x02, 0x85, 0x19, 0x63, 0x74}, 5, {0x12, 0x05, 0x69, 0x43, 0x87}, 6, {0x21, 0x69
             -, 0x50, 0x37, 0x84}, 7, {0x10, 0x63, 0x52, 0x74, 0x89}, 8, {0x09, 0x58, 0x26, 0x17, 0x34}, 9, {0x18, 0x95, 0x42, 0x76, 0
             -x30}};
              #endif
 252          
 253          const char dq_otp_sdk_ver[] = "sdk v1.0.0";
 254          
 255          #define DQ_OTP_INVALID_INDEX 0xFFFF
 256          #define DQ_OTP_PWD_NOT_USED 0x11
 257          #define DQ_OTP_PWD_USED 0x10
 258          //function
 259          static OTP_BASE_RET dq_otp_syn_aes_16_key(unsigned char *p_data);
 260          static void dq_otp_cmd_dataOperation(uint8_t *p_data, uint16_t data_len);
 261          /*
 262          parameter: 
 263            current status machine
 264          return :
 265            none
 266          */
 267          void dq_otp_reback_pwd_by_sec(OTP_TYPE type, unsigned char *old_pwd, unsigned char *new_pwd);
 268          
 269          unsigned char dq_otp_get_sys_time_hour(unsigned short *sys_hour);
 270          
 271          uint32_t dq_otp_get_lim_pwd_end_time(unsigned char *dec_pwd, unsigned char len);
 272          extern unsigned short dq_otp_get_pwd_time_hour(unsigned char *in_pwd, unsigned char len, unsigned char off
             -set);
 273          static void dq_otp_find_log_head_end(void);
 274          extern void dq_otp_send_log(void);
 275          extern uint8_t dq_otp_check_and_update_log_time(uint32_t time);
 276          #ifdef __WIN32_ENV_SUPPORT__
              int main(void)
              {
                //0104 5D134A30 FFFF FFFF FFFF FFFF FF 99
                //uint8_t test_temp_data[] = {0x01,0x04,0x5D,0x13,0x4A,0x30,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
             -0x99,0x3,0x81};
                //0105 00 4316982507 01 2641538970 FF 99
                //uint8_t test_temp_data[] = {0x01,0x05,0x00,0x43,0x16,0x98,0x25,0x07,0x01,0x26,0x41,0x53,0x89,0x70,0xFF,
             -0x99,0x3,0x81};
                //0201 01 5C89B5B8 5CEA6BB0 7F FF FF FF 99
                //uint8_t test_temp_data[] = {0x02,0x01,0x04,0x5C,0x89,0xB5,0xB8,0x5C,0xEA,0x6B,0xB0,0x4F,0xFF,0xFF,0xFF,
             -0x99,0x3,0x81};
                //0211 93 62 39 60 5F  87 68 62 74 FFFF FFFF 99
                //uint8_t test_temp_data[] = {0x02,0x11,0x93,0x62,0x39,0x60,0x5F,0x87,0x68,0x62,0x74,0xFF,0xFF,0xFF,0xFF,
             -0x99,0x3,0x81};
                //0212 8866 7687 3F FFFF FFFF FFFF FFFF 99
                //uint8_t test_temp_data[] = {0x02,0x12,0x88,0x62,0x78,0x87,0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
             -0x99,0x3,0x81};
                //0213 5C90 628C FFFF FFFF FFFF FFFF FF 99
                //uint8_t test_temp_data[] = {0x02,0x13,0x5C,0x90,0x62,0x8C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
             -0x99,0x3,0x81};
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 6   

                //0221 5C9A0030 5D134A30 00 60 FFFF FF 99
                uint8_t test_temp_data[] = {0x02, 0x21, 0x5C, 0x9A, 0x00, 0x30, 0x5D, 0x13, 0x4A, 0x30, 0x43, 0x56, 0xFF,
             - 0xFF, 0xFF, 0x99, 0x3, 0x81};
                dq_sdk_otp_init();
                dq_otp_dataCheck(test_temp_data, 18);
                return 1;
              }
              #endif
 298          
 299          /*
 300          parameter: 
 301            none
 302          return :
 303            none
 304          */
 305          void dq_sdk_ByteToHexStr(const uint8_t *source, char *dest, int sourceLen)
 306          {
 307   1        short i;
 308   1        uint8_t highByte, lowByte;
 309   1        for (i = 0; i < sourceLen; i++)
 310   1        {
 311   2          highByte = source[i] >> 4;
 312   2          lowByte = source[i] & 0x0f;
 313   2          highByte += 0x30;
 314   2          if (highByte > 0x39)
 315   2            dest[i * 2] = highByte + 0x07;
 316   2          else
 317   2            dest[i * 2] = highByte;
 318   2          lowByte += 0x30;
 319   2          if (lowByte > 0x39)
 320   2            dest[i * 2 + 1] = lowByte + 0x07;
 321   2          else
 322   2            dest[i * 2 + 1] = lowByte;
 323   2        }
 324   1        return;
 325   1      }
 326          /*
 327          parameter: 
 328            none
 329          return :
 330            none
 331          */
 332          void dq_sdk_IntToByteStr(unsigned int p_data, char *dest, int sourceLen)
 333          {
 334   1        unsigned char i = 0;
 335   1        unsigned int temp_data = p_data;
 336   1        for (i = 0; i < sourceLen; i++)
 337   1        {
 338   2          dest[sourceLen - i - 1] = temp_data % 10;
 339   2          temp_data = temp_data / 10;
 340   2        }
 341   1        return;
 342   1      }
 343          
 344          /*
 345          parameter: 
 346            none
 347          return :
 348            none
 349          */
 350          void dq_sdk_CharToHexByte(const uint8_t *source, char *dest, int sourceLen)
 351          {
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 7   

 352   1        short i;
 353   1        uint8_t highByte, lowByte;
 354   1        for (i = 0; i < sourceLen; i++)
 355   1        {
 356   2          highByte = source[i] >> 4;
 357   2          lowByte = source[i] & 0x0f;
 358   2          dest[i * 2] = highByte;
 359   2          if (lowByte != 0x0F)
 360   2            dest[i * 2 + 1] = lowByte;
 361   2        }
 362   1        return;
 363   1      }
 364          
 365          /*
 366          parameter: 
 367            none
 368          return :
 369            none
 370          */
 371          unsigned int dq_sdk_CharToInt(const uint8_t *source, int sourceLen)
 372          {
 373   1        short i;
 374   1        unsigned int int_ret = 0;
 375   1        for (i = 0; i < sourceLen; i++)
 376   1        {
 377   2          int_ret = int_ret * 10 + source[i];
 378   2        }
 379   1        return int_ret;
 380   1      }
 381          /*
 382          parameter: 
 383            none
 384          return :
 385            none
 386          */
 387          void dq_sdk_HexStrToByte(const char *source, uint8_t *dest, int sourceLen)
 388          {
 389   1        short i;
 390   1        uint8_t highByte, lowByte;
 391   1        for (i = 0; i < sourceLen; i += 2)
 392   1        {
 393   2          highByte = (uint8_t)toupper(source[i]);
 394   2          lowByte = (uint8_t)toupper(source[i + 1]);
 395   2          if (highByte > 0x39)
 396   2            highByte -= 0x37;
 397   2          else
 398   2            highByte -= 0x30;
 399   2          if (lowByte > 0x39)
 400   2            lowByte -= 0x37;
 401   2          else
 402   2            lowByte -= 0x30;
 403   2          dest[i / 2] = (highByte << 4) | lowByte;
 404   2        }
 405   1        return;
 406   1      }
 407          /*
 408          parameter: 
 409            none
 410          return :
 411            none
 412          */
 413          void dq_sdk_HexCharToByte(const char *source, uint8_t *dest, int sourceLen)
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 8   

 414          {
 415   1        short i;
 416   1        uint8_t highByte, lowByte;
 417   1        for (i = 0; i < sourceLen; i += 2)
 418   1        {
 419   2          highByte = (uint8_t)toupper(source[i]);
 420   2          if ((sourceLen % 2 != 0) && (i == ((sourceLen / 2) * 2)))
 421   2            lowByte = 0x0F;
 422   2          else
 423   2            lowByte = (uint8_t)toupper(source[i + 1]);
 424   2          dest[i / 2] = (highByte << 4) | lowByte;
 425   2        }
 426   1        return;
 427   1      }
 428          
 429          /*
 430          parameter: 
 431            none
 432          return :
 433            none
 434          */
 435          void dq_sdk_ByteCharToString(char *source, char *dest, int sourcelen)
 436          {
 437   1        unsigned char i = 0, j = 0, k = 0;
 438   1        for (i = 0; i < sourcelen; i++)
 439   1        {
 440   2          if (source[i] != 0x00)
 441   2            break;
 442   2        }
 443   1        for (k = i; k < sourcelen; k++)
 444   1        {
 445   2          if (source[k] != 0x00)
 446   2          {
 447   3            dest[j++] = source[k];
 448   3          }
 449   2          else
 450   2            break;
 451   2        }
 452   1        return;
 453   1      }
 454          
 455          /*
 456          parameter: 
 457            none
 458          return :
 459            none
 460          */
 461          // int dq_sdk_HexcharToInt(uint8_t *source, int length)
 462          // {
 463          //  int int_data = 0;
 464          //  char dest[20];
 465          //  uint8_t ret = 0;
 466          //  //dest = malloc(length*2*sizeof(unsigned char));
 467          
 468          //  memset(dest, 0x00, sizeof(dest));
 469          //  dq_sdk_ByteToHexStr(source, dest, length);
 470          //  ret = sscanf((const char *)dest, "%x", &int_data);
 471          
 472          //  //free(dest);
 473          //  if (ret == 1)
 474          //    return int_data;
 475          //  else
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 9   

 476          //    return 0;
 477          // }
 478          /*
 479          parameter: 
 480            current status machine
 481          return :
 482            none
 483          */
 484          time_t dq_otp_get_pwd_time_sec(unsigned char year, unsigned char month, unsigned char day, unsigned char h
             -our)
 485          {
 486   1        time_t time_sec;
 487   1        struct tm tm_now;
 488   1      
 489   1        tm_now.tm_year = year;
 490   1        tm_now.tm_mon = month;
 491   1        tm_now.tm_mday = day;
 492   1        tm_now.tm_hour = hour;
 493   1        tm_now.tm_min = 0;
 494   1        tm_now.tm_sec = 0;
 495   1      
 496   1        // time_sec = mktime(&tm_now);
 497   1        return time_sec;
 498   1      }
 499          /*
 500          parameter: 
 501            current status machine
 502          return :
 503            none
 504          */
 505          time_t dq_otp_get_sys_time_sec(void)
 506          {
 507   1        time_t now;
 508   1        struct tm tm_now;
 509   1        g_dq_otp_init.get_lock_time_info(&tm_now);
 510   1      
 511   1        // now = mktime(&tm_now);
 512   1        return now;
 513   1      }
 514          
 515          /*
 516          parameter: 
 517            current status machine
 518          return :
 519            none
 520          */
 521          // unsigned char dq_otp_get_pwd_time_ymd(unsigned int pwd_hour, unsigned char *year, unsigned char *month,
             - unsigned char *day, unsigned char *hour)
 522          // {
 523          //  time_t now = pwd_hour * 3600 + otp_set_info.otp_start_hour; //DQ_OTP_START_TIME_SEC;
 524          //  struct tm *tm_now;
 525          //  localtime(&now,tm_now);
 526          //  *year = tm_now->tm_year;
 527          //  *month = tm_now->tm_mon;
 528          //  *day = tm_now->tm_mday;
 529          //  *hour = tm_now->tm_hour;
 530          //  return 1;
 531          // }
 532          
 533          /*
 534          parameter: 
 535            current status machine
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 10  

 536          return :
 537            none
 538          */
 539          unsigned char dq_otp_get_sys_time_ymd(unsigned char *year, unsigned char *month, unsigned char *day, unsig
             -ned char *hour)
 540          {
 541   1        struct tm tm_sys;
 542   1        g_dq_otp_init.get_lock_time_info(&tm_sys);
 543   1        *year = tm_sys.tm_year;
 544   1        *month = tm_sys.tm_mon;
 545   1        *day = tm_sys.tm_mday;
 546   1        *hour = tm_sys.tm_hour;
 547   1        return 1;
 548   1      }
 549          
 550          /*
 551          parameter: 
 552            current status machine
 553          return :
 554            none
 555          */
 556          // unsigned char dq_otp_get_sys_local_time_week(void)
 557          // {
 558          //  time_t now;
 559          //  struct tm tm_sys, *tm_local;
 560          //  g_dq_otp_init.get_lock_time_info(&tm_sys);
 561          //  now = mktime(&tm_sys);
 562          //  g_dq_otp_init.time_zone_pro(&now);
 563          //  tm_local = localtime(&now);
 564          //  return tm_local->tm_wday;
 565          // }
 566          
 567          /*
 568          parameter: 
 569            none
 570          return :
 571            none
 572          */
 573          void dq_sdk_otp_init(void)
 574          {
 575   1        uint8_t ret;
 576   1      #ifndef __LOCK_USE_MALLOC__
 577   1        uint8_t i = 0;
 578   1      #endif
 579   1        uint8_t admin_state = 0;
 580   1      
 581   1        g_dq_otp_init.fds_read = dq_otp_fds_read_cb;
 582   1        g_dq_otp_init.fds_write = dq_otp_fds_write_cb;
 583   1        g_dq_otp_init.data_send_bt = dq_otp_data_send_by_bt_cb;
 584   1        //g_dq_otp_init.data_send_nb = dq_otp_data_send_by_nb_cb;
 585   1      
 586   1        g_dq_otp_init.set_lock_fp = dq_otp_set_lock_fp_cb;
 587   1        g_dq_otp_init.set_lock_pwd = dq_otp_set_lock_pwd_cb;
 588   1        g_dq_otp_init.set_lock_rfid = dq_otp_set_lock_rfid_cb;
 589   1      
 590   1        g_dq_otp_init.stop_set_lock_fp = dq_otp_stop_set_lock_fp_cb;
 591   1        g_dq_otp_init.stop_set_lock_rfid = dq_otp_stop_set_lock_rfid_cb;
 592   1        g_dq_otp_init.stop_verify_admin_status = dq_otp_stop_verify_admin_status_cb;
 593   1      
 594   1        g_dq_otp_init.clear_lock_fp = dq_otp_clear_lock_fp_cb;
 595   1        g_dq_otp_init.clear_lock_pwd = dq_otp_clear_lock_pwd_cb;
 596   1        g_dq_otp_init.clear_lock_rf = dq_otp_clear_lock_rf_cb;
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 11  

 597   1      
 598   1        //g_dq_otp_init.del_lock_fp = dq_otp_get_lock_fp_index_cb;
 599   1        //g_dq_otp_init.get_lock_pwd_index = dq_otp_get_lock_pwd_index_cb;
 600   1        g_dq_otp_init.del_lock_pwd = dq_otp_del_lock_pwd_cb;
 601   1        g_dq_otp_init.del_lock_fp = dq_otp_del_lock_fp_cb;
 602   1        g_dq_otp_init.del_lock_rf = dq_otp_del_lock_rf_cb;
 603   1      
 604   1        g_dq_otp_init.add_lock_rfid_by_app = dq_otp_add_lock_rfid_by_app_cb;
 605   1        //lock info
 606   1        g_dq_otp_init.get_lock_bat_level = dq_otp_get_lock_bat_info_cb;
 607   1        g_dq_otp_init.get_lock_ver_info = dq_otp_get_lock_ver_info_cb;
 608   1        g_dq_otp_init.set_lock_open_aud = dq_otp_set_lock_open_aud_cb;
 609   1        g_dq_otp_init.get_lock_mem_info = dq_otp_get_lock_mem_info_cb;
 610   1        g_dq_otp_init.get_admin_status = dq_otp_get_admin_status_cb;
 611   1        g_dq_otp_init.verify_admin_status = dq_otp_verify_admin_status_cb;
 612   1        g_dq_otp_init.set_system_time = dq_otp_set_system_time_cb;
 613   1        g_dq_otp_init.set_system_time_zone = dq_otp_set_system_time_zone_cb;
 614   1        g_dq_otp_init.get_lock_time_info = dq_otp_get_lock_time_info_cb;
 615   1      
 616   1        //init sucess
 617   1        g_dq_otp_init.init_sucess = dq_otp_set_init_sucess_cb;
 618   1        g_dq_otp_init.init_sucess_reset_lock = dq_otp_set_init_sucess_reset_lock_cb;
 619   1      
 620   1        g_dq_otp_init.open_lock = dq_otp_set_lock_open;
 621   1      
 622   1        g_dq_otp_init.check_admin_pwd = dq_otp_lock_check_admin_pwd;
 623   1        g_dq_otp_init.check_lock_state = dq_otp_lock_check_lock_state;
 624   1        g_dq_otp_init.input_pwd_cb = dq_otp_lock_input_pwd_cb;
 625   1      
 626   1        g_dq_otp_init.time_zone_pro = dq_otp_lock_time_zone_pro;
 627   1      
 628   1        g_dq_cmd_repleys_status = OTP_BASE_SUCESS;
 629   1      
 630   1        //setinfo
 631   1        g_dq_dfu_permit = 0;
 632   1      
 633   1        memset(&otp_set_info, 0xFF, sizeof(otp_set_info));
 634   1        //g_dq_otp_init.fds_read(DQ_OTP_FILE_ID_SET, (unsigned char *)&otp_set_info, sizeof(otp_set_info), &ret);
 635   1      #ifdef __WIN32_ENV_SUPPORT__
                {
                  unsigned char temp_exg_key_9[] = {0x93, 0x42, 0x67, 0x15, 0x8F};
                  unsigned char temp_sec_key_9[] = {0x15, 0x02, 0x23, 0x28, 0x6F};
                  unsigned char temp_exg_key_8[] = {0x43, 0x26, 0x71, 0x58};
                  unsigned char temp_sec_key_8[] = {0x50, 0x72, 0x29, 0x98};
                  memset(otp_set_info.otp_exg_key_8, 0x00, sizeof(otp_set_info.otp_exg_key_8));
                  memset(otp_set_info.otp_sec_key_8, 0x00, sizeof(otp_set_info.otp_sec_key_8));
                  memset(otp_set_info.otp_exg_key_9, 0x00, sizeof(otp_set_info.otp_exg_key_9));
                  memset(otp_set_info.otp_sec_key_9, 0x00, sizeof(otp_set_info.otp_sec_key_9));
                  memcpy(otp_set_info.otp_exg_key_8, temp_exg_key_8, 4);
                  memcpy(otp_set_info.otp_sec_key_8, temp_sec_key_8, 4);
                  memcpy(otp_set_info.otp_exg_key_9, temp_exg_key_9, 5);
                  memcpy(otp_set_info.otp_sec_key_9, temp_sec_key_9, 5);
                  for (i = 0; i < 10; i++)
                  {
                    otp_set_info.g_pwd_signed_data[i].num = i;
                    memcpy(otp_set_info.g_pwd_signed_data[i].exchg_num, temp_pwd_signed_data[i].exchg_num, 5);
                  }
                }
              //NRF_LOG_PRINTF_DEBUG("dq_sdk_otp_init entry otp_set_info.init_suc_flag = %d \n",otp_set_info.init_suc_fl
             -ag);
              #endif
 657   1        //g_dq_otp_init.get_admin_status(&admin_state, &ret);
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 12  

 658   1        if (otp_set_info.init_suc_flag == 1 && admin_state != 0)
 659   1        {
 660   2          // extern uint8_t wdt_flag;
 661   2          uint8_t wdt_flag;
 662   2          dq_dev_key_flag = 1;
 663   2          //LOG
 664   2          memset(&otp_lock_log, 0xFF, sizeof(otp_lock_log));
 665   2          //g_dq_otp_init.fds_read(DQ_OTP_FILE_ID_LOG, (uint8_t *)&otp_lock_log, sizeof(otp_lock_log), &ret);
 666   2          dq_otp_find_log_head_end();
 667   2          //init ekey
 668   2      #ifndef __LOCK_USE_MALLOC__
 669   2          memset(&g_dq_app_pwd_info, 0xFF, sizeof(g_dq_app_pwd_info));
 670   2          //g_dq_otp_init.fds_read(DQ_OTP_FILE_ID_PWD_APP, (uint8_t *)&g_dq_app_pwd_info, sizeof(otp_base_app_pwd_
             -info) * DQ_OTP_APP_PWD_NUM, &ret);
 671   2      
 672   2          memset(&g_dq_app_fp_info, 0xFF, sizeof(g_dq_app_fp_info));
 673   2          //g_dq_otp_init.fds_read(DQ_OTP_FILE_ID_FP, (uint8_t *)&g_dq_app_fp_info, sizeof(otp_base_app_fp_info) *
             - DQ_OTP_APP_FP_NUM, &ret);
 674   2      
 675   2          memset(&g_dq_app_rfid_info, 0xFF, sizeof(g_dq_app_rfid_info));
 676   2          //g_dq_otp_init.fds_read(DQ_OTP_FILE_ID_RFID, (uint8_t *)&g_dq_app_rfid_info, sizeof(otp_base_app_rfid_i
             -nfo) * DQ_OTP_APP_RFID_NUM, &ret);
 677   2      #endif
 678   2          g_dq_otp_init.init_sucess(1);
 679   2      
 680   2          if (wdt_flag == 1)
 681   2          {
 682   3            //NRF_LOG_PRINTF_DEBUG("###wdt_flag   1\n");
 683   3            dq_otp_add_alarm_log(DQ_ALART_LOG_ERROR_RESET);
 684   3          }
 685   2        }
 686   1        else
 687   1        {
 688   2          dq_dev_key_flag = 0;
 689   2      
 690   2          memset(&otp_set_info, 0xFF, sizeof(otp_set_info));
 691   2          //LOG
 692   2          memset(otp_lock_log, 0xFF, sizeof(otp_lock_log));
 693   2          otp_log_head = 0;
 694   2          otp_log_end = 0;
 695   2          //init ekey
 696   2      
 697   2      #ifndef __LOCK_USE_MALLOC__
 698   2          for (i = 0; i < DQ_OTP_APP_PWD_NUM; i++)
 699   2          {
 700   3            //g_dq_app_pwd_info[i].pwd_index = 0xFF;
 701   3            memset(g_dq_app_pwd_info[i].app_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].app_pwd));
 702   3            memset(g_dq_app_pwd_info[i].replace_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].replace_pwd));
 703   3            g_dq_app_pwd_info[i].pwd_type = 0xFF;
 704   3            g_dq_app_pwd_info[i].pwd_flag = 0xFF;
 705   3            //g_dq_app_pwd_info[i].pwd_end_time = 0xFFFFFFFF;
 706   3          }
 707   2      
 708   2          for (i = 0; i < DQ_OTP_APP_FP_NUM; i++)
 709   2          {
 710   3            g_dq_app_fp_info[i].fp_start_time = 0xFFFFFFFF;
 711   3            g_dq_app_fp_info[i].fp_end_time = 0xFFFFFFFF;
 712   3          }
 713   2      
 714   2          for (i = 0; i < DQ_OTP_APP_RFID_NUM; i++)
 715   2          {
 716   3            g_dq_app_rfid_info[i].rfid_start_time = 0xFFFFFFFF;
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 13  

 717   3            g_dq_app_rfid_info[i].rfid_end_time = 0xFFFFFFFF;
 718   3          }
 719   2      #endif
 720   2          g_dq_otp_init.init_sucess(0);
 721   2        }
 722   1        return;
 723   1      }
*** WARNING C280 IN LINE 575 OF mmi_src\dq_sdk_main.c: 'ret': unreferenced local variable
 724          /*
 725          parameter: 
 726            none
 727          return :
 728            none
 729          */
 730          OTP_TYPE dq_otp_get_cmd_type(unsigned char *p_data)
 731          {
 732   1        unsigned char i = 0;
 733   1      
 734   1        for (i = 0; i < CMD_OTP_MAX_NUM; i++)
 735   1        {
 736   2          if ((cmd_info[i].cmd_h == p_data[0]) && (cmd_info[i].cmd_l == p_data[1]))
 737   2            break;
 738   2        }
 739   1        if (i < CMD_OTP_MAX_NUM)
 740   1          return cmd_info[i].cmd;
 741   1        else
 742   1          return CMD_OTP_INVALID;
 743   1      }
 744          
 745          /*
 746          parameter: 
 747            none
 748          return :
 749            none
 750          */
 751          void dq_otp_setSerialId(uint8_t *p_data)
 752          {
 753   1        //char serialData[4+1];
 754   1        //uint8_t bytes[2];
 755   1      
 756   1        //memset(serialData,0,4+1);
 757   1        //sprintf((char *)serialData,(const char *)"%04x",serialId);
 758   1        //dq_sdk_HexStrToByte(serialData,bytes,4);
 759   1      
 760   1        //data[14] = bytes[0];
 761   1        //data[15] = bytes[1];
 762   1      
 763   1        //data[14] = (serialId>>8)&0xFF;
 764   1        p_data[14] = 0xFF;
 765   1        p_data[15] = serialId & 0xFF;
 766   1        return;
 767   1      }
 768          
 769          /*
 770          parameter: 
 771            none
 772          return :
 773            none
 774          */
 775          void dq_otp_getCRCBytes(uint8_t *in, uint8_t *out)
 776          {
 777   1        unsigned short crc = CRC16_CCITT_FALSE(in, DQ_OTP_CMD_NO_CRC_LENGTH / 2);
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 14  

 778   1        out[0] = (0xff00 & crc) >> 8;
 779   1        out[1] = 0xff & crc;
 780   1        return;
 781   1      }
 782          
 783          /*
 784          parameter: 
 785            none
 786          return :
 787            none
 788          */
 789          void dq_otp_getCmdEncryptData(uint8_t *in, uint8_t *out)
 790          {
 791   1        //if (dq_dev_key_flag == 1)
 792   1          //DQ_AES128_ECB_encrypt(in, otp_set_info.otp_dev_key, out);
 793   1        //else
 794   1          //DQ_AES128_ECB_encrypt(in, DQ_OTP_AES_GBL_KEY, out);
 795   1      
 796   1        return;
 797   1      }
*** WARNING C280 IN LINE 789 OF mmi_src\dq_sdk_main.c: 'in': unreferenced local variable
*** WARNING C280 IN LINE 789 OF mmi_src\dq_sdk_main.c: 'out': unreferenced local variable
 798          
 799          /*
 800          parameter: 
 801            none
 802          return :
 803            none
 804          */
 805          void dq_otp_getCmdDecryptData(uint8_t *in, uint8_t *out)
 806          {
 807   1        static uint8_t encrypt[DQ_OTP_CMD_NO_CRC_LENGTH / 2 + 1];
 808   1        memset(encrypt, 0, DQ_OTP_CMD_NO_CRC_LENGTH / 2 + 1);
 809   1        memcpy(encrypt, in, DQ_OTP_CMD_NO_CRC_LENGTH / 2);
 810   1        //if (dq_dev_key_flag == 1)
 811   1          //DQ_AES128_ECB_decrypt(encrypt, otp_set_info.otp_dev_key, out);
 812   1        //else
 813   1          //DQ_AES128_ECB_decrypt(encrypt, DQ_OTP_AES_GBL_KEY, out);
 814   1        return;
 815   1      }
*** WARNING C280 IN LINE 805 OF mmi_src\dq_sdk_main.c: 'out': unreferenced local variable
 816          
 817          /*
 818          parameter: 
 819            none
 820          return :
 821            none
 822          */
 823          void dq_otp_notify(uint8_t *p_data)
 824          {
 825   1        uint8_t crc_data[2];
 826   1        uint8_t encrypt_data[DQ_OTP_CMD_NO_CRC_LENGTH / 2 + 1];
 827   1        uint8_t notify_data[DQ_OTP_CMD_NO_CRC_LENGTH / 2 + DQ_OTP_CMD_NO_CRC_LENGTH / 2 + 1];
 828   1        uint32_t ret = 0;
 829   1      
 830   1        memset(encrypt_data, 0, DQ_OTP_CMD_NO_CRC_LENGTH / 2 + 1);
 831   1        memset(notify_data, 0, DQ_OTP_CMD_NO_CRC_LENGTH / 2 + DQ_OTP_CMD_NO_CRC_LENGTH / 2 + 1);
 832   1      
 833   1        dq_otp_getCmdEncryptData(p_data, encrypt_data);
 834   1        dq_otp_getCRCBytes(p_data, crc_data);
 835   1      
 836   1        memcpy(notify_data, encrypt_data, DQ_OTP_CMD_NO_CRC_LENGTH / 2);
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 15  

 837   1        notify_data[16] = crc_data[0];
 838   1        notify_data[17] = crc_data[1];
 839   1      
 840   1        //g_dq_otp_init.data_send_bt(notify_data, DQ_OTP_CMD_NO_CRC_LENGTH / 2 + 2, &ret);
 841   1      
 842   1        serialId++;
 843   1        return;
 844   1      }
 845          
 846          /*
 847          parameter: 
 848            none
 849          return :
 850            none
 851          */
 852          void dq_otp_device_key_unknow(uint8_t instruct_h, uint8_t instruct_l, uint8_t result_code)
 853          {
 854   1        uint8_t notify_data[DQ_OTP_CMD_NO_CRC_LENGTH / 2];
 855   1        unsigned char i = 0;
 856   1        uint32_t ret = 0;
 857   1      
 858   1        memset(notify_data, 0x00, DQ_OTP_CMD_NO_CRC_LENGTH / 2);
 859   1        //instruct
 860   1        notify_data[0] = instruct_h;
 861   1        notify_data[1] = instruct_l;
 862   1        //result
 863   1        notify_data[2] = result_code;
 864   1        //padding
 865   1        notify_data[3] = 0xFF;
 866   1      #ifndef __WIN32_ENV_SUPPORT__
 867   1        for (i = 0; i < 16; i++)
 868   1        {
 869   2          //NRF_LOG_PRINTF_DEBUG("dq_otp_device_key_unknow notify_data[%d] = 0x%x \n", i, notify_data[i]);
 870   2        }
 871   1      #endif
 872   1        //g_dq_otp_init.data_send_bt(notify_data, 4, &ret);
 873   1        return;
 874   1      }
 875          
 876          /*
 877          parameter: 
 878            none
 879          return :
 880            none
 881          */
 882          void dq_otp_common_reply(uint8_t instruct_h, uint8_t instruct_l, uint8_t result_code)
 883          {
 884   1        uint8_t notify_data[DQ_OTP_CMD_NO_CRC_LENGTH / 2];
 885   1        unsigned char i = 0;
 886   1        memset(notify_data, 0, DQ_OTP_CMD_NO_CRC_LENGTH / 2);
 887   1        //instruct
 888   1        notify_data[0] = instruct_h;
 889   1        notify_data[1] = instruct_l;
 890   1        //result
 891   1        notify_data[2] = result_code;
 892   1        //padding
 893   1        notify_data[3] = 0xFF;
 894   1        notify_data[4] = 0xFF;
 895   1        notify_data[5] = 0xFF;
 896   1        notify_data[6] = 0xFF;
 897   1        notify_data[7] = 0xFF;
 898   1        notify_data[8] = 0xFF;
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 16  

 899   1        notify_data[9] = 0xFF;
 900   1        notify_data[10] = 0xFF;
 901   1        notify_data[11] = 0xFF;
 902   1        notify_data[12] = 0xFF;
 903   1        notify_data[13] = 0xFF;
 904   1      
 905   1        //serialId
 906   1        dq_otp_setSerialId(notify_data);
 907   1        for (i = 0; i < 16; i++)
 908   1        {
 909   2          //NRF_LOG_PRINTF_DEBUG("dq_otp_common_reply notify_data[%d] = 0x%x \n", i, notify_data[i]);
 910   2        }
 911   1        dq_otp_notify(notify_data);
 912   1        return;
 913   1      }
 914          
 915          /*
 916          parameter: 
 917            none
 918          return :
 919            none
 920          */
 921          void dq_otp_send_data_reply(uint8_t instruct_h, uint8_t instruct_l, uint8_t result_code, uint8_t *p_data, 
             -uint8_t data_len)
 922          {
 923   1        uint8_t notify_data[DQ_OTP_CMD_NO_CRC_LENGTH / 2];
 924   1        uint8_t i = 0;
 925   1        memset(notify_data, 0, DQ_OTP_CMD_NO_CRC_LENGTH / 2);
 926   1        //instruct
 927   1        notify_data[0] = instruct_h;
 928   1        notify_data[1] = instruct_l;
 929   1        //result
 930   1        notify_data[2] = result_code;
 931   1        //padding
 932   1        if (data_len > 11)
 933   1          return;
 934   1        for (i = 0; i < data_len; i++)
 935   1        {
 936   2          notify_data[3 + i] = *p_data++;
 937   2        }
 938   1        for (i = data_len; i < 11; i++)
 939   1        {
 940   2          notify_data[3 + i] = 0xFF;
 941   2        }
 942   1        dq_otp_setSerialId(notify_data);
 943   1      
 944   1        for (i = 0; i < 11; i++)
 945   1        {
 946   2          //NRF_LOG_PRINTF_DEBUG("dq_otp_send_data_reply notify_data[%d] = 0x%x \n", i, notify_data[i]);
 947   2        }
 948   1        //serialId
 949   1        dq_otp_notify(notify_data);
 950   1        return;
 951   1      }
 952          /*
 953          parameter: 
 954            none
 955          return :
 956            none
 957          */
 958          void dq_otp_send_data_no_result_reply(uint8_t instruct_h, uint8_t instruct_l, uint8_t *p_data, uint8_t dat
             -a_len)
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 17  

 959          {
 960   1        uint8_t notify_data[DQ_OTP_CMD_NO_CRC_LENGTH / 2];
 961   1        uint8_t i = 0;
 962   1        memset(notify_data, 0, DQ_OTP_CMD_NO_CRC_LENGTH / 2);
 963   1        //instruct
 964   1        notify_data[0] = instruct_h;
 965   1        notify_data[1] = instruct_l;
 966   1        //padding
 967   1        if (data_len > 12)
 968   1          return;
 969   1        for (i = 0; i < data_len; i++)
 970   1        {
 971   2          notify_data[2 + i] = *p_data++;
 972   2        }
 973   1        for (i = data_len; i < 12; i++)
 974   1        {
 975   2          notify_data[2 + i] = 0xFF;
 976   2        }
 977   1        //serialId
 978   1        dq_otp_setSerialId(notify_data);
 979   1        dq_otp_notify(notify_data);
 980   1        return;
 981   1      }
 982          
 983          //Abnormal disconnection
 984          void dq_otp_disconnect_pro(void)
 985          {
 986   1        uint8_t flag = 0;
 987   1        uint8_t result;
 988   1        if (otp_set_info.init_suc_flag == 0xFF)
 989   1        {
 990   2          dq_dev_key_flag = 0;
 991   2          memset(&otp_set_info, 0xFF, sizeof(otp_set_info));
 992   2        }
 993   1      
 994   1        flag = dq_otp_app_get_operate_lock_flag();
 995   1        if (flag == 1)
 996   1        {
 997   2          switch (g_dq_otp_type)
 998   2          {
 999   3          case CMD_OTP_VERY_ADMIN_STA:
1000   3            g_dq_otp_init.stop_verify_admin_status(&result);
1001   3            break;
1002   3          case CMD_OTP_ADD_FP:
1003   3            g_dq_link_error = 1;
1004   3            g_dq_otp_init.stop_set_lock_fp(&result);
1005   3            break;
1006   3          case CMD_OTP_ADD_RFID:
1007   3            g_dq_link_error = 1;
1008   3            g_dq_otp_init.stop_set_lock_rfid(&result);
1009   3            break;
1010   3          }
1011   2        }
1012   1      
1013   1        //if(g_dq_dfu_permit == 2)
1014   1        //  g_dq_dfu_permit = 0;
1015   1      }
1016          
1017          uint8_t dq_otp_get_link_state(void)
1018          {
1019   1        return g_dq_link_error;
1020   1      }
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 18  

1021          
1022          void dq_otp_lock_timeout(void)
1023          {
1024   1        uint8_t flag = 0;
1025   1      
1026   1        flag = dq_otp_app_get_operate_lock_flag();
1027   1        if (flag == 1)
1028   1        {
1029   2          switch (g_dq_otp_type)
1030   2          {
1031   3          case CMD_OTP_VERY_ADMIN_STA:
1032   3            dq_otp_app_set_operate_lock_flag(0);
1033   3            dq_otp_check_lock_admin_pwd_fp_ret(1);
1034   3            break;
1035   3      #if defined(__LOCK_FP_SUPPORT__) || defined(__LOCK_FP_SUPPORT2__) || defined(__LOCK_FP_SUPPORT1_2__)
                  case CMD_OTP_ADD_FP:
                    dq_otp_app_add_lock_fp_result(1, 0);
                    break;
              #endif
1040   3      #ifdef __LOCK_RFID_CARD_SUPPORT__
1041   3          case CMD_OTP_ADD_RFID:
1042   3            dq_otp_app_add_lock_rfid_result(1, 0);
1043   3            break;
1044   3      #endif
1045   3          }
1046   2        }
1047   1      }
1048          
1049          /*
1050          parameter: 
1051            none
1052          return :
1053            none
1054          */
1055          void dq_otp_dataCheck(uint8_t *p_data, uint16_t length)
1056          {
1057   1      #ifndef __WIN32_ENV_SUPPORT__
1058   1        uint8_t decrypt_data[DQ_OTP_CMD_NO_CRC_LENGTH / 2 + 1];
1059   1        uint8_t crc_data[2];
1060   1        bool isPassCRC = false;
1061   1      
1062   1      //  NRF_LOG_PRINTF_DEBUG("dq_otp_dataCheck length\n");
1063   1      
1064   1        memset(decrypt_data, 0, DQ_OTP_CMD_NO_CRC_LENGTH / 2 + 1);
1065   1        dq_otp_getCmdDecryptData(p_data, decrypt_data);
1066   1        dq_otp_getCRCBytes(decrypt_data, crc_data);
1067   1        if (crc_data[0] == p_data[length - 2] && crc_data[1] == p_data[length - 1])
1068   1        {
1069   2          isPassCRC = true;
1070   2        }
1071   1        else
1072   1        {
1073   2          isPassCRC = false;
1074   2        }
1075   1        if (isPassCRC)
1076   1        {
1077   2          dq_otp_cmd_dataOperation(decrypt_data, length);
1078   2        }
1079   1        else
1080   1        {
1081   2          uint8_t p_data[] = "efef0001";
1082   2          uint32_t ret = 0;
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 19  

1083   2      //    g_dq_otp_init.data_send_bt(p_data, 8, &ret);
1084   2        }
1085   1      #else
                dq_otp_cmd_dataOperation(p_data, length);
              #endif
1088   1        return;
1089   1      }
1090          
1091          /*
1092          parameter: 
1093            none
1094          return :
1095            none
1096          */
1097          //0101 84757AEBE3987D3E 00 FFFF FFFF 99
1098          static OTP_BASE_RET dq_otp_syn_aes_16_key(unsigned char *p_data)
1099          {
1100   1        unsigned char i = 0;
1101   1        unsigned char c_aes_key[8];
1102   1        int end_flag = p_data[10];
1103   1      
1104   1        memset(c_aes_key, 0x00, sizeof(c_aes_key));
1105   1        for (i = 2; i < 10; i++)
1106   1        {
1107   2          c_aes_key[i - 2] = p_data[i];
1108   2      #ifndef __WIN32_ENV_SUPPORT__
1109   2      //    NRF_LOG_PRINTF_DEBUG("dq_otp_syn_aes_16_key c_aes_key[%d] = 0x%x \n", i - 2, c_aes_key[i - 2]);
1110   2      #endif
1111   2        }
1112   1        if (end_flag == 0)
1113   1        {
1114   2          memset(otp_set_info.otp_dev_key, 0x00, sizeof(otp_set_info.otp_dev_key));
1115   2          memcpy(otp_set_info.otp_dev_key, c_aes_key, sizeof(c_aes_key));
1116   2        }
1117   1        else if (end_flag == 1)
1118   1        {
1119   2          memcpy(otp_set_info.otp_dev_key + 8, (const char *)c_aes_key, sizeof(c_aes_key));
1120   2          dq_dev_key_flag = 1;
1121   2        }
1122   1        return OTP_BASE_SUCESS;
1123   1      }
1124          
1125          /*
1126          parameter: 
1127            none
1128          return :
1129            none
1130          */
1131          //0102 73638150 35817426 FFFF FFFF FF 99
1132          static OTP_BASE_RET dq_otp_syn_sec_8_key(unsigned char *p_data)
1133          {
1134   1        uint8_t i = 0;
1135   1        memset(otp_set_info.otp_sec_key_8, 0xFF, sizeof(otp_set_info.otp_sec_key_8));
1136   1        memset(otp_set_info.otp_exg_key_8, 0xFF, sizeof(otp_set_info.otp_exg_key_8));
1137   1        for (i = 0; i < 4; i++)
1138   1        {
1139   2          otp_set_info.otp_sec_key_8[i] = p_data[i + 2];
1140   2        }
1141   1        for (i = 0; i < 4; i++)
1142   1        {
1143   2          otp_set_info.otp_exg_key_8[i] = p_data[i + 6];
1144   2        }
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 20  

1145   1        return OTP_BASE_SUCESS;
1146   1      }
1147          /*
1148          parameter: 
1149            none
1150          return :
1151            none
1152          */
1153          //0103 736381504F 358174265F FFFF FF 99
1154          static OTP_BASE_RET dq_otp_syn_sec_9_key(unsigned char *p_data)
1155          {
1156   1        uint8_t i = 0;
1157   1        memset(otp_set_info.otp_sec_key_9, 0xFF, sizeof(otp_set_info.otp_sec_key_9));
1158   1        memset(otp_set_info.otp_exg_key_9, 0xFF, sizeof(otp_set_info.otp_exg_key_9));
1159   1        for (i = 0; i < 5; i++)
1160   1        {
1161   2          otp_set_info.otp_sec_key_9[i] = p_data[i + 2];
1162   2        }
1163   1        otp_set_info.otp_sec_key_9[4] |= 0x0F;
1164   1      
1165   1        for (i = 0; i < 5; i++)
1166   1        {
1167   2          otp_set_info.otp_exg_key_9[i] = (p_data[i + 6] << 4) + ((p_data[i + 7] >> 4) & 0x0F);
1168   2        }
1169   1      
1170   1        return OTP_BASE_SUCESS;
1171   1      }
1172          /*
1173          parameter: 
1174            none
1175          return :
1176            none
1177          */
1178          //0104 5D134A30 FFFF FFFF FFFF FFFF FF 99
1179          static OTP_BASE_RET dq_otp_syn_start_time(unsigned char *p_data)
1180          {
1181   1        uint8_t i = 0;
1182   1        unsigned char start_time[5];
1183   1      
1184   1        memset(start_time, 0x00, sizeof(start_time));
1185   1        for (i = 0; i < 5; i++)
1186   1        {
1187   2          start_time[i] = p_data[i + 2];
1188   2        }
1189   1        if (otp_set_info.otp_start_hour == 0xFFFFFFFF)
1190   1        {
1191   2          otp_set_info.otp_start_hour = dq_sdk_HexcharToInt(start_time, 4);
1192   2          return OTP_BASE_SUCESS;
1193   2        }
1194   1        else
1195   1        {
1196   2          uint8_t ret;
1197   2          otp_set_info.otp_start_hour = dq_sdk_HexcharToInt(start_time, 4);
1198   2          g_dq_cmd_repleys_status = OTP_BASE_SUCESS;
1199   2      //    g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_SET, (unsigned char *)&otp_set_info, sizeof(otp_base_setting_in
             -fo), &ret, dq_otp_fds_write_common_cb);
1200   2          return OTP_BASE_BUSY;
1201   2        }
1202   1      }
*** WARNING C280 IN LINE 1196 OF mmi_src\dq_sdk_main.c: 'ret': unreferenced local variable
1203          
1204          /*
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 21  

1205          parameter: 
1206            none
1207          return :
1208            none
1209          */
1210          //0105 00 4316982507 01 2641538970 FF 99
1211          static OTP_BASE_RET dq_otp_syn_exchange_num(unsigned char *p_data)
1212          {
1213   1        uint8_t i = 0, j = 0;
1214   1        uint8_t num = 0;
1215   1        unsigned char exg_num[5];
1216   1        OTP_BASE_RET ret_val = OTP_BASE_SUCESS;
1217   1      
1218   1        for (j = 0; j < 2; j++)
1219   1        {
1220   2          num = p_data[2 + 6 * j];
1221   2          if (num > 9)
1222   2          {
1223   3            ret_val = OTP_BASE_FAIL;
1224   3            break;
1225   3          }
1226   2          otp_set_info.g_pwd_signed_data[num].num = num;
1227   2          memset(exg_num, 0x00, sizeof(exg_num));
1228   2          for (i = 0; i < 5; i++)
1229   2          {
1230   3            otp_set_info.g_pwd_signed_data[num].exchg_num[i] = p_data[3 + i + j * 6];
1231   3          }
1232   2        }
1233   1        return ret_val;
1234   1      }
1235          /*
1236          parameter: 
1237            none
1238          return :
1239            none
1240          */
1241          //0404 0060 FFFF FFFF FFFF FFFF FFFF 8899
1242          static void dq_otp_lock_init_complete(uint8_t *p_data)
1243          {
1244   1        uint8_t ret = 0;
1245   1      
1246   1        otp_set_info.init_suc_flag = 1;
1247   1        g_dq_cmd_repleys_status = OTP_BASE_SUCESS;
1248   1      //  g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_SET, (unsigned char *)&otp_set_info, sizeof(otp_base_setting_inf
             -o), &ret, dq_otp_fds_write_common_cb);
1249   1        return;
1250   1      }
*** WARNING C280 IN LINE 1242 OF mmi_src\dq_sdk_main.c: 'p_data': unreferenced local variable
1251          #if 0
              /*
              parameter: 
                none
              return :
                none
              */
              static uint8_t dq_otp_check_ekey_week(uint8_t ekey_week)
              {
                unsigned char sys_week;
                unsigned short bit_week = 1;
                uint8_t week_off;
                sys_week = dq_otp_get_sys_time_week();
                week_off = bit_week << sys_week;
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 22  

                if((week_off&ekey_week) > 0)
                  return 1;
                else
                  return 0;
              }
              /*
              parameter: 
                none
              return :
                none
              */
              static uint8_t dq_otp_check_per_ekey_verify(time_t start_time,time_t end_time,time_t sys_time)
              {
                if((sys_time >= start_time)&&(sys_time <= end_time))
                  return 1;
                else
                  return 0;
              }
              /*
              parameter: 
                none
              return :
                none
              */
              static uint8_t dq_otp_check_sin_ekey_verify(time_t start_time,time_t end_time,time_t sys_time)
              {
                if((sys_time >= start_time)&&(sys_time <= end_time))
                  return 1;
                else
                  return 0;
              }
              
              /*
              parameter: 
                none
              return :
                none
              */
              static uint8_t dq_otp_check_lim_ekey_verify(time_t start_time,time_t end_time,time_t sys_time)
              {
                if((sys_time >= start_time)&&(sys_time <= end_time))
                  return 1;
                else
                  return 0;
              }
              /*
              parameter: 
                none
              return :
                none
              */
              static uint8_t dq_otp_check_loop_ekey_verify(time_t start_time,time_t end_time,time_t sys_time,uint8_t wee
             -k_info)
              { 
                uint8_t ret_val = 0;
                uint32_t start_hour = start_time%(3600*24);
                uint32_t end_hour = end_time%(3600*24);
                uint32_t sys_hour = sys_time%(3600*24);
              
                ret_val = dq_otp_check_ekey_week(week_info);
                if(ret_val == 0)
                  return 0;
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 23  

                if((sys_time >= start_time)&&(sys_time <= end_time))
                {
                  if((sys_hour >= start_hour)&&(sys_hour <= end_hour))
                    return 1;
                }
                return 0;
              }
              #endif
1334          
1335          /*
1336          parameter: 
1337            none
1338          return :
1339            none
1340          */
1341          //0201 01 5C89B5B8 5CEA6BB0 7F FF FF FF 99
1342          static OTP_BASE_RET dq_otp_check_ekey_verify(uint8_t *p_data)
1343          {
1344   1      #if 1
1345   1        uint8_t check_byte[2];
1346   1        uint16_t check_sum = 0;
1347   1        uint8_t i;
1348   1        if (dq_otp_get_lock_state())
1349   1          return OTP_BASE_FAIL;
1350   1      
1351   1        for (i = 0; i <= 10; i++)
1352   1        {
1353   2          check_sum += p_data[i];
1354   2        }
1355   1      
1356   1        check_byte[0] = (0xff00 & check_sum) >> 8;
1357   1        check_byte[1] = 0xff & check_sum;
1358   1      
1359   1        if (check_byte[0] == p_data[12] && check_byte[1] == p_data[11])
1360   1          return OTP_BASE_SUCESS;
1361   1        else
1362   1          return OTP_BASE_FAIL;
1363   1      
1364   1      #else
                uint8_t i = 0;
                uint8_t ekey_time[5];
                uint32_t ekey_start_time = 0;
                uint32_t ekey_end_time = 0;
                time_t sys_time_sec;
                uint8_t week_info = pdata[11];
                uint8_t ekey_type = pdata[2];
                uint8_t ret_val = 0;
              
                memset(ekey_time, 0x00, sizeof(ekey_time));
                for (i = 0; i < 4; i++)
                {
                  ekey_time[i] = pdata[i + 3];
                }
                ekey_start_time = dq_sdk_HexcharToInt(ekey_time, 4);
              
                memset(ekey_time, 0x00, sizeof(ekey_time));
                for (i = 0; i < 4; i++)
                {
                  ekey_time[i] = pdata[i + 7];
                }
                ekey_end_time = dq_sdk_HexcharToInt(ekey_time, 4);
              
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 24  

                sys_time_sec = dq_otp_get_sys_time_sec();
              
                if (ekey_type == 0x01) //per ekey
                {
                  ret_val = dq_otp_check_per_ekey_verify(ekey_start_time, ekey_end_time, sys_time_sec);
                }
                else if (ekey_type == 0x02) //sin ekey
                {
                  ret_val = dq_otp_check_sin_ekey_verify(ekey_start_time, ekey_end_time, sys_time_sec);
                }
                else if (ekey_type == 0x03) //lim ekey
                {
                  ret_val = dq_otp_check_lim_ekey_verify(ekey_start_time, ekey_end_time, sys_time_sec);
                }
                else if (ekey_type == 0x04) //loop ekey
                {
                  ret_val = dq_otp_check_loop_ekey_verify(ekey_start_time, ekey_end_time, sys_time_sec, week_info);
                }
                if (ret_val == 1)
                  return OTP_BASE_SUCESS;
                else
                  return OTP_BASE_FAIL;
              
              #endif
1412   1      }
1413          
1414          /*
1415          parameter: 
1416            none
1417          return :
1418            none
1419          */
1420          static uint8_t dq_otp_get_pwd_type(uint8_t *pwd)
1421          {
1422   1        if (pwd[0] <= 5)
1423   1        {
1424   2          return OTP_PWD_TYPE_LIM;
1425   2        }
1426   1        else if (pwd[0] == 6)
1427   1        {
1428   2          return OTP_PWD_TYPE_LOOP;
1429   2        }
1430   1        else if (pwd[0] == 7)
1431   1        {
1432   2          return OTP_PWD_TYPE_CLR;
1433   2        }
1434   1        else if (pwd[0] == 8)
1435   1        {
1436   2          return OTP_PWD_TYPE_SIN;
1437   2        }
1438   1        else if (pwd[0] == 9)
1439   1        {
1440   2          return OTP_PWD_TYPE_PER;
1441   2        }
1442   1        return OTP_PWD_TYPE_INVALID;
1443   1      }
1444          
1445          /*
1446          parameter: 
1447            none
1448          return :
1449            none
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 25  

1450          */
1451          static uint8_t dq_otp_get_pwd_len(uint8_t *pwd, uint8_t len)
1452          {
1453   1        uint8_t i = 0;
1454   1        uint8_t pwd_l = 0;
1455   1        uint8_t pwd_h = 0;
1456   1        uint8_t pwd_len = 0;
1457   1      
1458   1        for (i = 0; i < len; i++)
1459   1        {
1460   2          pwd_h = (pwd[i] & 0xF0) >> 4;
1461   2          if (pwd_h == 0x0F)
1462   2            break;
1463   2          else
1464   2            pwd_len++;
1465   2          pwd_l = (pwd[i] & 0x0F);
1466   2          if (pwd_l == 0x0F)
1467   2            break;
1468   2          else
1469   2            pwd_len++;
1470   2        }
1471   1        return pwd_len;
1472   1      }
1473          /*
1474          parameter: 
1475            none
1476          return :
1477            none
1478          */
1479          static uint8_t dq_otp_get_empty_pwd_index(void)
1480          {
1481   1        uint8_t i = 0;
1482   1        unsigned short sys_hour = 0;
1483   1      
1484   1        dq_otp_get_sys_time_hour(&sys_hour);
1485   1      
1486   1        for (i = 0; i < DQ_OTP_APP_PWD_NUM; i++)
1487   1        {
1488   2          switch (g_dq_app_pwd_info[i].pwd_type)
1489   2          {
1490   3          case OTP_PWD_TYPE_PER:
1491   3            if (g_dq_app_pwd_info[i].pwd_flag == 2)
1492   3            {
1493   4              unsigned char dec_pwd_char[15];
1494   4              unsigned short pwd_hour;
1495   4              unsigned char len = dq_otp_get_pwd_len(g_dq_app_pwd_info[i].app_pwd, 5);
1496   4              memset(dec_pwd_char, 0x00, sizeof(dec_pwd_char));
1497   4              dq_otp_enc_pwd(g_dq_app_pwd_info[i].app_pwd, len, otp_set_info.otp_sec_key_8, otp_set_info.otp_exg_key
             -_8, dec_pwd_char);
1498   4              pwd_hour = dq_otp_get_pwd_time_hour(dec_pwd_char, 5, 1);
1499   4              if (sys_hour >= (pwd_hour + 24))
1500   4              {
1501   5                memset(g_dq_app_pwd_info[i].app_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].app_pwd));
1502   5                memset(g_dq_app_pwd_info[i].replace_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].replace_pwd));
1503   5                g_dq_app_pwd_info[i].pwd_flag = 0xFF;
1504   5                g_dq_app_pwd_info[i].pwd_type = 0xFF;
1505   5              }
1506   4            }
1507   3            break;
1508   3          case OTP_PWD_TYPE_SIN:
1509   3          {
1510   4            unsigned char dec_pwd_char[15];
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 26  

1511   4            unsigned short pwd_hour;
1512   4            unsigned char len = dq_otp_get_pwd_len(g_dq_app_pwd_info[i].app_pwd, 5);
1513   4            memset(dec_pwd_char, 0x00, sizeof(dec_pwd_char));
1514   4            dq_otp_enc_pwd(g_dq_app_pwd_info[i].app_pwd, len, otp_set_info.otp_sec_key_8, otp_set_info.otp_exg_key_
             -8, dec_pwd_char);
1515   4            pwd_hour = dq_otp_get_pwd_time_hour(dec_pwd_char, 5, 1);
1516   4      
1517   4            if (pwd_hour + 6 <= sys_hour)
1518   4            {
1519   5              memset(g_dq_app_pwd_info[i].app_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].app_pwd));
1520   5              memset(g_dq_app_pwd_info[i].replace_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].replace_pwd));
1521   5              g_dq_app_pwd_info[i].pwd_flag = 0xFF;
1522   5              g_dq_app_pwd_info[i].pwd_type = 0xFF;
1523   5            }
1524   4          }
1525   3          break;
1526   3          case OTP_PWD_TYPE_LIM:
1527   3          {
1528   4            unsigned char dec_pwd_char[15];
1529   4            unsigned short pwd_hour;
1530   4            unsigned short end_time;
1531   4            unsigned char len = dq_otp_get_pwd_len(g_dq_app_pwd_info[i].app_pwd, 5);
1532   4            memset(dec_pwd_char, 0x00, sizeof(dec_pwd_char));
1533   4            if (len == 8)
1534   4              dq_otp_enc_pwd(g_dq_app_pwd_info[i].app_pwd, len, otp_set_info.otp_sec_key_8, otp_set_info.otp_exg_key
             -_8, dec_pwd_char);
1535   4            else if (len == 9)
1536   4              dq_otp_enc_pwd(g_dq_app_pwd_info[i].app_pwd, len, otp_set_info.otp_sec_key_9, otp_set_info.otp_exg_key
             -_9, dec_pwd_char);
1537   4            pwd_hour = dq_otp_get_pwd_time_hour(dec_pwd_char, 5, 0);
1538   4      
1539   4            end_time = dq_otp_get_lim_pwd_end_time(dec_pwd_char, len) / 3600;
1540   4            if ((g_dq_app_pwd_info[i].pwd_flag == 2 && pwd_hour + 24 <= sys_hour) || (end_time < sys_hour))
1541   4            {
1542   5              memset(g_dq_app_pwd_info[i].app_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].app_pwd));
1543   5              memset(g_dq_app_pwd_info[i].replace_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].replace_pwd));
1544   5              g_dq_app_pwd_info[i].pwd_flag = 0xFF;
1545   5              g_dq_app_pwd_info[i].pwd_type = 0xFF;
1546   5            }
1547   4          }
1548   3          break;
1549   3          case OTP_PWD_TYPE_LOOP:
1550   3            if (g_dq_app_pwd_info[i].pwd_flag == 2)
1551   3            {
1552   4              unsigned char dec_pwd_char[15];
1553   4              unsigned short pwd_hour;
1554   4              unsigned char len = dq_otp_get_pwd_len(g_dq_app_pwd_info[i].app_pwd, 5);
1555   4              memset(dec_pwd_char, 0x00, sizeof(dec_pwd_char));
1556   4              dq_otp_enc_pwd(g_dq_app_pwd_info[i].app_pwd, len, otp_set_info.otp_sec_key_9, otp_set_info.otp_exg_key
             -_9, dec_pwd_char);
1557   4              pwd_hour = dq_otp_get_pwd_time_hour(dec_pwd_char, 5, 1);
1558   4      
1559   4              if (pwd_hour + 24 <= sys_hour)
1560   4              {
1561   5                memset(g_dq_app_pwd_info[i].app_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].app_pwd));
1562   5                memset(g_dq_app_pwd_info[i].replace_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].replace_pwd));
1563   5                g_dq_app_pwd_info[i].pwd_flag = 0xFF;
1564   5                g_dq_app_pwd_info[i].pwd_type = 0xFF;
1565   5              }
1566   4            }
1567   3            break;
1568   3          }
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 27  

1569   2        }
1570   1      
1571   1        for (i = 0; i < DQ_OTP_APP_PWD_NUM; i++)
1572   1        {
1573   2          if (g_dq_app_pwd_info[i].pwd_type == 0xFF)
1574   2            break;
1575   2        }
1576   1        return i;
1577   1      }
1578          
1579          /*
1580          parameter: 
1581            none
1582          return :
1583            none
1584          */
1585          //0211 21 83 13 18 5F  87 68 62 74 FFFF FFFF 99
1586          static OTP_BASE_RET dq_otp_add_user_def_pwd(uint8_t *p_data)
1587          {
1588   1        uint8_t i = 0;
1589   1        uint8_t pwd_index;
1590   1        uint8_t pwd_info[5];
1591   1        uint8_t pwd_len;
1592   1        uint8_t pwd_char[10];
1593   1        uint8_t ret = 0;
1594   1      
1595   1        if ((g_dq_otp_init.check_admin_pwd(&p_data[i + 7])) != 0xFF)
1596   1        {
1597   2          return OTP_BASE_EXIST;
1598   2        }
1599   1        if (dq_otp_check_replace_password(&p_data[i + 7]) == 1)
1600   1          return OTP_BASE_EXIST;
1601   1      
1602   1        for (i = 0; i < 5; i++)
1603   1        {
1604   2          pwd_info[i] = p_data[i + 2];
1605   2        }
1606   1      
1607   1      #ifdef __LOCK_USE_MALLOC__
                g_dq_app_pwd_info = (otp_base_app_pwd_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_PWD, &ret);
              #endif
1610   1        for (i = 0; i < DQ_OTP_APP_PWD_NUM; i++)
1611   1        {
1612   2          if (memcmp(pwd_info, g_dq_app_pwd_info[i].app_pwd, 5) == 0)
1613   2            break;
1614   2        }
1615   1        if (i < DQ_OTP_APP_PWD_NUM)
1616   1        {
1617   2          if (g_dq_app_pwd_info[i].pwd_flag == 2)
1618   2            return OTP_BASE_FAIL;
1619   2      
1620   2          pwd_index = i;
1621   2          for (i = 0; i < 4; i++)
1622   2          {
1623   3            g_dq_app_pwd_info[pwd_index].replace_pwd[i] = p_data[i + 7];
1624   3          }
1625   2          g_dq_app_pwd_info[pwd_index].replace_pwd[4] = 0xFF;
1626   2        }
1627   1        else
1628   1        {
1629   2          pwd_index = dq_otp_get_empty_pwd_index();
1630   2      
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 28  

1631   2          if (pwd_index == DQ_OTP_APP_PWD_NUM)
1632   2            return OTP_BASE_NO_MEM;
1633   2      
1634   2          //g_dq_app_pwd_info[pwd_index].pwd_index = pwd_index;
1635   2      
1636   2          //memset(pwd_info,0xFF,sizeof(pwd_info));
1637   2          for (i = 0; i < 5; i++)
1638   2          {
1639   3            g_dq_app_pwd_info[pwd_index].app_pwd[i] = p_data[i + 2];
1640   3          }
1641   2          //memset(pwd_info,0xFF,sizeof(pwd_info));
1642   2          for (i = 0; i < 4; i++)
1643   2          {
1644   3            g_dq_app_pwd_info[pwd_index].replace_pwd[i] = p_data[i + 7];
1645   3          }
1646   2          g_dq_app_pwd_info[pwd_index].replace_pwd[4] = 0xFF;
1647   2          memset(pwd_char, 0xFF, sizeof(pwd_char));
1648   2          pwd_len = dq_otp_get_pwd_len(g_dq_app_pwd_info[pwd_index].app_pwd, 5);
1649   2          if (pwd_len == 8)
1650   2            dq_otp_enc_pwd(g_dq_app_pwd_info[pwd_index].app_pwd, pwd_len, otp_set_info.otp_sec_key_8, otp_set_info.
             -otp_exg_key_8, pwd_char);
1651   2          else if (pwd_len == 9)
1652   2            dq_otp_enc_pwd(g_dq_app_pwd_info[pwd_index].app_pwd, pwd_len, otp_set_info.otp_sec_key_9, otp_set_info.
             -otp_exg_key_9, pwd_char);
1653   2          g_dq_app_pwd_info[pwd_index].pwd_type = dq_otp_get_pwd_type(pwd_char);
1654   2          if (g_dq_app_pwd_info[pwd_index].pwd_type == OTP_PWD_TYPE_PER)
1655   2          {
1656   3            unsigned short pwd_hour;
1657   3            unsigned short sys_hour = 0;
1658   3      
1659   3            dq_otp_get_sys_time_hour(&sys_hour);
1660   3            pwd_hour = dq_otp_get_pwd_time_hour(pwd_char, 5, 1);
1661   3            if (sys_hour >= (pwd_hour + 24))
1662   3            {
1663   4              memset(g_dq_app_pwd_info[pwd_index].app_pwd, 0xFF, sizeof(g_dq_app_pwd_info[pwd_index].app_pwd));
1664   4              memset(g_dq_app_pwd_info[pwd_index].replace_pwd, 0xFF, sizeof(g_dq_app_pwd_info[pwd_index].replace_pwd
             -));
1665   4              g_dq_app_pwd_info[pwd_index].pwd_flag = 0xFF;
1666   4              g_dq_app_pwd_info[pwd_index].pwd_type = 0xFF;
1667   4              return OTP_BASE_FAIL;
1668   4            }
1669   3          }
1670   2          else if (g_dq_app_pwd_info[pwd_index].pwd_type == OTP_PWD_TYPE_LIM)
1671   2          {
1672   3            unsigned short pwd_hour;
1673   3            unsigned short sys_hour = 0;
1674   3            unsigned short end_time;
1675   3            dq_otp_get_sys_time_hour(&sys_hour);
1676   3            pwd_hour = dq_otp_get_pwd_time_hour(pwd_char, 5, 0);
1677   3      
1678   3            end_time = dq_otp_get_lim_pwd_end_time(pwd_char, pwd_len) / 3600;
1679   3            if ((pwd_hour + 24 <= sys_hour) || (end_time < sys_hour))
1680   3            {
1681   4              memset(g_dq_app_pwd_info[pwd_index].app_pwd, 0xFF, sizeof(g_dq_app_pwd_info[pwd_index].app_pwd));
1682   4              memset(g_dq_app_pwd_info[pwd_index].replace_pwd, 0xFF, sizeof(g_dq_app_pwd_info[pwd_index].replace_pwd
             -));
1683   4              g_dq_app_pwd_info[pwd_index].pwd_flag = 0xFF;
1684   4              g_dq_app_pwd_info[pwd_index].pwd_type = 0xFF;
1685   4              return OTP_BASE_FAIL;
1686   4            }
1687   3          }
1688   2      
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 29  

1689   2          g_dq_app_pwd_info[pwd_index].pwd_flag = 1;
1690   2          //if(g_dq_app_pwd_info[pwd_index].pwd_type == OTP_PWD_TYPE_LIM)
1691   2          //  g_dq_app_pwd_info[pwd_index].pwd_end_time=dq_otp_get_lim_pwd_end_time(pwd_char, pwd_len);
1692   2          //if(g_dq_app_pwd_info[pwd_index].pwd_type == OTP_PWD_TYPE_CLR)
1693   2          //  g_dq_app_pwd_info[pwd_index].pwd_used_flag = 1;//update
1694   2        }
1695   1        //save pwd info
1696   1        g_dq_cmd_repleys_status = OTP_BASE_SUCESS;
1697   1      //  g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_PWD_APP, (unsigned char *)g_dq_app_pwd_info, sizeof(otp_base_app
             -_pwd_info) * DQ_OTP_APP_PWD_NUM, &ret, dq_otp_fds_write_common_cb);
1698   1      #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
1701   1        return OTP_BASE_SUCESS;
1702   1      }
1703          
1704          /*
1705          parameter: 
1706            none
1707          return :
1708            none
1709          */
1710          //0212 8866 7687 3F FFFF FFFF FFFF FFFF 99
1711          static OTP_BASE_RET dq_otp_del_lock_pwd(uint8_t *p_data)
1712          {
1713   1        uint8_t i = 0;
1714   1        uint8_t lock_pwd[5];
1715   1        uint8_t ret = 0;
1716   1      #ifdef __LOCK_USE_MALLOC__
                g_dq_app_pwd_info = (otp_base_app_pwd_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_PWD, &ret);
              #endif
1719   1        memset(lock_pwd, 0xFF, sizeof(lock_pwd));
1720   1        for (i = 0; i < 5; i++)
1721   1        {
1722   2          lock_pwd[i] = p_data[i + 2];
1723   2        }
1724   1        for (i = 0; i < DQ_OTP_APP_PWD_NUM; i++)
1725   1        {
1726   2          if (!memcmp((const char *)g_dq_app_pwd_info[i].app_pwd, (const char *)lock_pwd, 5))
1727   2            break;
1728   2          if (!memcmp((const char *)g_dq_app_pwd_info[i].replace_pwd, (const char *)lock_pwd, 5))
1729   2            break;
1730   2        }
1731   1        if (i < DQ_OTP_APP_PWD_NUM)
1732   1        {
1733   2          memset(g_dq_app_pwd_info[i].app_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].app_pwd));
1734   2          memset(g_dq_app_pwd_info[i].replace_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].replace_pwd));
1735   2          g_dq_app_pwd_info[i].pwd_flag = 0xFF;
1736   2          g_dq_app_pwd_info[i].pwd_type = 0xFF;
1737   2          //save
1738   2      
1739   2          g_dq_cmd_repleys_status = OTP_BASE_SUCESS;
1740   2      //    g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_PWD_APP, (unsigned char *)g_dq_app_pwd_info, sizeof(otp_base_ap
             -p_pwd_info) * DQ_OTP_APP_PWD_NUM, &ret, dq_otp_fds_write_common_cb);
1741   2      #ifdef __LOCK_USE_MALLOC__
                  mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
1744   2      
1745   2          return OTP_BASE_SUCESS;
1746   2        }
1747   1        else
1748   1        {
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 30  

1749   2      #ifdef __LOCK_USE_MALLOC__
                  mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
1752   2          //return OTP_BASE_NOT_FOUND;
1753   2          //
1754   2          return OTP_BASE_SUCESS;
1755   2        }
1756   1      }
1757          /*
1758          parameter: 
1759            none
1760          return :
1761            none
1762          */
1763          //0213 5C90 628C FFFF FFFF FFFF FFFF FF 99
1764          static OTP_BASE_RET dq_otp_clr_lock_pwd(uint8_t *p_data)
1765          {
1766   1        uint8_t i = 0;
1767   1        //uint8_t sys_time[4];
1768   1        //uint32_t sys_time_int = 0;
1769   1        uint8_t ret_val = 0;
1770   1      #ifdef __LOCK_USE_MALLOC__
                uint8_t ret = 0;
                g_dq_app_pwd_info = (otp_base_app_pwd_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_PWD, &ret);
              #endif
1774   1        //memset(sys_time,0xFF,sizeof(sys_time));
1775   1      
1776   1        //for(i=0;i<4;i++)
1777   1        //{
1778   1        //  sys_time[i] = pdata[i+2];
1779   1        //}
1780   1        for (i = 0; i < DQ_OTP_APP_PWD_NUM; i++)
1781   1        {
1782   2          memset(g_dq_app_pwd_info[i].app_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].app_pwd));
1783   2          memset(g_dq_app_pwd_info[i].replace_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].replace_pwd));
1784   2          g_dq_app_pwd_info[i].pwd_flag = 0xFF;
1785   2          g_dq_app_pwd_info[i].pwd_type = 0xFF;
1786   2        }
1787   1        //need save the system time to startime
1788   1      
1789   1        //sys_time_int = dq_sdk_HexcharToInt(sys_time,4);
1790   1      
1791   1        //otp_set_info.otp_start_hour = sys_time_int;
1792   1      
1793   1        //g_dq_otp_init.set_system_time(sys_time_int,&ret_val);
1794   1      
1795   1        g_dq_cmd_repleys_status = OTP_BASE_SUCESS;
1796   1      //  g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_PWD_APP, (unsigned char *)g_dq_app_pwd_info, sizeof(otp_base_app
             -_pwd_info) * DQ_OTP_APP_PWD_NUM, &ret_val, dq_otp_fds_write_common_cb);
1797   1      #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
1800   1        return OTP_BASE_SUCESS;
1801   1      }
*** WARNING C280 IN LINE 1764 OF mmi_src\dq_sdk_main.c: 'p_data': unreferenced local variable
1802          
1803          static OTP_BASE_RET dq_otp_syn_lock_pwd(uint8_t *p_data)
1804          {
1805   1        uint8_t i = 0, j = 0;
1806   1        uint8_t t = p_data[2];
1807   1        uint8_t num = 0;
1808   1        uint8_t _data[9];
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 31  

1809   1      #ifdef __LOCK_USE_MALLOC__
                uint8_t ret = 0;
                g_dq_app_pwd_info = (otp_base_app_pwd_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_PWD, &ret);
              #endif
1813   1        for (i = 0; i < DQ_OTP_APP_PWD_NUM; i++)
1814   1        {
1815   2          if (memcmp(g_dq_app_pwd_info[i].app_pwd, g_dq_app_pwd_info[i].replace_pwd, 5) != 0)
1816   2          {
1817   3            num++;
1818   3            if (num == t)
1819   3              break;
1820   3          }
1821   2        }
1822   1        if (i >= DQ_OTP_APP_PWD_NUM)
1823   1        {
1824   2          return OTP_BASE_FAIL;
1825   2        }
1826   1      
1827   1        for (j = 0; j < 5; j++)
1828   1        {
1829   2          _data[j] = g_dq_app_pwd_info[i].app_pwd[j];
1830   2        }
1831   1        for (j = 0; j < 4; j++)
1832   1        {
1833   2          _data[j + 5] = g_dq_app_pwd_info[i].replace_pwd[j];
1834   2        }
1835   1      #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
1838   1        dq_otp_send_data_reply(0x02, 0x14, OTP_BASE_SUCESS, (uint8_t *)_data, 9);
1839   1        return OTP_BASE_SUCESS;
1840   1      }
1841          
1842          static OTP_BASE_RET dq_otp_syn_lock_temp_pwd(uint8_t *p_data)
1843          {
1844   1        uint8_t i = 0, j = 0;
1845   1        uint8_t t = p_data[2];
1846   1        uint8_t num = 0;
1847   1        uint8_t _data[10];
1848   1      #ifdef __LOCK_USE_MALLOC__
                uint8_t ret = 0;
                g_dq_app_pwd_info = (otp_base_app_pwd_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_PWD, &ret);
              #endif
1852   1        memset(_data, 0xFF, 10);
1853   1        for (i = 0; i < DQ_OTP_APP_PWD_NUM; i++)
1854   1        {
1855   2          if (g_dq_app_pwd_info[i].pwd_type != 0xFF)
1856   2          {
1857   3            if (memcmp(g_dq_app_pwd_info[i].app_pwd, g_dq_app_pwd_info[i].replace_pwd, 5) == 0)
1858   3            {
1859   4              num++;
1860   4              if (num == (t * 2 - 1))
1861   4              {
1862   5                for (j = 0; j < 5; j++)
1863   5                {
1864   6                  _data[j] = g_dq_app_pwd_info[i].app_pwd[j];
1865   6                }
1866   5                break;
1867   5              }
1868   4            }
1869   3          }
1870   2        }
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 32  

1871   1        if (i >= DQ_OTP_APP_PWD_NUM)
1872   1        {
1873   2      #ifdef __LOCK_USE_MALLOC__
                  mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
1876   2          return OTP_BASE_FAIL;
1877   2        }
1878   1      
1879   1        for (i = i + 1; i < DQ_OTP_APP_PWD_NUM; i++)
1880   1        {
1881   2          if (memcmp(g_dq_app_pwd_info[i].app_pwd, g_dq_app_pwd_info[i].replace_pwd, 5) == 0)
1882   2          {
1883   3            for (j = 0; j < 5; j++)
1884   3            {
1885   4              _data[j + 5] = g_dq_app_pwd_info[i].app_pwd[j];
1886   4            }
1887   3            break;
1888   3          }
1889   2        }
1890   1      #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
1893   1        dq_otp_send_data_reply(0x02, 0x15, OTP_BASE_SUCESS, (uint8_t *)_data, 10);
1894   1        return OTP_BASE_SUCESS;
1895   1      }
1896          
1897          /*
1898          parameter: 
1899            none
1900          return :
1901            none
1902          */
1903          //static uint8_t dq_otp_get_empty_fp_index(void)
1904          //{
1905          //  uint8_t i = 0;
1906          //  for(i=0;i<DQ_OTP_APP_FP_NUM;i++)
1907          //  {
1908          //    if(g_dq_app_fp_info[i].fp_index == 0xFFFF)
1909          //      break;
1910          //  }
1911          //  return i;
1912          //}
1913          
1914          /*
1915          parameter: 
1916            none
1917          return :
1918            none
1919          */
1920          #if defined(__LOCK_FP_SUPPORT__) || defined(__LOCK_FP_SUPPORT2__) || defined(__LOCK_FP_SUPPORT1_2__)
              
              void dq_otp_app_add_lock_fp_result(uint8_t result_flag, uint16_t fp_index)
              {
                uint8_t fp_index_char[2];
                uint8_t ret = 0;
              
                memset(fp_index_char, 0xFF, sizeof(fp_index_char));
                if (result_flag == 0)
                {
                  fp_index_char[0] = (fp_index >> 8) & 0xFF;
                  fp_index_char[1] = fp_index & 0xFF;
                }
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 33  

              
                if (result_flag == 0)
                  g_dq_cmd_repleys_status = OTP_BASE_SUCESS;
                else if (result_flag == 1)
                  g_dq_cmd_repleys_status = OTP_BASE_TIMEOUT;
                else if (result_flag == 2)
                  g_dq_cmd_repleys_status = OTP_BASE_FULL;
                else if (result_flag == 3)
                  g_dq_cmd_repleys_status = OTP_BASE_HAND_EXIT;
                else if (result_flag == 5)
                  g_dq_cmd_repleys_status = OTP_BASE_TYPE_ERROR;
                else
                  g_dq_cmd_repleys_status = OTP_BASE_FAIL;
              
                if (result_flag == 0)
                {
                  //save fp info
                  g_dq_fp_index = fp_index;
              #ifdef __LOCK_USE_MALLOC__
                  g_dq_app_fp_info = (otp_base_app_fp_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_FP, &ret);
              #endif
                  g_dq_app_fp_info[fp_index].fp_start_time = g_dq_add_temp_start_time;
                  g_dq_app_fp_info[fp_index].fp_end_time = g_dq_add_temp_end_time;
                  g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_FP, (unsigned char *)g_dq_app_fp_info, sizeof(otp_base_app_fp_inf
             -o) * DQ_OTP_APP_FP_NUM, &ret, dq_otp_fds_write_common_cb);
              #ifdef __LOCK_USE_MALLOC__
                  mmi_dq_fs_free_storage(DQ_FS_MEM_APP_FP, (void **)&g_dq_app_fp_info);
              #endif
                }
                else
                {
                  unsigned char i;
                  g_dq_add_temp_start_time = 0;
                  g_dq_add_temp_end_time = 0;
                  for (i = 0; i < CMD_OTP_MAX_NUM; i++)
                  {
                    if (cmd_info[i].cmd == g_dq_otp_type)
                      break;
                  }
                  dq_otp_app_set_operate_lock_flag(0);
                  if (g_dq_link_error == 1)
                  {
                    g_dq_link_error = 0;
                  }
                  else
                    dq_otp_common_reply(cmd_info[i].cmd_h, cmd_info[i].cmd_l, g_dq_cmd_repleys_status);
                }
              }
              /*
              parameter: 
                none
              return :
                none
              */
              //0221 5C9A0030 5D134A30 00 60 FFFF FF 99
              static OTP_BASE_RET dq_otp_add_lock_fp(uint8_t *p_data)
              {
                uint8_t result = 0;
                uint8_t fp_time[4];
                uint8_t i = 0;
                uint16_t delay_time = 0;
              
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 34  

                //g_dq_fp_index = dq_otp_get_empty_fp_index();
              
                //if(g_dq_fp_index == DQ_OTP_APP_FP_NUM)
                //  return OTP_BASE_NO_MEM;
              
                memset(fp_time, 0x00, sizeof(fp_time));
                for (i = 0; i < 4; i++)
                {
                  fp_time[i] = p_data[i + 2];
                }
                g_dq_add_temp_start_time = dq_sdk_HexcharToInt(fp_time, 4);
              
                memset(fp_time, 0x00, sizeof(fp_time));
                for (i = 0; i < 4; i++)
                {
                  fp_time[i] = p_data[i + 6];
                }
                g_dq_add_temp_end_time = dq_sdk_HexcharToInt(fp_time, 4);
              
                memset(fp_time, 0x00, sizeof(fp_time));
                for (i = 0; i < 2; i++)
                {
                  fp_time[i] = p_data[i + 10];
                }
                delay_time = dq_sdk_HexcharToInt(fp_time, 2);
              
                g_dq_otp_init.set_lock_fp(delay_time, &result);
                return OTP_BASE_SUCESS;
              }
              
              void dq_otp_lock_fp_app_clr_result(void)
              {
                uint8_t ret = 0;
                uint8_t i;
              #ifdef __LOCK_USE_MALLOC__
                g_dq_app_fp_info = (otp_base_app_fp_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_FP, &ret);
              #endif
                for (i = 0; i < DQ_OTP_APP_FP_NUM; i++)
                {
                  g_dq_app_fp_info[i].fp_end_time = 0xFFFFFFFF;
                  g_dq_app_fp_info[i].fp_start_time = 0xFFFFFFFF;
                }
              
                g_dq_cmd_repleys_status = OTP_BASE_SUCESS;
                g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_FP, (unsigned char *)g_dq_app_fp_info, sizeof(otp_base_app_fp_info
             -) * DQ_OTP_APP_FP_NUM, &ret, dq_otp_fds_write_common_cb);
              #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_APP_FP, (void **)&g_dq_app_fp_info);
              #endif
              }
              
              extern uint16_t lock_del_fp_index;
              void dq_otp_lock_fp_app_del_result(void)
              {
                uint8_t ret = 0;
              #ifdef __LOCK_USE_MALLOC__
                g_dq_app_fp_info = (otp_base_app_fp_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_FP, &ret);
              #endif
                g_dq_app_fp_info[lock_del_fp_index].fp_end_time = 0xFFFFFFFF;
                g_dq_app_fp_info[lock_del_fp_index].fp_start_time = 0xFFFFFFFF;
              
                g_dq_cmd_repleys_status = OTP_BASE_SUCESS;
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 35  

                g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_FP, (unsigned char *)g_dq_app_fp_info, sizeof(otp_base_app_fp_info
             -) * DQ_OTP_APP_FP_NUM, &ret, dq_otp_fds_write_common_cb);
              #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_APP_FP, (void **)&g_dq_app_fp_info);
              #endif
              }
              
              void dq_otp_lock_fp_app_fail_result(void)
              {
              
                g_dq_cmd_repleys_status = OTP_BASE_FAIL;
                dq_otp_fds_write_common_cb();
              }
              
              /*
              parameter: 
                none
              return :
                none
              */
              //0222 8866 FFFF FFFF FFFF FFFF FFFF 8899
              static OTP_BASE_RET dq_otp_del_lock_fp(uint8_t *p_data)
              {
                uint8_t i = 0;
                uint8_t fp_index[2];
                uint16_t index = 0;
                uint8_t ret = 0;
              
                memset(fp_index, 0x00, sizeof(fp_index));
                for (i = 0; i < 2; i++)
                {
                  fp_index[i] = p_data[i + 2];
                }
              
                index = dq_sdk_HexcharToInt(fp_index, 2);
              
                //for(i=0;i<DQ_OTP_APP_FP_NUM;i++)
                //{
                //  if(g_dq_app_fp_info[i].fp_index == index)
                //    break;
                //}
                //if(i == DQ_OTP_APP_FP_NUM)
                //  return OTP_BASE_NOT_FOUND;
                //else
                if (dq_otp_check_lock_fp(index) == 0)
                {
                  g_dq_otp_init.del_lock_fp(index, &ret); //delete fp in lock
              
                  //save fp info
              
                  return (OTP_BASE_RET)ret;
                }
                else
                  return OTP_BASE_NOT_FOUND;
              }
              /*
              parameter: 
                none
              return :
                none
              */
              //0213 5C90 628C FFFF FFFF FFFF FFFF FF 99
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 36  

              static OTP_BASE_RET dq_otp_clr_lock_fp(uint8_t *p_data)
              {
                uint8_t ret = 0;
              
                g_dq_otp_init.clear_lock_fp(&ret);
              
                //save fp info
              
                return OTP_BASE_SUCESS;
              }
              
              static OTP_BASE_RET dq_otp_syn_lock_fp(uint8_t *p_data)
              {
                uint8_t i = 0, j = 0;
                uint8_t t = p_data[2];
                uint8_t num = 0;
                uint8_t _data[10];
              
                memset(_data, 0xFF, 10);
                for (i = 0; i < DQ_OTP_APP_FP_NUM; i++)
                {
                  if (dq_otp_check_lock_fp(i) == 0)
                  {
                    num++;
                    if ((num > (t - 1) * 5) && (num <= t * 5))
                    {
                      _data[j * 2] = 0;  //((g_dq_app_fp_info[i].fp_index>>8)&0xFF);
                      _data[j * 2 + 1] = i; //(g_dq_app_fp_info[i].fp_index&0xFF);
                      j++;
                      if (j >= 5)
                        break;
                    }
                  }
                }
                if (j == 0)
                {
                  return OTP_BASE_FAIL;
                }
              
                dq_otp_send_data_reply(0x02, 0x24, OTP_BASE_SUCESS, (uint8_t *)_data, 10);
                return OTP_BASE_SUCESS;
              }
              
              #endif
2160          /*
2161          parameter: 
2162            none
2163          return :
2164            none
2165          */
2166          //static uint8_t dq_otp_get_empty_rfid_index(void)
2167          //{
2168          //  uint8_t i = 0;
2169          //  for(i=0;i<DQ_OTP_APP_RFID_NUM;i++)
2170          //  {
2171          //    if(g_dq_app_rfid_info[i].rfid_index == 0xFFFF)
2172          //      break;
2173          //  }
2174          //  return i;
2175          //}
2176          /*
2177          parameter: 
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 37  

2178            none
2179          return :
2180            none
2181          */
2182          #ifdef __LOCK_RFID_CARD_SUPPORT__
2183          
2184          void dq_otp_app_add_lock_rfid_result(uint8_t result_flag, uint16_t rfid_index)
2185          {
2186   1        uint8_t rfid_index_char[2];
2187   1        uint8_t ret = 0;
2188   1      
2189   1        memset(rfid_index_char, 0xFF, sizeof(rfid_index_char));
2190   1        if (result_flag == 0)
2191   1        {
2192   2          rfid_index_char[0] = (rfid_index >> 8) & 0xFF;
2193   2          rfid_index_char[1] = rfid_index & 0xFF;
2194   2        }
2195   1      
2196   1        if (result_flag == 0)
2197   1          g_dq_cmd_repleys_status = OTP_BASE_SUCESS;
2198   1        else if (result_flag == 1)
2199   1          g_dq_cmd_repleys_status = OTP_BASE_TIMEOUT;
2200   1        else if (result_flag == 2)
2201   1          g_dq_cmd_repleys_status = OTP_BASE_FULL;
2202   1        else if (result_flag == 3)
2203   1          g_dq_cmd_repleys_status = OTP_BASE_HAND_EXIT;
2204   1        else if (result_flag == 5)
2205   1          g_dq_cmd_repleys_status = OTP_BASE_TYPE_ERROR;
2206   1        else
2207   1          g_dq_cmd_repleys_status = OTP_BASE_FAIL;
2208   1      
2209   1        if (result_flag == 0)
2210   1        {
2211   2          //save fp info
2212   2          g_dq_rfid_index = rfid_index;
2213   2      #ifdef __LOCK_USE_MALLOC__
                  g_dq_app_rfid_info = (otp_base_app_rfid_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_RFID, &ret);
              #endif
2216   2          g_dq_app_rfid_info[rfid_index].rfid_start_time = g_dq_add_temp_start_time;
2217   2          g_dq_app_rfid_info[rfid_index].rfid_end_time = g_dq_add_temp_end_time;
2218   2      //    g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_RFID, (unsigned char *)g_dq_app_rfid_info, sizeof(otp_base_app_
             -rfid_info) * DQ_OTP_APP_RFID_NUM, &ret, dq_otp_fds_write_common_cb);
2219   2      #ifdef __LOCK_USE_MALLOC__
                  mmi_dq_fs_free_storage(DQ_FS_MEM_APP_RFID, (void **)&g_dq_app_rfid_info);
              #endif
2222   2        }
2223   1        else
2224   1        {
2225   2          unsigned char i;
2226   2          g_dq_add_temp_start_time = 0;
2227   2          g_dq_add_temp_end_time = 0;
2228   2      
2229   2          for (i = 0; i < CMD_OTP_MAX_NUM; i++)
2230   2          {
2231   3            if (cmd_info[i].cmd == g_dq_otp_type)
2232   3              break;
2233   3          }
2234   2          dq_otp_app_set_operate_lock_flag(0);
2235   2      
2236   2          if (g_dq_link_error == 1)
2237   2          {
2238   3            g_dq_link_error = 0;
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 38  

2239   3          }
2240   2          else
2241   2            dq_otp_common_reply(cmd_info[i].cmd_h, cmd_info[i].cmd_l, g_dq_cmd_repleys_status);
2242   2        }
2243   1      }
2244          
2245          /*
2246          parameter: 
2247            none
2248          return :
2249            none
2250          */
2251          //0231 5C9A0030 5D134A30 00 60 FFFF FF 99
2252          static OTP_BASE_RET dq_otp_add_lock_rfid(uint8_t *p_data)
2253          {
2254   1        uint8_t result = 0;
2255   1        uint8_t rfid_time[4];
2256   1        uint8_t i = 0;
2257   1        uint16_t delay_time = 0;
2258   1      
2259   1        //g_dq_rfid_index = dq_otp_get_empty_rfid_index();
2260   1      
2261   1        //if(g_dq_rfid_index == DQ_OTP_APP_RFID_NUM)
2262   1        //  return OTP_BASE_NO_MEM;
2263   1      
2264   1        memset(rfid_time, 0x00, sizeof(rfid_time));
2265   1        for (i = 0; i < 4; i++)
2266   1        {
2267   2          rfid_time[i] = p_data[i + 2];
2268   2        }
2269   1        g_dq_add_temp_start_time = dq_sdk_HexcharToInt(rfid_time, 4);
2270   1      
2271   1        memset(rfid_time, 0x00, sizeof(rfid_time));
2272   1        for (i = 0; i < 4; i++)
2273   1        {
2274   2          rfid_time[i] = p_data[i + 6];
2275   2        }
2276   1        g_dq_add_temp_end_time = dq_sdk_HexcharToInt(rfid_time, 4);
2277   1      
2278   1        memset(rfid_time, 0x00, sizeof(rfid_time));
2279   1        for (i = 0; i < 2; i++)
2280   1        {
2281   2          rfid_time[i] = p_data[i + 10];
2282   2        }
2283   1        delay_time = dq_sdk_HexcharToInt(rfid_time, 2);
2284   1      
2285   1        g_dq_otp_init.set_lock_rfid(delay_time, &result);
2286   1      
2287   1        return OTP_BASE_SUCESS;
2288   1      }
2289          
2290          void dq_otp_lock_rfid_app_clr_result(void)
2291          {
2292   1        uint8_t ret = 0;
2293   1        uint8_t i = 0;
2294   1      
2295   1      #ifdef __LOCK_USE_MALLOC__
                g_dq_app_rfid_info = (otp_base_app_rfid_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_RFID, &ret);
              #endif
2298   1        for (i = 0; i < DQ_OTP_APP_RFID_NUM; i++)
2299   1        {
2300   2          g_dq_app_rfid_info[i].rfid_end_time = 0xFFFFFFFF;
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 39  

2301   2          g_dq_app_rfid_info[i].rfid_start_time = 0xFFFFFFFF;
2302   2          //g_dq_app_rfid_info[i].rfid_index = 0xFFFF;
2303   2        }
2304   1      
2305   1        g_dq_cmd_repleys_status = OTP_BASE_SUCESS;
2306   1      //  g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_RFID, (unsigned char *)g_dq_app_rfid_info, sizeof(otp_base_app_r
             -fid_info) * DQ_OTP_APP_RFID_NUM, &ret, dq_otp_fds_write_common_cb);
2307   1      #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_APP_RFID, (void **)&g_dq_app_rfid_info);
              #endif
2310   1      }
2311          
2312          extern uint16_t lock_del_rf_index;
2313          void dq_otp_lock_rfid_app_del_result(void)
2314          {
2315   1        uint8_t ret = 0;
2316   1      
2317   1      #ifdef __LOCK_USE_MALLOC__
                g_dq_app_rfid_info = (otp_base_app_rfid_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_RFID, &ret);
              #endif
2320   1        g_dq_app_rfid_info[lock_del_rf_index].rfid_end_time = 0xFFFFFFFF;
2321   1        g_dq_app_rfid_info[lock_del_rf_index].rfid_start_time = 0xFFFFFFFF;
2322   1        //g_dq_app_rfid_info[i].rfid_index = 0xFFFF;
2323   1      
2324   1        g_dq_cmd_repleys_status = OTP_BASE_SUCESS;
2325   1      //  g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_RFID, (unsigned char *)g_dq_app_rfid_info, sizeof(otp_base_app_r
             -fid_info) * DQ_OTP_APP_RFID_NUM, &ret, dq_otp_fds_write_common_cb);
2326   1      #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_APP_RFID, (void **)&g_dq_app_rfid_info);
              #endif
2329   1      }
2330          
2331          /*
2332          parameter: 
2333            none
2334          return :
2335            none
2336          */
2337          //0232 8866 FFFF FFFF FFFF FFFF FFFF 8899
2338          static OTP_BASE_RET dq_otp_del_lock_rfid(uint8_t *p_data)
2339          {
2340   1        uint8_t i = 0;
2341   1        uint8_t rfid_index[2];
2342   1        uint16_t index = 0;
2343   1        uint8_t ret = 0;
2344   1      
2345   1        memset(rfid_index, 0x00, sizeof(rfid_index));
2346   1        for (i = 0; i < 2; i++)
2347   1        {
2348   2          rfid_index[i] = p_data[i + 2];
2349   2        }
2350   1      
2351   1        index = dq_sdk_HexcharToInt(rfid_index, 2);
2352   1      
2353   1        //for(i=0;i<DQ_OTP_APP_RFID_NUM;i++)
2354   1        //{
2355   1        //  if(g_dq_app_rfid_info[i].rfid_index == index)
2356   1        //    break;
2357   1        //}
2358   1        //if(i == DQ_OTP_APP_RFID_NUM)
2359   1        //  return OTP_BASE_NOT_FOUND;
2360   1        //else
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 40  

2361   1        if (dq_otp_check_lock_rfid(index) == 0)
2362   1        {
2363   2          g_dq_otp_init.del_lock_rf(index, &ret);
2364   2      
2365   2          //save rfid info
2366   2          return OTP_BASE_SUCESS;
2367   2        }
2368   1        else
2369   1          return OTP_BASE_NOT_FOUND;
2370   1      }
2371          
2372          /*
2373          parameter: 
2374            none
2375          return :
2376            none
2377          */
2378          //0233 FFFF FFFF FFFF FFFF FFFF FFFF FF 99
2379          static OTP_BASE_RET dq_otp_clr_lock_rfid(uint8_t *p_data)
2380          {
2381   1        uint8_t ret = 0;
2382   1      
2383   1        //save rfid info
2384   1        g_dq_otp_init.clear_lock_rf(&ret);
2385   1      
2386   1        return OTP_BASE_SUCESS;
2387   1      }
*** WARNING C280 IN LINE 2379 OF mmi_src\dq_sdk_main.c: 'p_data': unreferenced local variable
2388          
2389          static OTP_BASE_RET dq_otp_syn_lock_rfid(uint8_t *p_data)
2390          {
2391   1        uint8_t i = 0, j = 0;
2392   1        uint8_t t = p_data[2];
2393   1        uint8_t num = 0;
2394   1        uint8_t _data[10];
2395   1      
2396   1        memset(_data, 0xFF, 10);
2397   1        for (i = 0; i < DQ_OTP_APP_RFID_NUM; i++)
2398   1        {
2399   2          if (dq_otp_check_lock_rfid(i) == 0)
2400   2          {
2401   3            num++;
2402   3            if ((num > (t - 1) * 5) && (num <= t * 5))
2403   3            {
2404   4              _data[j * 2] = 0;  //((g_dq_app_rfid_info[i].rfid_index>>8)&0xFF);
2405   4              _data[j * 2 + 1] = i; // (g_dq_app_rfid_info[i].rfid_index&0xFF);
2406   4              j++;
2407   4              if (j >= 5)
2408   4                break;
2409   4            }
2410   3          }
2411   2        }
2412   1        if (j == 0)
2413   1        {
2414   2          return OTP_BASE_FAIL;
2415   2        }
2416   1      
2417   1        dq_otp_send_data_reply(0x02, 0x34, OTP_BASE_SUCESS, (uint8_t *)_data, 10);
2418   1        return OTP_BASE_SUCESS;
2419   1      }
2420          
2421          static OTP_BASE_RET dq_otp_add_lock_rfid_by_app(uint8_t *p_data)
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 41  

2422          {
2423   1        uint8_t rfid_time[4];
2424   1        uint8_t i = 0;
2425   1        //uint16_t delay_time = 0;
2426   1        static uint8_t data_len = 0;
2427   1        static uint8_t _data[20] = {0};
2428   1        static uint8_t data_flag = 0;
2429   1        if (p_data[2] == 0)
2430   1        {
2431   2          memset(rfid_time, 0x00, sizeof(rfid_time));
2432   2          for (i = 0; i < 4; i++)
2433   2          {
2434   3            rfid_time[i] = p_data[i + 3];
2435   3          }
2436   2          g_dq_add_temp_start_time = dq_sdk_HexcharToInt(rfid_time, 4);
2437   2      
2438   2          memset(rfid_time, 0x00, sizeof(rfid_time));
2439   2          for (i = 0; i < 4; i++)
2440   2          {
2441   3            rfid_time[i] = p_data[i + 7];
2442   3          }
2443   2          g_dq_add_temp_end_time = dq_sdk_HexcharToInt(rfid_time, 4);
2444   2          data_len = p_data[11];
2445   2          memset(rfid_time, 0x00, sizeof(rfid_time));
2446   2          for (i = 0; i < 2; i++)
2447   2          {
2448   3            rfid_time[i] = p_data[i + 12];
2449   3          }
2450   2          //  delay_time = dq_sdk_HexcharToInt(rfid_time, 2);
2451   2          memset(_data, 0, 20);
2452   2          data_flag = 0;
2453   2      
2454   2          if (data_len > 20)
2455   2          {
2456   3            data_len = 0;
2457   3            dq_otp_common_reply(p_data[0], p_data[1], OTP_BASE_FAIL);
2458   3          }
2459   2          else
2460   2            dq_otp_common_reply(p_data[0], p_data[1], OTP_BASE_SUCESS);
2461   2        }
2462   1        else if (p_data[2] == data_flag + 1)
2463   1        {
2464   2          if (data_len > 12)
2465   2          {
2466   3            for (i = 0; i < 12; i++)
2467   3            {
2468   4              _data[data_flag * 12 + i] = p_data[i + 3];
2469   4            }
2470   3            data_len -= 12;
2471   3            data_flag++;
2472   3            dq_otp_common_reply(p_data[0], p_data[1], OTP_BASE_SUCESS);
2473   3          }
2474   2          else if (data_len > 0)
2475   2          {
2476   3            for (i = 0; i < data_len; i++)
2477   3            {
2478   4              _data[data_flag * 12 + i] = p_data[i + 3];
2479   4            }
2480   3            data_len = 0;
2481   3            data_flag = 0;
2482   3      
2483   3            g_dq_otp_init.add_lock_rfid_by_app(_data);
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 42  

2484   3          }
2485   2          else
2486   2            dq_otp_common_reply(p_data[0], p_data[1], OTP_BASE_FAIL);
2487   2        }
2488   1        else
2489   1          dq_otp_common_reply(p_data[0], p_data[1], OTP_BASE_FAIL);
2490   1      
2491   1        return OTP_BASE_SUCESS;
2492   1      }
2493          
2494          #endif
2495          /*
2496          parameter: 
2497            none
2498          return :
2499            none
2500          */
2501          //0401 FFFF FFFF FFFF FFFF FFFF FFFF FF 99
2502          static OTP_BASE_RET dq_otp_get_lock_config_info(uint8_t *pwd_num, uint8_t *fp_num, uint8_t *rf_num, uint16
             -_t *lock_config)
2503          {
2504   1      //  g_dq_otp_init.get_lock_mem_info(pwd_num, fp_num, rf_num, lock_config);
2505   1        *pwd_num = DQ_OTP_APP_PWD_NUM;
2506   1        *fp_num = DQ_OTP_APP_FP_NUM;
2507   1        *rf_num = DQ_OTP_APP_RFID_NUM;
2508   1      
2509   1        return OTP_BASE_SUCESS;
2510   1      }
*** WARNING C280 IN LINE 2502 OF mmi_src\dq_sdk_main.c: 'lock_config': unreferenced local variable
2511          
2512          /*
2513          parameter: 
2514            none
2515          return :
2516            none
2517          */
2518          void dq_otp_check_and_update_time_cb(void)
2519          {
2520   1        uint8_t ret_val = 0;
2521   1        uint8_t bat = 0;
2522   1        uint16_t sw = 0;
2523   1      
2524   1        uint8_t reply_data[3];
2525   1        dq_otp_app_return_idle();
2526   1      
2527   1      //  g_dq_otp_init.get_lock_bat_level(&bat, &ret_val);
2528   1      
2529   1      //  g_dq_otp_init.get_lock_ver_info(&sw, &ret_val);
2530   1      
2531   1        memset(reply_data, 0xFF, sizeof(reply_data));
2532   1      
2533   1        reply_data[0] = bat;
2534   1        reply_data[1] = (sw >> 8) & 0xFF;
2535   1        reply_data[2] = sw & 0xFF;
2536   1        dq_otp_send_data_reply(0x04, 0x02, OTP_BASE_SUCESS, reply_data, 3);
2537   1      }
2538          
2539          //0402 5D13 4A30 FFFF FFFF FFFF FFFF FF 99
2540          //0402 00 58 1001 FFFF FFFF FFFF FFFF FFFF FF 99
2541          static OTP_BASE_RET dq_otp_get_lock_base_info(uint8_t *p_data, uint8_t *bat_val, uint16_t *sw_ver)
2542          {
2543   1        uint8_t i = 0;
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 43  

2544   1        uint8_t sys_time[4];
2545   1        uint32_t sys_time_int = 0;
2546   1        uint32_t time = 0;
2547   1        uint8_t ret_val = 0;
2548   1        uint8_t bat = 0;
2549   1        uint16_t sw = 0;
2550   1        uint16_t west_d = 0;
2551   1        uint16_t east_d = 0;
2552   1        uint8_t time_zone_update_flag = 0;
2553   1      
2554   1        memset(sys_time, 0xFF, sizeof(sys_time));
2555   1      
2556   1        for (i = 0; i < 4; i++)
2557   1        {
2558   2          sys_time[i] = p_data[i + 2];
2559   2        }
2560   1      
2561   1        west_d = (p_data[7] << 8) + p_data[8];
2562   1        east_d = (p_data[9] << 8) + p_data[10];
2563   1      
2564   1        g_dq_otp_init.set_system_time_zone(west_d, east_d, &time_zone_update_flag);
2565   1      
2566   1        sys_time_int = dq_sdk_HexcharToInt(sys_time, 4);
2567   1        time = sys_time_int - dq_otp_get_sys_time_sec();
2568   1      
2569   1        g_dq_otp_init.set_system_time(sys_time_int, &ret_val);
2570   1      
2571   1        if (DQ_OTP_SYS_TIME_GET == 0)
2572   1        {
2573   2          DQ_OTP_SYS_TIME_GET = 1;
2574   2      
2575   2          if (dq_otp_check_and_update_log_time(time) != 1)
2576   2          {
2577   3            dq_otp_update_time();
2578   3          }
2579   2          return OTP_BASE_BUSY;
2580   2        }
2581   1        else if (time_zone_update_flag == 1)
2582   1        {
2583   2      
2584   2          dq_otp_update_time();
2585   2          return OTP_BASE_BUSY;
2586   2        }
2587   1      
2588   1      //  g_dq_otp_init.get_lock_bat_level(&bat, &ret_val);
2589   1      
2590   1      //  g_dq_otp_init.get_lock_ver_info(&sw, &ret_val);
2591   1      
2592   1        *bat_val = bat;
2593   1        *sw_ver = sw;
2594   1        return OTP_BASE_SUCESS;
2595   1      }
2596          
2597          unsigned char dq_otp_get_lock_sys_time_state(void)
2598          {
2599   1        return DQ_OTP_SYS_TIME_GET;
2600   1      }
2601          
2602          /*
2603          parameter: 
2604            none
2605          return :
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 44  

2606            none
2607          */
2608          //0403 FFFF FFFF FFFF FFFF FFFF FFFF FF 99
2609          static uint8_t dq_otp_get_lock_admin_status(uint8_t *p_data)
2610          {
2611   1        uint8_t status;
2612   1        uint8_t retval;
2613   1      //  g_dq_otp_init.get_admin_status(&status, &retval);
2614   1        return status;
2615   1      }
*** WARNING C280 IN LINE 2609 OF mmi_src\dq_sdk_main.c: 'p_data': unreferenced local variable
*** WARNING C280 IN LINE 2612 OF mmi_src\dq_sdk_main.c: 'retval': unreferenced local variable
2616          
2617          /*
2618          parameter: 
2619            none
2620          return :
2621            none
2622          */
2623          //0404 0060 FFFF FFFF FFFF FFFF FFFF 8899
2624          static uint8_t dq_otp_check_lock_admin_pwd_fp(uint8_t *p_data)
2625          {
2626   1        uint8_t i = 0;
2627   1        uint8_t time[2];
2628   1        uint16_t delay_time = 0;
2629   1        uint8_t retval = 0;
2630   1      
2631   1        memset(time, 0xFF, sizeof(time));
2632   1        for (i = 0; i < 2; i++)
2633   1        {
2634   2          time[i] = p_data[i + 2];
2635   2        }
2636   1        delay_time = dq_sdk_HexcharToInt(time, 2);
2637   1      
2638   1        g_dq_otp_init.verify_admin_status(delay_time, &retval);
2639   1        if (retval == 1)
2640   1          dq_otp_common_reply(0x04, 0x04, OTP_BASE_FAIL);
2641   1        return 0;
2642   1      }
2643          /*
2644          parameter: 
2645            none
2646          return :
2647            none
2648          */
2649          void dq_otp_check_lock_admin_pwd_fp_ret(uint8_t result)
2650          {
2651   1        if (result == 0)
2652   1          dq_otp_common_reply(0x04, 0x04, OTP_BASE_SUCESS);
2653   1        else if (result == 1)
2654   1          dq_otp_common_reply(0x04, 0x04, OTP_BASE_TIMEOUT);
2655   1        else if (result == 2)
2656   1          dq_otp_common_reply(0x04, 0x04, OTP_BASE_HAND_EXIT);
2657   1        else
2658   1          dq_otp_common_reply(0x04, 0x04, OTP_BASE_FAIL);
2659   1        return;
2660   1      }
2661          
2662          void dq_otp_sys_get_time(void)
2663          {
2664   1        time_t time = dq_otp_get_sys_time_sec();
2665   1        uint8_t _data[4] = {0};
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 45  

2666   1        _data[0] = (time >> 24) & 0xFF;
2667   1        _data[1] = (time >> 16) & 0xFF;
2668   1        _data[2] = (time >> 8) & 0xFF;
2669   1        _data[3] = time & 0xFF;
2670   1        dq_otp_send_data_reply(0x04, 0x07, OTP_BASE_SUCESS, _data, 4);
2671   1      }
2672          
2673          void dq_otp_sys_enter_dfu(void)
2674          {
2675   1        g_dq_dfu_permit = 1;
2676   1      }
2677          
2678          uint8_t dq_otp_get_dfu_permit(void)
2679          {
2680   1        return g_dq_dfu_permit;
2681   1      }
2682          
2683          void dq_otp_set_dfu_permit(uint8_t permit)
2684          {
2685   1        g_dq_dfu_permit = permit;
2686   1      }
2687          
2688          /*
2689          parameter: 
2690            none
2691          return :
2692            none
2693          */
2694          void dq_otp_cmd_dataOperation(uint8_t *p_data, uint16_t data_len)
2695          {
2696   1        OTP_BASE_RET retval = OTP_BASE_SUCESS;
2697   1      
2698   1        uint8_t data_ret[20];
2699   1        uint8_t data_back[20];
2700   1        uint8_t i = 0;
2701   1        uint8_t ret = 0;
2702   1      
2703   1        memset(data_ret, 0x00, sizeof(data_ret));
2704   1        memset(data_back, 0x00, sizeof(data_back));
2705   1        for (i = 0; i < data_len; i++)
2706   1        {
2707   2          data_ret[i] = *p_data++;
2708   2        }
2709   1      
2710   1        ret = g_dq_otp_init.check_lock_state();
2711   1        if (ret == 1)
2712   1        {
2713   2          dq_otp_common_reply(data_ret[0], data_ret[1], OTP_BASE_MUL_ERROR);
2714   2          return;
2715   2        }
2716   1        else if (ret == 2)
2717   1        {
2718   2          dq_otp_common_reply(data_ret[0], data_ret[1], OTP_BASE_LOW_VBAT);
2719   2          return;
2720   2        }
2721   1      
2722   1        g_dq_otp_type = dq_otp_get_cmd_type(data_ret);
2723   1      
2724   1      #ifndef __WIN32_ENV_SUPPORT__
2725   1        for (i = 0; i < data_len; i++)
2726   1        {
2727   2      //    NRF_LOG_PRINTF_DEBUG("dq_otp_cmd_dataOperation data_ret[%d] = 0x%x \n", i, data_ret[i]);
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 46  

2728   2        }
2729   1      //  NRF_LOG_PRINTF_DEBUG("dq_otp_get_cmd_type otp_type = 0x%x \n", g_dq_otp_type);
2730   1      #endif
2731   1      
2732   1        if (g_dq_otp_type == CMD_OTP_GET_LOCK_BASE_INFO || g_dq_otp_type == CMD_OTP_SYN_AES_16)
2733   1        {
2734   2          uint8_t _data;
2735   2          dq_otp_lock_random_vector_generate(&_data, 1);
2736   2          serialId = _data % 50;
2737   2      //    NRF_LOG_PRINTF_DEBUG("dq_otp_cmd_dataOperation CMD_OTP_GET_LOCK_BASE_INFO serialID= 0x%x  0x%x \n", se
             -rialId, _data);
2738   2        }
2739   1        else if (data_ret[15] != serialId)
2740   1        {
2741   2      
2742   2      //    NRF_LOG_PRINTF_DEBUG("dq_otp_cmd_dataOperation error serialID= 0x%x data_ret 0x%x \n", serialId, data_
             -ret[15]);
2743   2          dq_otp_common_reply(data_ret[0], data_ret[1], OTP_BASE_FAIL);
2744   2          return;
2745   2        }
2746   1      
2747   1        switch (g_dq_otp_type)
2748   1        {
2749   2        case CMD_OTP_SYN_AES_16:
2750   2          retval = dq_otp_syn_aes_16_key(data_ret);
2751   2      #ifndef __WIN32_ENV_SUPPORT__
2752   2      //    NRF_LOG_PRINTF_DEBUG("dq_otp_syn_aes_16_key retval = %d \n", retval);
2753   2      #endif
2754   2          if (retval == OTP_BASE_SUCESS)
2755   2          {
2756   3            if (dq_dev_key_flag == 0)
2757   3              dq_otp_device_key_unknow(data_ret[0], data_ret[1], retval);
2758   3            else
2759   3              dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2760   3          }
2761   2          break;
2762   2        case CMD_OTP_SYN_SEC_8:
2763   2          retval = dq_otp_syn_sec_8_key(data_ret);
2764   2          if (retval == OTP_BASE_SUCESS)
2765   2          {
2766   3            dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2767   3          }
2768   2          break;
2769   2        case CMD_OTP_SYN_SEC_9:
2770   2          retval = dq_otp_syn_sec_9_key(data_ret);
2771   2          if (retval == OTP_BASE_SUCESS)
2772   2          {
2773   3            dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2774   3          }
2775   2          break;
2776   2        case CMD_OTP_SYN_START_TIME:
2777   2          retval = dq_otp_syn_start_time(data_ret);
2778   2          if (retval == OTP_BASE_SUCESS)
2779   2          {
2780   3            dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2781   3          }
2782   2          break;
2783   2        case CMD_OTP_SYN_PWD_STR:
2784   2          retval = dq_otp_syn_exchange_num(data_ret);
2785   2          dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2786   2          break;
2787   2        case CMD_OTP_EKEY_OPEN_LOCK:
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 47  

2788   2          retval = dq_otp_check_ekey_verify(data_ret);
2789   2          if (retval == OTP_BASE_SUCESS)
2790   2          {
2791   3            g_dq_otp_init.open_lock();
2792   3            dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2793   3          }
2794   2          else
2795   2            dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2796   2          break;
2797   2        case CMD_OTP_USER_DEF_PWD:
2798   2          retval = dq_otp_add_user_def_pwd(data_ret);
2799   2          if (retval != OTP_BASE_SUCESS)
2800   2          {
2801   3            dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2802   3          }
2803   2          break;
2804   2        case CMD_OTP_DEL_PWD:
2805   2          retval = dq_otp_del_lock_pwd(data_ret);
2806   2          if (retval != OTP_BASE_SUCESS)
2807   2          {
2808   3            dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2809   3          }
2810   2          break;
2811   2        case CMD_OTP_CLR_PWD:
2812   2          retval = dq_otp_clr_lock_pwd(data_ret);
2813   2          break;
2814   2        case CMD_OTP_SYN_PWD:
2815   2          retval = dq_otp_syn_lock_pwd(data_ret);
2816   2          if (retval != OTP_BASE_SUCESS)
2817   2          {
2818   3            dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2819   3          }
2820   2          break;
2821   2        case CMD_OTP_SYN_TEMP_PWD:
2822   2          retval = dq_otp_syn_lock_temp_pwd(data_ret);
2823   2          if (retval != OTP_BASE_SUCESS)
2824   2          {
2825   3            dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2826   3          }
2827   2          break;
2828   2        case CMD_OTP_ADD_FP:
2829   2      #if defined(__LOCK_FP_SUPPORT__) || defined(__LOCK_FP_SUPPORT2__) || defined(__LOCK_FP_SUPPORT1_2__)
                  retval = dq_otp_add_lock_fp(data_ret);
              #else
2832   2          retval = OTP_BASE_FAIL;
2833   2      #endif
2834   2          if (retval != OTP_BASE_SUCESS)
2835   2          {
2836   3            dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2837   3          }
2838   2          break;
2839   2        case CMD_OTP_DEL_FP:
2840   2      #if defined(__LOCK_FP_SUPPORT__) || defined(__LOCK_FP_SUPPORT2__) || defined(__LOCK_FP_SUPPORT1_2__)
                  retval = dq_otp_del_lock_fp(data_ret);
              #else
2843   2          retval = OTP_BASE_FAIL;
2844   2      #endif
2845   2          if (retval != OTP_BASE_SUCESS)
2846   2          {
2847   3            dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2848   3          }
2849   2          break;
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 48  

2850   2        case CMD_OTP_CLR_FP:
2851   2      #if defined(__LOCK_FP_SUPPORT__) || defined(__LOCK_FP_SUPPORT2__) || defined(__LOCK_FP_SUPPORT1_2__)
                  retval = dq_otp_clr_lock_fp(data_ret);
              #else
2854   2          retval = OTP_BASE_FAIL;
2855   2      #endif
2856   2          if (retval != OTP_BASE_SUCESS)
2857   2          {
2858   3            dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2859   3          }
2860   2          break;
2861   2        case CMD_OTP_SYN_FP:
2862   2      #if defined(__LOCK_FP_SUPPORT__) || defined(__LOCK_FP_SUPPORT2__) || defined(__LOCK_FP_SUPPORT1_2__)
                  retval = dq_otp_syn_lock_fp(data_ret);
              #else
2865   2          retval = OTP_BASE_FAIL;
2866   2      #endif
2867   2          if (retval != OTP_BASE_SUCESS)
2868   2          {
2869   3            dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2870   3          }
2871   2          break;
2872   2        case CMD_OTP_ADD_RFID:
2873   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
2874   2          retval = dq_otp_add_lock_rfid(data_ret);
2875   2      #else
                  retval = OTP_BASE_FAIL;
              #endif
2878   2          if (retval != OTP_BASE_SUCESS)
2879   2          {
2880   3            dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2881   3          }
2882   2          break;
2883   2        case CMD_OTP_DEL_RFID:
2884   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
2885   2          retval = dq_otp_del_lock_rfid(data_ret);
2886   2      #else
                  retval = OTP_BASE_FAIL;
              #endif
2889   2          if (retval != OTP_BASE_SUCESS)
2890   2          {
2891   3            dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2892   3          }
2893   2          break;
2894   2        case CMD_OTP_CLR_RFID:
2895   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
2896   2          retval = dq_otp_clr_lock_rfid(data_ret);
2897   2      #else
                  retval = OTP_BASE_FAIL;
              #endif
2900   2          if (retval != OTP_BASE_SUCESS)
2901   2          {
2902   3            dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2903   3          }
2904   2          break;
2905   2        case CMD_OTP_SYN_RFID:
2906   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
2907   2          retval = dq_otp_syn_lock_rfid(data_ret);
2908   2      #else
                  retval = OTP_BASE_FAIL;
              #endif
2911   2          if (retval != OTP_BASE_SUCESS)
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 49  

2912   2          {
2913   3            dq_otp_common_reply(data_ret[0], data_ret[1], retval);
2914   3          }
2915   2          break;
2916   2        case CMD_OTP_ADD_RFID_BY_APP:
2917   2      #ifdef __LOCK_RFID_CARD_SUPPORT__
2918   2          retval = dq_otp_add_lock_rfid_by_app(data_ret);
2919   2      #else
                  dq_otp_common_reply(data_ret[0], data_ret[1], OTP_BASE_FAIL);
              #endif
2922   2          break;
2923   2      
2924   2        case CMD_OTP_UPDATE_LOG:
2925   2          dq_otp_send_log();
2926   2          break;
2927   2        case CMD_OTP_GET_LOCK_CONFIG:
2928   2        {
2929   3          uint8_t lock_mem_info[5];
2930   3          uint16_t lock_config;
2931   3          memset(lock_mem_info, 0xFF, sizeof(lock_mem_info));
2932   3      
2933   3          retval = dq_otp_get_lock_config_info(&lock_mem_info[2], &lock_mem_info[3], &lock_mem_info[4], &lock_conf
             -ig);
2934   3          lock_mem_info[0] = (lock_config >> 8) & 0xFF;
2935   3          lock_mem_info[1] = lock_config & 0xFF;
2936   3      
2937   3          if (retval == OTP_BASE_SUCESS)
2938   3          {
2939   4            dq_otp_send_data_reply(data_ret[0], data_ret[1], retval, lock_mem_info, 5);
2940   4          }
2941   3        }
2942   2        break;
2943   2        case CMD_OTP_GET_LOCK_BASE_INFO:
2944   2        {
2945   3          uint8_t reply_data[3];
2946   3          uint16_t sw_ver = 0;
2947   3          memset(reply_data, 0xFF, sizeof(reply_data));
2948   3          retval = dq_otp_get_lock_base_info(data_ret, &reply_data[0], &sw_ver);
2949   3          if (retval == OTP_BASE_SUCESS)
2950   3          {
2951   4            reply_data[1] = (sw_ver >> 8) & 0xFF;
2952   4            reply_data[2] = sw_ver & 0xFF;
2953   4            dq_otp_send_data_reply(data_ret[0], data_ret[1], retval, reply_data, 3);
2954   4          }
2955   3        }
2956   2        break;
2957   2        case CMD_OTP_CHK_ADMIN_STATUS:
2958   2        {
2959   3          uint8_t admin_status = 0;
2960   3          admin_status = dq_otp_get_lock_admin_status(data_ret);
2961   3          dq_otp_send_data_reply(data_ret[0], data_ret[1], OTP_BASE_SUCESS, &admin_status, 1);
2962   3        }
2963   2        break;
2964   2        case CMD_OTP_VERY_ADMIN_STA:
2965   2          dq_otp_check_lock_admin_pwd_fp(data_ret);
2966   2          break;
2967   2        case CMD_OTP_INIT_SUCESS:
2968   2          dq_otp_lock_init_complete(data_ret);
2969   2          break;
2970   2        case CMD_OTP_SYS_ENTER_DFU:
2971   2          dq_otp_sys_enter_dfu();
2972   2          dq_otp_common_reply(data_ret[0], data_ret[1], OTP_BASE_SUCESS);
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 50  

2973   2          break;
2974   2        case CMD_OTP_GET_SYS_TIME:
2975   2          dq_otp_sys_get_time();
2976   2          break;
2977   2        case CMD_OTP_INVALID:
2978   2          dq_otp_common_reply(data_ret[0], data_ret[1], OTP_BASE_FAIL);
2979   2          break;
2980   2        default:
2981   2          break;
2982   2        }
2983   1        return;
2984   1      }
2985          
2986          /*
2987          parameter: 
2988            current status machine
2989          return :
2990            none
2991          */
2992          void dq_otp_fds_write_common_cb(void)
2993          {
2994   1        uint8_t i = 0;
2995   1      
2996   1        for (i = 0; i < CMD_OTP_MAX_NUM; i++)
2997   1        {
2998   2          if (cmd_info[i].cmd == g_dq_otp_type)
2999   2            break;
3000   2        }
3001   1      #ifndef __WIN32_ENV_SUPPORT__
3002   1      //  NRF_LOG_PRINTF_DEBUG("dq_otp_fds_write_common_cb g_dq_cmd_repleys_status = 0x%x,cmd_info[%d].cmd_h  = 0
             -x%x,cmd_info[%d].cmd_l = 0x%x,g_dq_fp_index = %d\n", g_dq_cmd_repleys_status, i, cmd_info[i].cmd_h, i, cmd_info[i].cmd_l
             -, g_dq_fp_index);
3003   1      #endif
3004   1        if (g_dq_otp_type == CMD_OTP_INIT_SUCESS)
3005   1        {
3006   2          g_dq_otp_init.init_sucess(1);
3007   2          g_dq_otp_init.init_sucess_reset_lock(); //delete all data in lock pwd fp rfid
3008   2        }
3009   1        /*
3010   1        else if(g_dq_otp_type == CMD_OTP_CLR_PWD)
3011   1        { 
3012   1          g_dq_cmd_repleys_status = OTP_BASE_SUCESS;
3013   1          g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_SET,(unsigned char *)&otp_set_info,sizeof(otp_base_setting_info),
             -&ret,dq_otp_fds_write_common_cb);
3014   1        }
3015   1        */
3016   1        else if (g_dq_otp_type == CMD_OTP_ADD_FP)
3017   1        {
3018   2          uint8_t fp_index_char[2];
3019   2      
3020   2          if (dq_otp_app_get_operate_lock_flag() == 2)
3021   2          {
3022   3            return;
3023   3          }
3024   2      
3025   2          memset(fp_index_char, 0xFF, sizeof(fp_index_char));
3026   2      
3027   2          fp_index_char[0] = (g_dq_fp_index >> 8) & 0xFF;
3028   2          fp_index_char[1] = g_dq_fp_index & 0xFF;
3029   2      
3030   2          if (g_dq_link_error == 1)
3031   2          {
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 51  

3032   3            uint16_t index;
3033   3            uint8_t ret;
3034   3            dq_otp_app_set_operate_lock_flag(2);
3035   3      
3036   3            g_dq_link_error = 0;
3037   3            index = g_dq_fp_index;
3038   3            g_dq_otp_init.del_lock_fp(index, &ret);
3039   3          }
3040   2          else
3041   2          {
3042   3            dq_otp_app_set_operate_lock_flag(0);
3043   3            dq_otp_send_data_reply(cmd_info[i].cmd_h, cmd_info[i].cmd_l, g_dq_cmd_repleys_status, (uint8_t *)fp_ind
             -ex_char, 2);
3044   3          }
3045   2        }
3046   1        else if (g_dq_otp_type == CMD_OTP_ADD_RFID)
3047   1        {
3048   2          uint8_t rfid_index_char[2];
3049   2      
3050   2          if (dq_otp_app_get_operate_lock_flag() == 2)
3051   2          {
3052   3            dq_otp_app_set_operate_lock_flag(0);
3053   3      
3054   3            return;
3055   3          }
3056   2      
3057   2          memset(rfid_index_char, 0xFF, sizeof(rfid_index_char));
3058   2      
3059   2          rfid_index_char[0] = (g_dq_rfid_index >> 8) & 0xFF;
3060   2          rfid_index_char[1] = g_dq_rfid_index & 0xFF;
3061   2      
3062   2          if (g_dq_link_error == 1)
3063   2          {
3064   3            uint16_t index;
3065   3            uint8_t ret;
3066   3            dq_otp_app_set_operate_lock_flag(2);
3067   3      
3068   3            g_dq_link_error = 0;
3069   3            index = g_dq_rfid_index;
3070   3            g_dq_otp_init.del_lock_rf(index, &ret);
3071   3          }
3072   2          else
3073   2          {
3074   3            dq_otp_app_set_operate_lock_flag(0);
3075   3            dq_otp_send_data_reply(cmd_info[i].cmd_h, cmd_info[i].cmd_l, g_dq_cmd_repleys_status, (uint8_t *)rfid_i
             -ndex_char, 2);
3076   3          }
3077   2        }
3078   1        else
3079   1        {
3080   2          dq_otp_common_reply(cmd_info[i].cmd_h, cmd_info[i].cmd_l, g_dq_cmd_repleys_status);
3081   2          dq_otp_app_return_idle();
3082   2        }
3083   1      
3084   1        return;
3085   1      }
3086          
3087          void dq_otp_app_init_suc(void)
3088          {
3089   1        dq_otp_common_reply(0x04, 0x05, g_dq_cmd_repleys_status);
3090   1      }
3091          
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 52  

3092          /*
3093          parameter: 
3094            current status machine
3095          return :
3096            none
3097          */
3098          void dq_otp_fds_clear_init_set_param(dq_otp_write_data_cb write_data_cb)
3099          {
3100   1        unsigned char ret = 0;
3101   1        dq_dev_key_flag = 0;
3102   1        memset(&otp_set_info, 0xFF, sizeof(otp_set_info));
3103   1      //  g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_SET, (unsigned char *)&otp_set_info, sizeof(otp_base_setting_inf
             -o), &ret, write_data_cb);
3104   1        return;
3105   1      }
*** WARNING C280 IN LINE 3098 OF mmi_src\dq_sdk_main.c: 'write_data_cb': unreferenced local variable
3106          /*
3107          parameter: 
3108            current status machine
3109          return :
3110            none
3111          */
3112          void dq_otp_fds_clear_app_pwd(dq_otp_write_data_cb write_data_cb)
3113          {
3114   1        uint8_t i = 0;
3115   1        uint8_t ret = 0;
3116   1      #ifdef __LOCK_USE_MALLOC__
                g_dq_app_pwd_info = (otp_base_app_pwd_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_PWD, &ret);
              #endif
3119   1      
3120   1        for (i = 0; i < DQ_OTP_APP_PWD_NUM; i++)
3121   1        {
3122   2          memset(g_dq_app_pwd_info[i].app_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].app_pwd));
3123   2          memset(g_dq_app_pwd_info[i].replace_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].replace_pwd));
3124   2          g_dq_app_pwd_info[i].pwd_flag = 0xFF;
3125   2          g_dq_app_pwd_info[i].pwd_type = 0xFF;
3126   2        }
3127   1      //  g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_PWD_APP, (unsigned char *)g_dq_app_pwd_info, sizeof(otp_base_app
             -_pwd_info) * DQ_OTP_APP_PWD_NUM, &ret, write_data_cb);
3128   1      #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
3131   1      
3132   1        return;
3133   1      }
*** WARNING C280 IN LINE 3112 OF mmi_src\dq_sdk_main.c: 'write_data_cb': unreferenced local variable
3134          
3135          void dq_otp_fds_clear_app_pwd_by_password(void)
3136          {
3137   1        uint8_t i = 0;
3138   1        uint8_t ret = 0;
3139   1        unsigned short sys_hour = 0;
3140   1      #ifdef __LOCK_USE_MALLOC__
                g_dq_app_pwd_info = (otp_base_app_pwd_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_PWD, &ret);
              #endif
3143   1      
3144   1        dq_otp_get_sys_time_hour(&sys_hour);
3145   1      
3146   1        for (i = 0; i < DQ_OTP_APP_PWD_NUM; i++)
3147   1        {
3148   2          switch (g_dq_app_pwd_info[i].pwd_type)
3149   2          {
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 53  

3150   3          case OTP_PWD_TYPE_SIN:
3151   3            if (g_dq_app_pwd_info[i].pwd_flag == 1)
3152   3            {
3153   4              unsigned char dec_pwd_char[15];
3154   4              unsigned short pwd_hour;
3155   4              unsigned char len = dq_otp_get_pwd_len(g_dq_app_pwd_info[i].app_pwd, 5);
3156   4              memset(dec_pwd_char, 0x00, sizeof(dec_pwd_char));
3157   4              dq_otp_enc_pwd(g_dq_app_pwd_info[i].app_pwd, len, otp_set_info.otp_sec_key_8, otp_set_info.otp_exg_key
             -_8, dec_pwd_char);
3158   4              pwd_hour = dq_otp_get_pwd_time_hour(dec_pwd_char, 5, 1);
3159   4      
3160   4              if (pwd_hour + 6 <= sys_hour)
3161   4              {
3162   5                memset(g_dq_app_pwd_info[i].app_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].app_pwd));
3163   5                memset(g_dq_app_pwd_info[i].replace_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].replace_pwd));
3164   5                g_dq_app_pwd_info[i].pwd_flag = 0xFF;
3165   5                g_dq_app_pwd_info[i].pwd_type = 0xFF;
3166   5              }
3167   4            }
3168   3            break;
3169   3          case OTP_PWD_TYPE_PER:
3170   3            if (g_dq_app_pwd_info[i].pwd_flag == 1)
3171   3            {
3172   4              unsigned char dec_pwd_char[15];
3173   4              unsigned short pwd_hour;
3174   4              unsigned char len = dq_otp_get_pwd_len(g_dq_app_pwd_info[i].app_pwd, 5);
3175   4              memset(dec_pwd_char, 0x00, sizeof(dec_pwd_char));
3176   4              dq_otp_enc_pwd(g_dq_app_pwd_info[i].app_pwd, len, otp_set_info.otp_sec_key_8, otp_set_info.otp_exg_key
             -_8, dec_pwd_char);
3177   4              pwd_hour = dq_otp_get_pwd_time_hour(dec_pwd_char, 5, 1);
3178   4      
3179   4              if (pwd_hour + 24 <= sys_hour)
3180   4              {
3181   5                memset(g_dq_app_pwd_info[i].app_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].app_pwd));
3182   5                memset(g_dq_app_pwd_info[i].replace_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].replace_pwd));
3183   5                g_dq_app_pwd_info[i].pwd_flag = 0xFF;
3184   5                g_dq_app_pwd_info[i].pwd_type = 0xFF;
3185   5              }
3186   4              else
3187   4                g_dq_app_pwd_info[i].pwd_flag = 2;
3188   4            }
3189   3            break;
3190   3          case OTP_PWD_TYPE_LIM:
3191   3            if (g_dq_app_pwd_info[i].pwd_flag == 1)
3192   3            {
3193   4              unsigned char dec_pwd_char[15];
3194   4              unsigned short pwd_hour;
3195   4              unsigned short end_time;
3196   4              unsigned char len = dq_otp_get_pwd_len(g_dq_app_pwd_info[i].app_pwd, 5);
3197   4              memset(dec_pwd_char, 0x00, sizeof(dec_pwd_char));
3198   4              if (len == 8)
3199   4                dq_otp_enc_pwd(g_dq_app_pwd_info[i].app_pwd, len, otp_set_info.otp_sec_key_8, otp_set_info.otp_exg_ke
             -y_8, dec_pwd_char);
3200   4              else if (len == 9)
3201   4                dq_otp_enc_pwd(g_dq_app_pwd_info[i].app_pwd, len, otp_set_info.otp_sec_key_9, otp_set_info.otp_exg_ke
             -y_9, dec_pwd_char);
3202   4              pwd_hour = dq_otp_get_pwd_time_hour(dec_pwd_char, 5, 0);
3203   4      
3204   4              end_time = dq_otp_get_lim_pwd_end_time(dec_pwd_char, len) / 3600;
3205   4              if (pwd_hour + 24 <= sys_hour || end_time < sys_hour)
3206   4              {
3207   5                memset(g_dq_app_pwd_info[i].app_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].app_pwd));
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 54  

3208   5                memset(g_dq_app_pwd_info[i].replace_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].replace_pwd));
3209   5                g_dq_app_pwd_info[i].pwd_type = 0xFF;
3210   5                g_dq_app_pwd_info[i].pwd_flag = 0xFF;
3211   5              }
3212   4              else
3213   4                g_dq_app_pwd_info[i].pwd_flag = 2;
3214   4            }
3215   3            break;
3216   3          case OTP_PWD_TYPE_LOOP:
3217   3            if (g_dq_app_pwd_info[i].pwd_flag == 1)
3218   3            {
3219   4              unsigned char dec_pwd_char[15];
3220   4              unsigned short pwd_hour;
3221   4              unsigned char len = dq_otp_get_pwd_len(g_dq_app_pwd_info[i].app_pwd, 5);
3222   4              memset(dec_pwd_char, 0x00, sizeof(dec_pwd_char));
3223   4              dq_otp_enc_pwd(g_dq_app_pwd_info[i].app_pwd, len, otp_set_info.otp_sec_key_9, otp_set_info.otp_exg_key
             -_9, dec_pwd_char);
3224   4              pwd_hour = dq_otp_get_pwd_time_hour(dec_pwd_char, 5, 1);
3225   4      
3226   4              if (pwd_hour + 24 <= sys_hour)
3227   4              {
3228   5                memset(g_dq_app_pwd_info[i].app_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].app_pwd));
3229   5                memset(g_dq_app_pwd_info[i].replace_pwd, 0xFF, sizeof(g_dq_app_pwd_info[i].replace_pwd));
3230   5                g_dq_app_pwd_info[i].pwd_flag = 0xFF;
3231   5                g_dq_app_pwd_info[i].pwd_type = 0xFF;
3232   5              }
3233   4              else
3234   4                g_dq_app_pwd_info[i].pwd_flag = 2;
3235   4            }
3236   3            break;
3237   3          }
3238   2        }
3239   1      //  g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_PWD_APP, (unsigned char *)g_dq_app_pwd_info, sizeof(otp_base_app
             -_pwd_info) * DQ_OTP_APP_PWD_NUM, &ret, NULL);
3240   1      #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
3243   1        return;
3244   1      }
3245          /*
3246          parameter: 
3247            current status machine
3248          return :
3249            none
3250          */
3251          void dq_otp_fds_clear_log(dq_otp_write_data_cb write_data_cb)
3252          {
3253   1        unsigned char ret = 0;
3254   1        unsigned char i;
3255   1        for (i = 0; i < DQ_OTP_LOG_NUM; i++)
3256   1        {
3257   2          memset(otp_lock_log[i].app_pwd, 0xFF, sizeof(otp_lock_log[i].app_pwd));
3258   2          otp_lock_log[i].sys_time = 0xFFFFFFFF;
3259   2          otp_lock_log[i].type = 0xFF;
3260   2          otp_lock_log[i].sys_time_correct = 0xFF;
3261   2      
3262   2          otp_lock_log[i].flag = 0xFF;
3263   2        }
3264   1        //memset(otp_lock_log,0xFF,sizeof(otp_lock_log));
3265   1        otp_log_head = 0;
3266   1        otp_log_end = 0;
3267   1        //LOG
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 55  

3268   1      //  g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_LOG, (unsigned char *)&otp_lock_log, sizeof(otp_base_log_info) *
             - DQ_OTP_LOG_NUM, &ret, write_data_cb);
3269   1        return;
3270   1      }
*** WARNING C280 IN LINE 3251 OF mmi_src\dq_sdk_main.c: 'write_data_cb': unreferenced local variable
3271          /*
3272          parameter: 
3273            current status machine
3274          return :
3275            none
3276          */
3277          void dq_otp_fds_clear_app_fp(dq_otp_write_data_cb write_data_cb)
3278          {
3279   1        unsigned char i = 0;
3280   1        unsigned char ret = 0;
3281   1      #ifdef __LOCK_USE_MALLOC__
                g_dq_app_fp_info = (otp_base_app_fp_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_FP, &ret);
              #endif
3284   1        for (i = 0; i < DQ_OTP_APP_FP_NUM; i++)
3285   1        {
3286   2          g_dq_app_fp_info[i].fp_end_time = 0xFFFFFFFF;
3287   2          g_dq_app_fp_info[i].fp_start_time = 0xFFFFFFFF;
3288   2          //g_dq_app_fp_info[i].fp_index = 0xFFFF;
3289   2        }
3290   1        //LOG
3291   1      //  g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_FP, (unsigned char *)g_dq_app_fp_info, sizeof(otp_base_app_fp_in
             -fo) * DQ_OTP_APP_FP_NUM, &ret, write_data_cb);
3292   1      #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_APP_FP, (void **)&g_dq_app_fp_info);
              #endif
3295   1        return;
3296   1      }
*** WARNING C280 IN LINE 3277 OF mmi_src\dq_sdk_main.c: 'write_data_cb': unreferenced local variable
3297          /*
3298          parameter: 
3299            current status machine
3300          return :
3301            none
3302          */
3303          void dq_otp_fds_clear_app_rf(dq_otp_write_data_cb write_data_cb)
3304          {
3305   1        unsigned char i = 0;
3306   1        unsigned char ret = 0;
3307   1      #ifdef __LOCK_USE_MALLOC__
                g_dq_app_rfid_info = (otp_base_app_rfid_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_RFID, &ret);
              #endif
3310   1        for (i = 0; i < DQ_OTP_APP_RFID_NUM; i++)
3311   1        {
3312   2          g_dq_app_rfid_info[i].rfid_end_time = 0xFFFFFFFF;
3313   2          g_dq_app_rfid_info[i].rfid_start_time = 0xFFFFFFFF;
3314   2          //g_dq_app_rfid_info[i].rfid_index = 0xFFFF;
3315   2        }
3316   1        //LOG
3317   1      //  g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_RFID, (unsigned char *)g_dq_app_rfid_info, sizeof(otp_base_app_r
             -fid_info) * DQ_OTP_APP_RFID_NUM, &ret, write_data_cb);
3318   1      #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_APP_RFID, (void **)&g_dq_app_rfid_info);
              #endif
3321   1        return;
3322   1      }
*** WARNING C280 IN LINE 3303 OF mmi_src\dq_sdk_main.c: 'write_data_cb': unreferenced local variable
3323          
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 56  

3324          #if 1
3325          
3326          static void dq_otp_find_log_head_end(void)
3327          {
3328   1      #if 1
3329   1        unsigned char i = 0;
3330   1        unsigned char index = 0xFF;
3331   1      
3332   1        for (i = 0; i < DQ_OTP_LOG_NUM; i++)
3333   1        {
3334   2          if (otp_lock_log[i].flag == 1)
3335   2          {
3336   3            index = i;
3337   3            break;
3338   3          }
3339   2        }
3340   1        if (index == 0xFF)
3341   1        {
3342   2          otp_log_end = 0;
3343   2          otp_log_head = 0;
3344   2        }
3345   1        else
3346   1        {
3347   2          otp_log_head = index;
3348   2          for (i = 0; i < DQ_OTP_LOG_NUM; i++)
3349   2          {
3350   3            if (otp_lock_log[i].flag == 2)
3351   3            {
3352   4              index = i;
3353   4              break;
3354   4            }
3355   3          }
3356   2          if (index < DQ_OTP_LOG_NUM - 1)
3357   2            otp_log_end = index + 1;
3358   2          else
3359   2            otp_log_end = 0;
3360   2      
3361   2          if (otp_log_end == otp_log_head)
3362   2          {
3363   3            if (otp_log_head < DQ_OTP_LOG_NUM - 1)
3364   3              otp_log_head++;
3365   3            else
3366   3              otp_log_head = 0;
3367   3      
3368   3            otp_lock_log[otp_log_head].flag = 1;
3369   3            otp_lock_log[otp_log_end].sys_time = 0xFFFFFFFF;
3370   3            otp_lock_log[otp_log_end].type = 0xFF;
3371   3            memset(otp_lock_log[otp_log_end].app_pwd, 0xFF, sizeof(otp_lock_log[otp_log_end].app_pwd));
3372   3            otp_lock_log[otp_log_end].flag = 0xFF;
3373   3          }
3374   2        }
3375   1      
3376   1      #else
                unsigned char i = 0;
                unsigned char index = 0xFF;
                uint32_t time = 0xFFFFFFFF;
                for (i = 0; i < DQ_OTP_LOG_NUM; i++)
                {
                  if (otp_lock_log[i].sys_time < time)
                  {
                    time = otp_lock_log[i].sys_time;
                    index = i;
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 57  

                  }
                }
                if (index == 0xFF)
                {
                  otp_log_end = 0;
                  otp_log_head = 0;
                }
                else
                {
                  otp_log_head = index;
                  for (i = 0; i < DQ_OTP_LOG_NUM; i++)
                  {
                    if (otp_lock_log[i].sys_time != 0xFFFFFFFF && otp_lock_log[i].sys_time > time)
                    {
                      time = otp_lock_log[i].sys_time;
                      index = i;
                    }
                  }
                  if (index < DQ_OTP_LOG_NUM - 1)
                    otp_log_end = index + 1;
                  else
                    otp_log_end = 0;
              
                  if (otp_log_end == otp_log_head)
                  {
                    if (otp_log_head < DQ_OTP_LOG_NUM - 1)
                      otp_log_head++;
                    else
                      otp_log_head = 0;
                  }
                }
              #endif
3418   1      }
3419          
3420          unsigned char dq_otp_add_log_index(void)
3421          {
3422   1        unsigned char index;
3423   1        index = otp_log_end;
3424   1        if (otp_log_end < DQ_OTP_LOG_NUM - 1)
3425   1          otp_log_end++;
3426   1        else
3427   1          otp_log_end = 0;
3428   1      
3429   1        if (otp_log_end == otp_log_head)
3430   1        {
3431   2          if (otp_log_head < DQ_OTP_LOG_NUM - 1)
3432   2            otp_log_head++;
3433   2          else
3434   2            otp_log_head = 0;
3435   2      
3436   2          otp_lock_log[otp_log_end].sys_time = 0xFFFFFFFF;
3437   2          otp_lock_log[otp_log_end].type = 0xFF;
3438   2          memset(otp_lock_log[otp_log_end].app_pwd, 0xFF, sizeof(otp_lock_log[otp_log_end].app_pwd));
3439   2          otp_lock_log[otp_log_end].sys_time_correct = 0xFF;
3440   2          otp_lock_log[otp_log_end].flag = 0xFF;
3441   2        }
3442   1      
3443   1        if (index == 0)
3444   1        {
3445   2          otp_lock_log[DQ_OTP_LOG_NUM - 1].flag = 0;
3446   2          otp_lock_log[0].flag = 2;
3447   2        }
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 58  

3448   1        else
3449   1        {
3450   2          otp_lock_log[index - 1].flag = 0;
3451   2          otp_lock_log[index].flag = 2;
3452   2        }
3453   1        otp_lock_log[otp_log_head].flag = 1;
3454   1      
3455   1        return index;
3456   1      }
3457          
3458          unsigned char dq_otp_get_log_index(void)
3459          {
3460   1        unsigned char index;
3461   1      
3462   1        if (otp_log_head == otp_log_end)
3463   1          return 0xFF;
3464   1      
3465   1        index = otp_log_head;
3466   1      
3467   1        if (otp_log_head < DQ_OTP_LOG_NUM - 1)
3468   1          otp_log_head++;
3469   1        else
3470   1          otp_log_head = 0;
3471   1      
3472   1        otp_lock_log[index].flag = 0;
3473   1        otp_lock_log[otp_log_head].flag = 1;
3474   1      
3475   1        return index;
3476   1      }
3477          
3478          void dq_otp_add_exchange_temp_open_log(uint8_t src_id, uint8_t dest_id)
3479          {
3480   1        unsigned char j;
3481   1      
3482   1        otp_lock_temp_log[dest_id].sys_time = otp_lock_temp_log[src_id].sys_time;
3483   1        otp_lock_temp_log[dest_id].type = otp_lock_temp_log[src_id].type;
3484   1        otp_lock_temp_log[dest_id].sys_time_correct = otp_lock_temp_log[src_id].sys_time_correct;
3485   1      
3486   1        memset(otp_lock_temp_log[dest_id].app_pwd, 0xFF, sizeof(otp_lock_temp_log[dest_id].app_pwd));
3487   1      
3488   1        for (j = 0; j < 5; j++)
3489   1        {
3490   2          otp_lock_temp_log[dest_id].app_pwd[j] = otp_lock_temp_log[src_id].app_pwd[j];
3491   2        }
3492   1      }
3493          
3494          void dq_otp_add_open_log_by_temp(uint8_t id)
3495          {
3496   1        unsigned char i, j;
3497   1      
3498   1        i = dq_otp_add_log_index();
3499   1      
3500   1        otp_lock_log[i].sys_time = otp_lock_temp_log[id].sys_time;
3501   1        otp_lock_log[i].type = otp_lock_temp_log[id].type;
3502   1        otp_lock_log[i].sys_time_correct = otp_lock_temp_log[id].sys_time_correct;
3503   1      
3504   1        memset(otp_lock_log[i].app_pwd, 0xFF, sizeof(otp_lock_log[i].app_pwd));
3505   1      
3506   1        for (j = 0; j < 5; j++)
3507   1        {
3508   2          otp_lock_log[i].app_pwd[j] = otp_lock_temp_log[id].app_pwd[j];
3509   2        }
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 59  

3510   1      }
3511          
3512          void dq_otp_del_temp_open_log(void)
3513          {
3514   1        uint8_t i;
3515   1        for (i = 0; i < 2; i++)
3516   1        {
3517   2          otp_lock_temp_log[i].sys_time = 0xFFFFFFFF;
3518   2          otp_lock_temp_log[i].type = 0xFF;
3519   2          memset(otp_lock_temp_log[i].app_pwd, 0xFF, sizeof(otp_lock_temp_log[i].app_pwd));
3520   2          otp_lock_temp_log[i].sys_time_correct = 0xFF;
3521   2          otp_lock_temp_log[i].flag = 0xFF;
3522   2        }
3523   1      }
3524          
3525          unsigned char dq_otp_add_temp_open_log(uint8_t id, unsigned char type, unsigned char *pwd, unsigned char l
             -en)
3526          {
3527   1        unsigned char j;
3528   1      
3529   1        otp_lock_temp_log[id].sys_time = dq_otp_get_sys_time_sec();
3530   1        otp_lock_temp_log[id].type = type;
3531   1        otp_lock_temp_log[id].sys_time_correct = dq_otp_get_lock_sys_time_state();
3532   1      
3533   1        memset(otp_lock_temp_log[id].app_pwd, 0xFF, sizeof(otp_lock_temp_log[id].app_pwd));
3534   1      
3535   1        for (j = 0; j < len; j++)
3536   1        {
3537   2          otp_lock_temp_log[id].app_pwd[j] = pwd[j];
3538   2        }
3539   1        return 0;
3540   1      }
3541          
3542          unsigned char dq_otp_add_open_log(unsigned char type, unsigned char *pwd, unsigned char len)
3543          {
3544   1      #if 1
3545   1        unsigned char i, j;
3546   1        //unsigned char password[5];
3547   1      
3548   1        i = dq_otp_add_log_index();
3549   1      
3550   1        otp_lock_log[i].sys_time = dq_otp_get_sys_time_sec();
3551   1        otp_lock_log[i].type = type;
3552   1        otp_lock_log[i].sys_time_correct = dq_otp_get_lock_sys_time_state();
3553   1      
3554   1        memset(otp_lock_log[i].app_pwd, 0xFF, sizeof(otp_lock_log[i].app_pwd));
3555   1      
3556   1        for (j = 0; j < len; j++)
3557   1        {
3558   2          otp_lock_log[i].app_pwd[j] = pwd[j];
3559   2        }
3560   1        return 0;
3561   1      #else
                unsigned char i;
                memset(otp_temp_lock_log.sys_time, 0xFF, sizeof(otp_temp_lock_log.sys_time));
                memset(otp_temp_lock_log.app_pwd, 0xFF, sizeof(otp_temp_lock_log.app_pwd));
                otp_temp_lock_log.sys_time = dq_otp_get_sys_time_sec();
                otp_temp_lock_log.type = type;
                for (i = 0; i < len; i++)
                {
                  otp_temp_lock_log.app_pwd[i] = pwd[i];
                }
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 60  

              #endif
3572   1      }
3573          
3574          unsigned char dq_otp_add_alarm_log(unsigned char type)
3575          {
3576   1        //unsigned char ret = 0;
3577   1        unsigned char i;
3578   1      
3579   1        i = dq_otp_add_log_index();
3580   1      
3581   1        otp_lock_log[i].sys_time = dq_otp_get_sys_time_sec();
3582   1        otp_lock_log[i].type = type;
3583   1        otp_lock_log[i].sys_time_correct = dq_otp_get_lock_sys_time_state();
3584   1      
3585   1        //g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_LOG,(unsigned char *)&otp_lock_log,sizeof(otp_base_log_info)*DQ_
             -OTP_LOG_NUM,&ret,NULL);
3586   1      
3587   1        return 0;
3588   1      }
3589          #if 0
              unsigned char dq_otp_del_open_log(void)
              {
                uint8_t temp_end, temp_end_next;
                if(otp_log_head == otp_log_end)
                  return 1;
              
                temp_end = otp_log_end;
                
                do
                {
                  if(temp_end>0)
                    temp_end--;
                  else
                    temp_end = DQ_OTP_LOG_NUM-1;
                  if(temp_end==otp_log_head)
                    break;
                }
                while(!(otp_lock_log[temp_end].type >= DQ_OPEN_LOG_ADMIN_PASSWORD && otp_lock_log[temp_end].type<=DQ_OPEN
             -_LOG_USER_RF));
              
                if(temp_end!=otp_log_head)
                {
              
                  while(1)
                  {
                    if(temp_end<DQ_OTP_LOG_NUM-1)
                      temp_end_next = temp_end+1;
                    else
                      temp_end_next = 0;
              
                    if(temp_end_next!=otp_log_end)
                    {
                      otp_lock_log[temp_end].sys_time = otp_lock_log[temp_end_next].sys_time;
                      otp_lock_log[temp_end].type = otp_lock_log[temp_end_next].type;
                      memcpy(otp_lock_log[temp_end].app_pwd , otp_lock_log[temp_end_next].app_pwd,sizeof(otp_lock_log[temp_e
             -nd].app_pwd ));
                      otp_lock_log[temp_end].sys_time_correct = otp_lock_log[temp_end_next].sys_time_correct;;
                      otp_lock_log[temp_end].flag = otp_lock_log[temp_end_next].flag;
              
                      temp_end = temp_end_next;
                    }
                    else
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 61  

                    {
                      otp_lock_log[temp_end].sys_time = 0xFFFFFFFF;
                      otp_lock_log[temp_end].type = 0xFF;
                      memset(otp_lock_log[temp_end].app_pwd , 0xFF,sizeof(otp_lock_log[temp_end].app_pwd ));
                      otp_lock_log[temp_end].sys_time_correct = 0xFF;
                      otp_lock_log[temp_end].flag = 0xFF;
              
                      otp_log_end = temp_end;
              
                      break;
                    }
                  }
              
                }
              
              
                
                if(otp_log_end != otp_log_head)
                {
                  if(otp_log_end>0&&otp_log_head!=otp_log_end-1)
                    otp_lock_log[otp_log_end-1].flag = 2;
                  else if(otp_log_head!=DQ_OTP_LOG_NUM-1)   
                    otp_lock_log[DQ_OTP_LOG_NUM-1].flag = 2;
                }
                  
                  
                return 0;
              }
              #endif
3659          
3660          void dq_otp_save_open_log(dq_otp_write_data_cb write_data_cb)
3661          {
3662   1        unsigned char ret = 0;
3663   1      
3664   1      //  g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_LOG, (unsigned char *)&otp_lock_log, sizeof(otp_base_log_info) *
             - DQ_OTP_LOG_NUM, &ret, write_data_cb);
3665   1        return;
3666   1      }
*** WARNING C280 IN LINE 3660 OF mmi_src\dq_sdk_main.c: 'write_data_cb': unreferenced local variable
3667          
3668          void dq_otp_send_log(void)
3669          {
3670   1      #if 1
3671   1        unsigned char i;
3672   1        unsigned char index = dq_otp_get_log_index();
3673   1        unsigned char _data[10] = {0};
3674   1        uint32_t time = 0;
3675   1      
3676   1        if (index == 0xFF)
3677   1        {
3678   2          unsigned char ret = 0;
3679   2          if (dq_otp_lock_save_log_state())
3680   2          {
3681   3            g_dq_cmd_repleys_status = OTP_BASE_EMPTY;
3682   3      //      g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_LOG, (unsigned char *)&otp_lock_log, sizeof(otp_base_log_info)
             - * DQ_OTP_LOG_NUM, &ret, dq_otp_fds_write_common_cb);
3683   3          }
3684   2          else
3685   2            dq_otp_common_reply(0x03, 0x01, OTP_BASE_EMPTY);
3686   2          return;
3687   2        }
3688   1      
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 62  

3689   1        time = otp_lock_log[index].sys_time;
3690   1        _data[0] = otp_lock_log[index].type;
3691   1        _data[1] = (time >> 24) & 0xFF;
3692   1        _data[2] = (time >> 16) & 0xFF;
3693   1        _data[3] = (time >> 8) & 0xFF;
3694   1        _data[4] = time & 0xFF;
3695   1      
3696   1        for (i = 0; i < 5; i++)
3697   1        {
3698   2          _data[5 + i] = otp_lock_log[index].app_pwd[i];
3699   2        }
3700   1      
3701   1        dq_otp_send_data_reply(0x03, 0x01, OTP_BASE_SUCESS, (uint8_t *)_data, 10);
3702   1      
3703   1        otp_lock_log[index].sys_time = 0xFFFFFFFF;
3704   1        otp_lock_log[index].type = 0xFF;
3705   1        memset(otp_lock_log[index].app_pwd, 0xFF, sizeof(otp_lock_log[otp_log_end].app_pwd));
3706   1        otp_lock_log[index].sys_time_correct = 0xFF;
3707   1        otp_lock_log[index].flag = 0xFF;
3708   1      #endif
3709   1      }
3710          
3711          uint8_t dq_otp_check_and_update_log_time(uint32_t time)
3712          {
3713   1      
3714   1        unsigned char i = 0;
3715   1        uint8_t res = 0;
3716   1      
3717   1        for (i = 0; i < DQ_OTP_LOG_NUM; i++)
3718   1        {
3719   2          if (otp_lock_log[i].sys_time_correct == 0)
3720   2          {
3721   3            otp_lock_log[i].sys_time += time;
3722   3            otp_lock_log[i].sys_time_correct = 1;
3723   3            res = 1;
3724   3          }
3725   2        }
3726   1        for (i = 0; i < 2; i++)
3727   1        {
3728   2          if (otp_lock_temp_log[i].sys_time_correct == 0)
3729   2          {
3730   3            otp_lock_temp_log[i].sys_time += time;
3731   3            otp_lock_temp_log[i].sys_time_correct = 1;
3732   3            res = 1;
3733   3          }
3734   2        }
3735   1      
3736   1        if (res == 1)
3737   1          dq_otp_save_open_log(dq_otp_update_time);
3738   1      
3739   1        return res;
3740   1      }
3741          
3742          #endif
3743          
3744          static char dq_app_pwd_flag = 0;
3745          static char dq_app_pwd_for_open_ret = 0;
3746          void dq_otp_app_pwd_save_cb(void)
3747          {
3748   1        unsigned char ret = 0;
3749   1        dq_app_pwd_flag = 0;
3750   1        ret = dq_app_pwd_for_open_ret;
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 63  

3751   1        dq_app_pwd_for_open_ret = 0;
3752   1        g_dq_otp_init.input_pwd_cb(ret);
3753   1      }
3754          
3755          unsigned char dq_otp_save_temp_pwd(unsigned char *in_pwd, OTP_PWD_TYPE type)
3756          {
3757   1        uint8_t i = 0;
3758   1        uint8_t pwd_index;
3759   1        uint8_t ret = 0;
3760   1      #ifdef __LOCK_USE_MALLOC__
                g_dq_app_pwd_info = (otp_base_app_pwd_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_PWD, &ret);
              #endif
3763   1        pwd_index = dq_otp_get_empty_pwd_index();
3764   1      
3765   1        if (pwd_index == DQ_OTP_APP_PWD_NUM)
3766   1          return OTP_BASE_NO_MEM;
3767   1      
3768   1        //g_dq_app_pwd_info[pwd_index].pwd_index = pwd_index;
3769   1        for (i = 0; i < 5; i++)
3770   1        {
3771   2          g_dq_app_pwd_info[pwd_index].app_pwd[i] = in_pwd[i];
3772   2          g_dq_app_pwd_info[pwd_index].replace_pwd[i] = in_pwd[i];
3773   2        }
3774   1      
3775   1        g_dq_app_pwd_info[pwd_index].pwd_type = type;
3776   1        g_dq_app_pwd_info[pwd_index].pwd_flag = 1;
3777   1      
3778   1        //save pwd info
3779   1        dq_app_pwd_flag = 1;
3780   1      //  g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_PWD_APP, (unsigned char *)g_dq_app_pwd_info, sizeof(otp_base_app
             -_pwd_info) * DQ_OTP_APP_PWD_NUM, &ret, dq_otp_app_pwd_save_cb);
3781   1      
3782   1      #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
3785   1      
3786   1        return OTP_BASE_SUCESS;
3787   1      }
3788          #if 0
              unsigned char dq_otp_save_temp_pwd_with_endtime(unsigned char *in_pwd, OTP_PWD_TYPE type, uint32_t endtime
             -)
              {
                uint8_t i = 0;
                uint8_t pwd_index = dq_otp_get_empty_pwd_index();
                uint8_t ret = 0;
              
                if(pwd_index == DQ_OTP_APP_PWD_NUM)
                  return OTP_BASE_NO_MEM;
              
                //g_dq_app_pwd_info[pwd_index].pwd_index = pwd_index;
              
                for(i=0;i<5;i++)
                {
                  g_dq_app_pwd_info[pwd_index].app_pwd[i] = in_pwd[i];
                  g_dq_app_pwd_info[pwd_index].replace_pwd[i] = in_pwd[i];
                }
              
                g_dq_app_pwd_info[pwd_index].pwd_type = type;
                g_dq_app_pwd_info[pwd_index].pwd_used_flag = 1;
                if(endtime != 0)
                  g_dq_app_pwd_info[pwd_index].pwd_end_time = endtime;
              
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 64  

                g_dq_app_pwd_info[pwd_index].pwd_del_flag = 0;
                
              
                //save pwd info
                dq_app_pwd_flag = 1;
                g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_PWD_APP,(unsigned char *)&g_dq_app_pwd_info,sizeof(otp_base_app_pw
             -d_info)*DQ_OTP_APP_PWD_NUM,&ret,dq_otp_app_pwd_save_cb);
                return OTP_BASE_SUCESS;
              
              }
              #endif
3821          #if 0
              void dq_otp_update_pwd_app(unsigned char index)
              {
                uint8_t ret = 0;
              
                g_dq_app_pwd_info[index].pwd_used_flag = 1;
                switch(g_dq_app_pwd_info[index].pwd_type)
                {
                  case OTP_PWD_TYPE_LIM:
                  {
                    unsigned char len;
                    unsigned char dec_pwd_char[15];
                    memset(dec_pwd_char,0x00,sizeof(dec_pwd_char));
                    len = dq_otp_get_pwd_len(g_dq_app_pwd_info[index].app_pwd,5);
              
                    if(len == 8)
                      dq_otp_enc_pwd(g_dq_app_pwd_info[index].app_pwd,len,otp_set_info.otp_sec_key_8,otp_set_info.otp_exg_ke
             -y_8,dec_pwd_char);
                    else if(len == 9)
                      dq_otp_enc_pwd(g_dq_app_pwd_info[index].app_pwd,len,otp_set_info.otp_sec_key_9,otp_set_info.otp_exg_ke
             -y_9,dec_pwd_char);  
                    g_dq_app_pwd_info[index].pwd_end_time=dq_otp_get_lim_pwd_end_time(dec_pwd_char, len);
                  }
                    break;
                  case OTP_PWD_TYPE_SIN:
                    break;
                  case OTP_PWD_TYPE_PER:
                  case OTP_PWD_TYPE_LOOP:
                    break;
                  default:
                    break;
                }
              
                dq_app_pwd_flag = 1;
                g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_PWD_APP,(unsigned char *)&g_dq_app_pwd_info,sizeof(otp_base_app_pw
             -d_info)*DQ_OTP_APP_PWD_NUM,&ret,dq_otp_app_pwd_save_cb);
                
              }
              #endif
3857          
3858          /*
3859          parameter: 
3860            current status machine
3861          return :
3862            none
3863          */
3864          void dq_otp_enc_pwd(unsigned char *pwd, unsigned char len, unsigned char *sec_key, unsigned char *exg_key,
             - unsigned char *sec_pwd)
3865          {
3866   1        unsigned char sec_key_char[10];
3867   1        unsigned char exg_key_char[10];
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 65  

3868   1        unsigned char pwd_char[10];
3869   1        unsigned char sec_char[10];
3870   1        unsigned int int_sec_key = 0;
3871   1        unsigned int int_pwd = 0;
3872   1        unsigned char i = 0;
3873   1        unsigned char j = 0;
3874   1        unsigned char hex_pwd_len = 0;
3875   1        unsigned char exchange_id = 0;
3876   1        unsigned char exchange_char[10];
3877   1      
3878   1        if (len == 8)
3879   1          hex_pwd_len = 4;
3880   1        else if (len == 9)
3881   1          hex_pwd_len = 5;
3882   1      
3883   1        memset(sec_key_char, 0x00, sizeof(sec_key_char));
3884   1        memset(exg_key_char, 0x00, sizeof(exg_key_char));
3885   1        memset(pwd_char, 0x00, sizeof(pwd_char));
3886   1      
3887   1        dq_sdk_CharToHexByte((const uint8_t *)exg_key, (char *)exg_key_char, hex_pwd_len);
3888   1        dq_sdk_CharToInt(exg_key_char, len);
3889   1      
3890   1        dq_sdk_CharToHexByte((const uint8_t *)sec_key, (char *)sec_key_char, hex_pwd_len);
3891   1        int_sec_key = dq_sdk_CharToInt(sec_key_char, len);
3892   1      
3893   1        dq_sdk_CharToHexByte((const uint8_t *)pwd, (char *)pwd_char, hex_pwd_len);
3894   1      
3895   1        for (i = 0; i < 59; i++)
3896   1        {
3897   2          int_pwd = dq_sdk_CharToInt((const uint8_t *)pwd_char, len);
3898   2      
3899   2          if (int_pwd < int_sec_key)
3900   2          {
3901   3            if (len == 8)
3902   3              int_pwd += 100000000;
3903   3            else if (len == 9)
3904   3              int_pwd += 1000000000;
3905   3            else if (len == 10)
3906   3              int_pwd += 10000000000;
3907   3          }
3908   2          int_pwd -= int_sec_key;
3909   2          memset(sec_char, 0x00, sizeof(sec_char));
3910   2          dq_sdk_IntToByteStr(int_pwd, (char *)sec_char, len);
3911   2          memset(pwd_char, 0x00, sizeof(pwd_char));
3912   2          for (j = 0; j < len; j++)
3913   2          {
3914   3            pwd_char[exg_key_char[j] - 1] = sec_char[j];
3915   3          }
3916   2        }
3917   1        memset(sec_char, 0x00, sizeof(sec_char));
3918   1        exchange_id = pwd_char[2];
3919   1        memset(exchange_char, 0x00, sizeof(exchange_char));
3920   1        dq_sdk_CharToHexByte((const uint8_t *)otp_set_info.g_pwd_signed_data[exchange_id].exchg_num, (char *)exch
             -ange_char, 5);
3921   1        for (i = 0; i < len; i++)
3922   1        {
3923   2          if (i == 2)
3924   2          {
3925   3            sec_char[i] = exchange_id;
3926   3          }
3927   2          else
3928   2          {
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 66  

3929   3            for (j = 0; j < 10; j++)
3930   3            {
3931   4              if (pwd_char[i] == exchange_char[j])
3932   4              {
3933   5                sec_char[i] = j;
3934   5                break;
3935   5              }
3936   4            }
3937   3          }
3938   2        }
3939   1        for (i = 2; i < len; i++)
3940   1        {
3941   2          sec_char[i] = sec_char[i + 1];
3942   2        }
3943   1        sec_char[len - 1] = exchange_id;
3944   1        memcpy((char *)sec_pwd, (const char *)sec_char, len);
3945   1        return;
3946   1      }
3947          /*
3948          parameter: 
3949            current status machine
3950          return :
3951            none
3952          */
3953          void dq_otp_fds_reset_ekey_record_cb(void)
3954          {
3955   1      #ifndef __WIN32_ENV_SUPPORT__
3956   1      //  NRF_LOG_PRINTF_DEBUG("#### dq_otp_fds_reset_ekey_record_cb \n");
3957   1      #endif
3958   1      }
3959          
3960          /*
3961          parameter: 
3962            current status machine
3963          return :
3964            none
3965          */
3966          unsigned char dq_otp_check_app_rfid(unsigned char index)
3967          {
3968   1        //unsigned char i = 0;
3969   1        unsigned char result = 1;
3970   1        uint32_t sys_time;
3971   1      
3972   1      #ifdef __LOCK_USE_MALLOC__
                uint8_t ret;
                g_dq_app_rfid_info = (otp_base_app_rfid_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_RFID, &ret);
              #endif
3976   1        sys_time = dq_otp_get_sys_time_sec();
3977   1      
3978   1        //for(i=0;i<DQ_OTP_APP_RFID_NUM;i++)
3979   1        //{
3980   1        //  if(g_dq_app_rfid_info[i].rfid_index == index)
3981   1        //  {
3982   1        if (g_dq_app_rfid_info[index].rfid_end_time == 0xFFFFFFFF || (sys_time >= g_dq_app_rfid_info[index].rfid_
             -start_time && sys_time <= g_dq_app_rfid_info[index].rfid_end_time))
3983   1        {
3984   2          result = 0;
3985   2          //      break;
3986   2        }
3987   1      
3988   1        //  }
3989   1        //}
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 67  

3990   1      #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_APP_RFID, (void **)&g_dq_app_rfid_info);
              #endif
3993   1      
3994   1        return result;
3995   1      }
3996          
3997          unsigned char dq_otp_check_app_fp(unsigned char index)
3998          {
3999   1        //unsigned char i = 0;
4000   1        unsigned char result = 1;
4001   1        uint32_t sys_time;
4002   1      #ifdef __LOCK_USE_MALLOC__
                uint8_t ret;
                g_dq_app_fp_info = (otp_base_app_fp_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_FP, &ret);
              #endif
4006   1        sys_time = dq_otp_get_sys_time_sec();
4007   1      
4008   1        //for(i=0;i<DQ_OTP_APP_FP_NUM;i++)
4009   1        //{
4010   1        //  if(g_dq_app_fp_info[i].fp_index == index)
4011   1        //  {
4012   1        if (g_dq_app_fp_info[index].fp_end_time == 0xFFFFFFFF || (sys_time >= g_dq_app_fp_info[index].fp_start_ti
             -me && sys_time <= g_dq_app_fp_info[index].fp_end_time))
4013   1        {
4014   2          result = 0;
4015   2          //      break;
4016   2        }
4017   1        //  }
4018   1        //}
4019   1      
4020   1      #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_APP_FP, (void **)&g_dq_app_fp_info);
              #endif
4023   1        return result;
4024   1      }
4025          
4026          /*
4027          parameter: 
4028            current status machine
4029          return :
4030            none
4031          */
4032          unsigned char dq_otp_check_password(unsigned char *password)
4033          {
4034   1        unsigned char i = 0;
4035   1        unsigned char k = 0;
4036   1      #ifdef __LOCK_USE_MALLOC__
                uint8_t ret;
                g_dq_app_pwd_info = (otp_base_app_pwd_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_PWD, &ret);
              #endif
4040   1      
4041   1        for (i = 0; i < DQ_OTP_APP_PWD_NUM; i++)
4042   1        {
4043   2          if (g_dq_app_pwd_info[i].pwd_type != 0xFF)
4044   2          {
4045   3            for (k = 0; k < 5; k++)
4046   3            {
4047   4              if (password[k] != g_dq_app_pwd_info[i].app_pwd[k])
4048   4                break;
4049   4            }
4050   3            if (k == 5)
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 68  

4051   3            {
4052   4              break;
4053   4            }
4054   3          }
4055   2        }
4056   1      
4057   1      #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
4060   1        if (i < DQ_OTP_APP_PWD_NUM)
4061   1        {
4062   2          return 1;
4063   2        }
4064   1      
4065   1        return 0;
4066   1      }
4067          
4068          unsigned char dq_otp_check_replace_password(unsigned char *password)
4069          {
4070   1        unsigned char i = 0;
4071   1        unsigned char k = 0;
4072   1      #ifdef __LOCK_USE_MALLOC__
                uint8_t ret;
                g_dq_app_pwd_info = (otp_base_app_pwd_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_PWD, &ret);
              #endif
4076   1      
4077   1        for (i = 0; i < DQ_OTP_APP_PWD_NUM; i++)
4078   1        {
4079   2          if (g_dq_app_pwd_info[i].pwd_type != 0xFF)
4080   2          {
4081   3            for (k = 0; k < 5; k++)
4082   3            {
4083   4              if (password[k] != g_dq_app_pwd_info[i].replace_pwd[k])
4084   4                break;
4085   4            }
4086   3            if (k == 5)
4087   3            {
4088   4              break;
4089   4            }
4090   3          }
4091   2        }
4092   1      
4093   1      #ifdef __LOCK_USE_MALLOC__
                mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
4096   1        if (i < DQ_OTP_APP_PWD_NUM)
4097   1        {
4098   2          return 1;
4099   2        }
4100   1      
4101   1        return 0;
4102   1      }
4103          
4104          unsigned char dq_otp_check_password_for_open(unsigned char *password, unsigned char len)
4105          {
4106   1        unsigned char i = 0;
4107   1        unsigned char k = 0;
4108   1        unsigned char pwd_len = 0;
4109   1        unsigned char ret = 0;
4110   1        unsigned char ret_t = 0;
4111   1      #ifdef __LOCK_USE_MALLOC__
                g_dq_app_pwd_info = (otp_base_app_pwd_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_PWD, &ret_t);
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 69  

              #endif
4114   1      
4115   1        for (i = 0; i < DQ_OTP_APP_PWD_NUM; i++)
4116   1        {
4117   2          if (g_dq_app_pwd_info[i].pwd_type != 0xFF)
4118   2          {
4119   3            for (k = 0; k < 5; k++)
4120   3            {
4121   4              if (password[k] != g_dq_app_pwd_info[i].replace_pwd[k])
4122   4                break;
4123   4            }
4124   3            if (k == 5)
4125   3            {
4126   4              break;
4127   4            }
4128   3      #if 0
                    for(k=0;k<5;k++)
                    {
                      if(password[k] != g_dq_app_pwd_info[i].app_pwd[k])
                        break;
                    }
                    if(k == 5)
                    {
                      break;
                    }
              #endif
4139   3          }
4140   2        }
4141   1        if (i < DQ_OTP_APP_PWD_NUM)
4142   1        {
4143   2          extern uint8_t mmi_dq_rtc_check_time(void);
4144   2          if (g_dq_app_pwd_info[i].pwd_flag == 2)
4145   2          {
4146   3      #ifdef __LOCK_USE_MALLOC__
                    mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
4149   3            g_dq_otp_init.input_pwd_cb(4);
4150   3            return 4;
4151   3          }
4152   2          if (g_dq_app_pwd_info[i].pwd_type == OTP_PWD_TYPE_SIN && g_dq_app_pwd_info[i].pwd_flag == 1)
4153   2          {
4154   3      #ifdef __LOCK_USE_MALLOC__
                    mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
4157   3            g_dq_otp_init.input_pwd_cb(4);
4158   3            return 4;
4159   3          }
4160   2          else if (g_dq_app_pwd_info[i].pwd_type == OTP_PWD_TYPE_PER && g_dq_app_pwd_info[i].pwd_flag == 1)
4161   2          {
4162   3      #ifdef __LOCK_USE_MALLOC__
                    mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
4165   3            ret = 1;
4166   3          }
4167   2          //    else if (dq_otp_get_lock_sys_time_state() == 0 && mmi_dq_rtc_check_time() == 1)
4168   2          //    {
4169   2          // #ifdef __LOCK_USE_MALLOC__
4170   2          //      mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
4171   2          // #endif
4172   2          //      g_dq_otp_init.input_pwd_cb(6);
4173   2          //      return 6;
4174   2          //    }
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 70  

4175   2          else
4176   2          {
4177   3            uint8_t pwd[5] = {0xFF};
4178   3            memcpy(pwd, g_dq_app_pwd_info[i].app_pwd, 5);
4179   3      #ifdef __LOCK_USE_MALLOC__
                    mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
4182   3            pwd_len = dq_otp_get_pwd_len(pwd, 5);
4183   3            ret = dq_otp_temp_pwd_check(pwd, pwd_len);
4184   3            if (ret == 0)
4185   3              ret = 4;
4186   3          }
4187   2      
4188   2          if (ret == 1)
4189   2          {
4190   3      #ifdef __LOCK_USE_MALLOC__
                    g_dq_app_pwd_info = (otp_base_app_pwd_info *)mmi_dq_fs_get_storage(DQ_FS_MEM_APP_PWD, &ret_t);
              #endif
4193   3            if (g_dq_app_pwd_info[i].pwd_flag == 0)
4194   3            {
4195   4              g_dq_app_pwd_info[i].pwd_flag = 1;
4196   4              dq_app_pwd_flag = 1;
4197   4      //        g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_PWD_APP, (unsigned char *)g_dq_app_pwd_info, sizeof(otp_base_
             -app_pwd_info) * DQ_OTP_APP_PWD_NUM, &ret, dq_otp_app_pwd_save_cb);
4198   4            }
4199   3      #ifdef __LOCK_USE_MALLOC__
                    mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
4202   3          }
4203   2        }
4204   1        else
4205   1        {
4206   2          for (i = 0; i < DQ_OTP_APP_PWD_NUM; i++)
4207   2          {
4208   3            if (g_dq_app_pwd_info[i].pwd_type != 0xFF)
4209   3            {
4210   4              for (k = 0; k < 5; k++)
4211   4              {
4212   5                if (password[k] != g_dq_app_pwd_info[i].app_pwd[k])
4213   5                  break;
4214   5              }
4215   4              if (k == 5)
4216   4              {
4217   5                break;
4218   5              }
4219   4            }
4220   3          }
4221   2      #ifdef __LOCK_USE_MALLOC__
                  mmi_dq_fs_free_storage(DQ_FS_MEM_APP_PWD, (void **)&g_dq_app_pwd_info);
              #endif
4224   2          if (i < DQ_OTP_APP_PWD_NUM)
4225   2            ret = 4;
4226   2          else
4227   2            ret = dq_otp_temp_pwd_check(password, len);
4228   2        }
4229   1      
4230   1        if (ret == 1)
4231   1          dq_otp_add_temp_open_log(0, DQ_OPEN_LOG_USER_PASSWORD, password, 5);
4232   1        else if (ret == 2)
4233   1        {
4234   2          dq_otp_add_alarm_log(DQ_ALART_LOG_EMPTY_PASSWORD);
4235   2        }
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 71  

4236   1      
4237   1        if (dq_app_pwd_flag == 0)
4238   1          g_dq_otp_init.input_pwd_cb(ret);
4239   1        else
4240   1          dq_app_pwd_for_open_ret = ret;
4241   1      
4242   1        return ret;
4243   1      }
4244          
4245          /*
4246          parameter: 
4247            current status machine
4248          return :
4249            none
4250          */
4251          unsigned short dq_otp_gen_random_key(unsigned char *old_key, unsigned char len, unsigned char mod_flag)
4252          {
4253   1        unsigned char i = 0;
4254   1        unsigned short odd_val = 0;
4255   1        unsigned short even_val = 0;
4256   1        unsigned char ret_val = 0;
4257   1        for (i = 0; i < len; i++)
4258   1        {
4259   2          odd_val += (*(old_key + i)) * 2;
4260   2          i++;
4261   2          if (i == len)
4262   2            break;
4263   2          else
4264   2            even_val += (*(old_key + i)) * (*(old_key + i));
4265   2        }
4266   1        ret_val = (odd_val + even_val) % mod_flag;
4267   1        return ret_val;
4268   1      }
4269          
4270          /*
4271          parameter: 
4272            current status machine
4273          return :
4274            none
4275          */
4276          unsigned short dq_otp_get_pwd_time_hour(unsigned char *in_pwd, unsigned char len, unsigned char offset)
4277          {
4278   1        unsigned char time_h[5];
4279   1        unsigned char i = 0;
4280   1        unsigned int time_pwd = 0;
4281   1      
4282   1        memset(time_h, 0x00, sizeof(time_h));
4283   1        for (i = 0; i < len; i++)
4284   1        {
4285   2          time_h[i] = in_pwd[i + offset];
4286   2        }
4287   1      
4288   1        time_pwd = dq_sdk_CharToInt(time_h, 5);
4289   1      
4290   1        return time_pwd;
4291   1      }
4292          
4293          /*
4294          parameter: 
4295            current status machine
4296          return :
4297            none
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 72  

4298          */
4299          unsigned char dq_otp_get_sys_time_hour(unsigned short *sys_hour)
4300          {
4301   1        unsigned int sec_time; //= (1552471200-DQ_OTP_START_TIME_SEC);
4302   1                     // unsigned char week_info;
4303   1      
4304   1        //g_dq_otp_init.get_lock_time_info(&sec_time,&week_info);
4305   1      
4306   1        sec_time = dq_otp_get_sys_time_sec() - otp_set_info.otp_start_hour;
4307   1      
4308   1        *sys_hour = sec_time / 3600;
4309   1      
4310   1      //  NRF_LOG_PRINTF_DEBUG("otp_set_info.otp_start_hour %d\n", otp_set_info.otp_start_hour);
4311   1      
4312   1      //  NRF_LOG_PRINTF_DEBUG("sec_timer %d\n", sec_time);
4313   1      
4314   1        return 1;
4315   1      }
4316          
4317          unsigned char dq_otp_get_local_sys_time_hour(unsigned short *sys_hour)
4318          {
4319   1        uint32_t sec_time; //= (1552471200-DQ_OTP_START_TIME_SEC);
4320   1                   // unsigned char week_info;
4321   1      
4322   1        //g_dq_otp_init.get_lock_time_info(&sec_time,&week_info);
4323   1      
4324   1        sec_time = dq_otp_get_sys_time_sec();
4325   1        g_dq_otp_init.time_zone_pro(&sec_time);
4326   1      
4327   1        *sys_hour = (sec_time / 3600) % 24;
4328   1        return 1;
4329   1      }
4330          
4331          /*
4332          parameter: 
4333            current status machine
4334          return :
4335            none
4336          */
4337          unsigned char dq_otp_check_time_by_hour(unsigned char *in_pwd, unsigned char len, unsigned short delay_tim
             -e)
4338          {
4339   1        unsigned short pwd_hour = 0;
4340   1        unsigned short sys_hour = 0;
4341   1        unsigned char ret_val = 0;
4342   1        pwd_hour = dq_otp_get_pwd_time_hour(in_pwd, len, 1);
4343   1        ret_val = dq_otp_get_sys_time_hour(&sys_hour);
4344   1      
4345   1      //  NRF_LOG_PRINTF_DEBUG("dq_otp_check_time_by_hour %d  %d\n", pwd_hour, sys_hour);
4346   1      
4347   1        if (ret_val == 1)
4348   1        {
4349   2          //if(otp_set_info.otp_empty_hour == 0xFFFF || pwd_hour >= otp_set_info.otp_empty_hour)
4350   2          //{
4351   2          if (delay_time == 0)
4352   2            ret_val = 1;
4353   2          else
4354   2          {
4355   3            if ((sys_hour >= pwd_hour) && (sys_hour < (pwd_hour + delay_time)))
4356   3            {
4357   4              ret_val = 1;
4358   4            }
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 73  

4359   3            else
4360   3            {
4361   4              ret_val = 0;
4362   4            }
4363   3          }
4364   2          //}
4365   2          //else
4366   2          //  ret_val = 0;
4367   2        }
4368   1        return ret_val;
4369   1      }
4370          
4371          /*
4372          parameter: 
4373            current status machine
4374          return :
4375            none
4376          */
4377          unsigned char dq_otp_check_per_pwd_verify(unsigned char *dec_pwd, unsigned char *pwd_in, unsigned char len
             -)
4378          {
4379   1        unsigned char ret_val = 0;
4380   1        unsigned char new_pwd_flag = 0;
4381   1      
4382   1      //  NRF_LOG_PRINTF_DEBUG("dq_otp_check_per_pwd_verify\n");
4383   1        if (dec_pwd[0] != 0x09)
4384   1          return 0;
4385   1      
4386   1        ret_val = dq_otp_check_password(pwd_in);
4387   1        if (ret_val == 0)
4388   1        {
4389   2          ret_val = dq_otp_check_time_by_hour(dec_pwd, 5, 24); //per pwd must in 24 hours
4390   2          new_pwd_flag = 1;
4391   2        }
4392   1        if (ret_val == 1)
4393   1        {
4394   2          if (new_pwd_flag == 1)
4395   2          {
4396   3            //save pwd
4397   3            if (dq_otp_save_temp_pwd(pwd_in, OTP_PWD_TYPE_PER) != 0)
4398   3              ret_val = 5;
4399   3          }
4400   2        }
4401   1      
4402   1        return ret_val;
4403   1      }
*** WARNING C280 IN LINE 4377 OF mmi_src\dq_sdk_main.c: 'len': unreferenced local variable
4404          
4405          /*
4406          parameter: 
4407            current status machine
4408          return :
4409            none
4410          */
4411          unsigned char dq_otp_check_empty_pwd_verify(unsigned char *in_pwd, unsigned char len)
4412          {
4413   1        unsigned short check_code = 0;
4414   1        unsigned short check_code2 = 0;
4415   1        unsigned char ver_code[2];
4416   1        unsigned char ret_val = 0;
4417   1      
4418   1        if (in_pwd[0] != 0x07)
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 74  

4419   1          return 0;
4420   1      
4421   1        memset(ver_code, 0x00, sizeof(ver_code));
4422   1      
4423   1        check_code = dq_otp_gen_random_key(in_pwd, 6, 100);
4424   1        ver_code[0] = in_pwd[6];
4425   1        ver_code[1] = in_pwd[7];
4426   1      
4427   1        check_code2 = dq_sdk_CharToInt(ver_code, 2);
4428   1        if (check_code == check_code2)
4429   1        {
4430   2          ret_val = dq_otp_check_time_by_hour(in_pwd, 5, 2); //empty pwd must in 2 hours
4431   2          if (ret_val == 1)
4432   2          {
4433   3            //clear password
4434   3            //unsigned short pwd_hour = 0;
4435   3            //uint8_t ret = 0;
4436   3      #ifdef __LOCK_VIRTUAL_PASSWORD__
4437   3            extern uint8_t input_empty_pwd_len;
4438   3            if (input_empty_pwd_len == 1)
4439   3      #endif
4440   3            {
4441   4              //pwd_hour = dq_otp_get_pwd_time_hour(in_pwd,5,1);
4442   4              //otp_set_info.otp_empty_hour = pwd_hour;
4443   4              //g_dq_otp_init.fds_write(DQ_OTP_FILE_ID_SET,(unsigned char *)&otp_set_info,sizeof(otp_base_setting_in
             -fo),&ret,dq_otp_fds_clear_app_pwd_by_password);
4444   4              dq_otp_fds_clear_app_pwd_by_password();
4445   4              return 2;
4446   4            }
4447   3          }
4448   2        }
4449   1        return 0;
4450   1      }
*** WARNING C280 IN LINE 4411 OF mmi_src\dq_sdk_main.c: 'len': unreferenced local variable
4451          /*
4452          parameter: 
4453            current status machine
4454          return :
4455            none
4456          */
4457          #if 0
              uint32_t dq_otp_get_sin_pwd_endtime(unsigned char *dec_pwd,unsigned char len)
              {
                unsigned short pwd_hour = 0;
                time_t pwd_time_sec = 0;
                time_t end_time_sec = 0;
                unsigned char time_y,time_m,time_h,time_d;
              
              
                if(dec_pwd[0] != 0x08)
                  return 0;
                pwd_hour = dq_otp_get_pwd_time_hour(dec_pwd,5,1);
                dq_otp_get_pwd_time_ymd(pwd_hour,&time_y,&time_m,&time_d,&time_h);
                pwd_time_sec = dq_otp_get_pwd_time_sec(time_y,time_m,time_d,time_h);
              
                end_time_sec = pwd_time_sec + 6*3600;
                  
                return end_time_sec;
              }
              #endif
4477          unsigned char dq_otp_check_sin_pwd_verify(unsigned char *dec_pwd, unsigned char *pwd_in, unsigned char len
             -)
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 75  

4478          {
4479   1        unsigned char ret_val = 0;
4480   1      //  NRF_LOG_PRINTF_DEBUG("dq_otp_check_sin_pwd_verify\n");
4481   1      
4482   1        if (dec_pwd[0] != 0x08)
4483   1          return 0;
4484   1      
4485   1        ret_val = dq_otp_check_time_by_hour(dec_pwd, 5, 6); //sin pwd must in 6 hours
4486   1      
4487   1        if (ret_val == 1)
4488   1        {
4489   2          ret_val = dq_otp_check_password(pwd_in);
4490   2          if (ret_val == 0)
4491   2          {
4492   3            //if not out 6 hour ,save pwd
4493   3            if (dq_otp_save_temp_pwd(pwd_in, OTP_PWD_TYPE_SIN) == 0) //, dq_otp_get_sin_pwd_endtime(dec_pwd, len));
4494   3              ret_val = 1;
4495   3            else
4496   3              ret_val = 5;
4497   3          }
4498   2        }
4499   1        return ret_val;
4500   1      }
*** WARNING C280 IN LINE 4477 OF mmi_src\dq_sdk_main.c: 'len': unreferenced local variable
4501          
4502          /*
4503          parameter: 
4504            current status machine
4505          return :
4506            none
4507          */
4508          unsigned char dq_otp_adjust_sys_time_verify(unsigned char *in_pwd, unsigned char len)
4509          {
4510   1        unsigned char dec_pwd_char[10];
4511   1        unsigned char vercode[2];
4512   1        unsigned short very_code, very_code2;
4513   1        //unsigned int time;
4514   1        //unsigned char ret_val;
4515   1      
4516   1        memset(dec_pwd_char, 0x00, sizeof(dec_pwd_char));
4517   1        //dq_otp_enc_pwd(in_pwd,8,otp_set_info.otp_sec_key,otp_set_info.otp_exg_key,dec_pwd_char);
4518   1      
4519   1        vercode[0] = in_pwd[8];
4520   1        vercode[1] = in_pwd[9];
4521   1      
4522   1        very_code = dq_sdk_CharToInt(vercode, 2);
4523   1      
4524   1        very_code2 = dq_otp_gen_random_key(in_pwd, 8, 100);
4525   1      
4526   1        if (very_code == very_code2)
4527   1        {
4528   2          //time = dq_sdk_CharToInt(dec_pwd_char, 8);
4529   2          //g_dq_otp_init.set_system_time(time*60,&ret_val);
4530   2      
4531   2          return 3;
4532   2        }
4533   1        return 0;
4534   1      }
*** WARNING C280 IN LINE 4508 OF mmi_src\dq_sdk_main.c: 'len': unreferenced local variable
4535          #if 0
              extern void mmi_dq_rtc_set_time_test(uint32_t year, uint32_t month, uint32_t day, uint32_t hour, uint32_t 
             -minute);
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 76  

              unsigned char dq_otp_adjust_sys_time_verify_for_test(unsigned char *in_pwd,unsigned char len)
              {
                unsigned char vercode[2];
                unsigned char year,month,day,hour,minute;
                unsigned char i;
                unsigned char pwd[11];
              
                dq_sdk_CharToHexByte(in_pwd, (char *)pwd, 10);
              
                for(i=0;i<len;i++)
                  NRF_LOG_PRINTF_DEBUG("dq_otp_adjust_sys_time_verify_for_test%d :%d\n",i,pwd[i]);
              
              
                vercode[0] = pwd[0];
                vercode[1] = pwd[1];
              
                year = dq_sdk_CharToInt(vercode,2);
              
                vercode[0] = pwd[2];
                vercode[1] = pwd[3];
                month = dq_sdk_CharToInt(vercode,2);
              
                vercode[0] = pwd[4];
                vercode[1] = pwd[5];
                day = dq_sdk_CharToInt(vercode,2);
              
                vercode[0] = pwd[6];
                vercode[1] = pwd[7];
                hour = dq_sdk_CharToInt(vercode,2); 
              
                vercode[0] = pwd[8];
                vercode[1] = pwd[9];
                minute = dq_sdk_CharToInt(vercode,2);
              
                NRF_LOG_PRINTF_DEBUG("dq_otp_adjust_sys_time_verify_for_test:%d %d %d %d %d\n",year,month, day, hour, min
             -ute );
                
                mmi_dq_rtc_set_time_test(year, month, day, hour, minute);
                return 3;
              }
              #endif
4577          /*
4578          parameter: 
4579            current status machine
4580          return :
4581            none
4582          */
4583          uint32_t dq_otp_get_lim_pwd_end_time(unsigned char *dec_pwd, unsigned char len)
4584          {
4585   1        unsigned int hour_time = 0;
4586   1        time_t pwd_time_sec = 0;
4587   1        time_t end_time_sec = 0;
4588   1        unsigned char time_y, time_m, time_h, time_d;
4589   1        unsigned int delay_time = 0;
4590   1        unsigned char i = 0;
4591   1        unsigned char time_buf[4];
4592   1      
4593   1        if (dec_pwd[0] > 5)
4594   1          return 0;
4595   1      
4596   1        hour_time = dq_otp_get_pwd_time_hour(dec_pwd, 5, 0);
4597   1      //  dq_otp_get_pwd_time_ymd(hour_time, &time_y, &time_m, &time_d, &time_h);
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 77  

4598   1        pwd_time_sec = dq_otp_get_pwd_time_sec(time_y, time_m, time_d, time_h);
4599   1      
4600   1        if (len == 8)
4601   1        {
4602   2          if (dec_pwd[5] <= 4) //T<= 20 day 0-499 hour
4603   2          {
4604   3            for (i = 0; i < 3; i++)
4605   3            {
4606   4              time_buf[i] = dec_pwd[5 + i];
4607   4            }
4608   3            delay_time = dq_sdk_CharToInt(time_buf, 3);
4609   3      
4610   3            end_time_sec = pwd_time_sec + delay_time * 3600;
4611   3          }
4612   2          else if ((dec_pwd[5] >= 5) && (dec_pwd[5] <= 8)) // 500-899 for day
4613   2          {
4614   3            for (i = 0; i < 3; i++)
4615   3            {
4616   4              time_buf[i] = dec_pwd[5 + i];
4617   4            }
4618   3            delay_time = dq_sdk_CharToInt(time_buf, 3);
4619   3            delay_time = (delay_time - 500) * 24;
4620   3      
4621   3            end_time_sec = pwd_time_sec + delay_time * 3600;
4622   3          }
4623   2          else if (dec_pwd[5] == 9) //900-999 for month
4624   2          {
4625   3            for (i = 0; i < 2; i++)
4626   3            {
4627   4              time_buf[i] = dec_pwd[6 + i];
4628   4            }
4629   3            delay_time = dq_sdk_CharToInt(time_buf, 2);
4630   3            time_y += (time_m + delay_time) / 12;
4631   3            time_m = (time_m + delay_time) % 12;
4632   3            end_time_sec = dq_otp_get_pwd_time_sec(time_y, time_m, time_d, time_h);
4633   3          }
4634   2        }
4635   1        else if (len == 9)
4636   1        {
4637   2          for (i = 0; i < 4; i++)
4638   2          {
4639   3            time_buf[i] = dec_pwd[5 + i];
4640   3          }
4641   2          delay_time = dq_sdk_CharToInt(time_buf, 4);
4642   2          end_time_sec = pwd_time_sec + delay_time * 3600;
4643   2        }
4644   1      
4645   1        return end_time_sec;
4646   1      }
4647          
4648          unsigned char dq_otp_check_lim_pwd_verify(unsigned char *dec_pwd, unsigned char *pwd_in, unsigned char len
             -)
4649          {
4650   1        unsigned char i = 0;
4651   1        unsigned char ret_val = 0, ret_code = 0;
4652   1        unsigned short sys_hour = 0;
4653   1        unsigned int hour_time = 0;
4654   1        unsigned char time_buf[4];
4655   1        unsigned int delay_time = 0;
4656   1        unsigned char time_y, time_m, time_h, time_d;
4657   1        time_t pwd_time_sec;
4658   1        time_t sys_time_sec;
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 78  

4659   1        time_t end_time_sec;
4660   1      
4661   1      //  NRF_LOG_PRINTF_DEBUG("dq_otp_check_lim_pwd_verify\n");
4662   1        if (dec_pwd[0] > 5)
4663   1          return 0;
4664   1      
4665   1        dq_otp_get_sys_time_hour(&sys_hour);
4666   1        hour_time = dq_otp_get_pwd_time_hour(dec_pwd, 5, 0);
4667   1        ret_val = dq_otp_check_password(pwd_in);
4668   1      
4669   1        //if(otp_set_info.otp_empty_hour != 0xFFFF&&hour_time < otp_set_info.otp_empty_hour)
4670   1        //  return 0;
4671   1      
4672   1        if (ret_val == 0) //not used
4673   1        {
4674   2          if ((sys_hour >= hour_time) && (sys_hour < hour_time + 24))
4675   2          {
4676   3            ret_code = 1;
4677   3          }
4678   2          else
4679   2          {
4680   3            return 0;
4681   3          }
4682   2        }
4683   1        memset(time_buf, 0x00, sizeof(time_buf));
4684   1        if (len == 8)
4685   1        {
4686   2          if (dec_pwd[5] <= 4) //T<= 20 day 0-499 hour
4687   2          {
4688   3            for (i = 0; i < 3; i++)
4689   3            {
4690   4              time_buf[i] = dec_pwd[5 + i];
4691   4            }
4692   3            delay_time = dq_sdk_CharToInt(time_buf, 3);
4693   3            if ((sys_hour >= hour_time) && (sys_hour <= (hour_time + delay_time)))
4694   3            {
4695   4              ret_code = 1;
4696   4            }
4697   3            else
4698   3            {
4699   4              ret_code = 0;
4700   4            }
4701   3          }
4702   2          else if ((dec_pwd[5] >= 5) && (dec_pwd[5] <= 8)) // 500-899 for day
4703   2          {
4704   3            for (i = 0; i < 3; i++)
4705   3            {
4706   4              time_buf[i] = dec_pwd[5 + i];
4707   4            }
4708   3            delay_time = dq_sdk_CharToInt(time_buf, 3);
4709   3            delay_time = (delay_time - 500) * 24;
4710   3            if ((sys_hour >= hour_time) && (sys_hour <= (hour_time + delay_time)))
4711   3            {
4712   4              ret_code = 1;
4713   4            }
4714   3            else
4715   3            {
4716   4              ret_code = 0;
4717   4            }
4718   3          }
4719   2          else if (dec_pwd[5] == 9) //900-999 for month
4720   2          {
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 79  

4721   3      //      dq_otp_get_pwd_time_ymd(hour_time, &time_y, &time_m, &time_d, &time_h);
4722   3            pwd_time_sec = dq_otp_get_pwd_time_sec(time_y, time_m, time_d, time_h);
4723   3      
4724   3            for (i = 0; i < 2; i++)
4725   3            {
4726   4              time_buf[i] = dec_pwd[6 + i];
4727   4            }
4728   3            delay_time = dq_sdk_CharToInt(time_buf, 2);
4729   3            time_y += (time_m + delay_time) / 12;
4730   3            time_m = (time_m + delay_time) % 12;
4731   3            end_time_sec = dq_otp_get_pwd_time_sec(time_y, time_m, time_d, time_h);
4732   3            sys_time_sec = dq_otp_get_sys_time_sec();
4733   3            if ((sys_time_sec >= pwd_time_sec) && (sys_time_sec <= end_time_sec))
4734   3              ret_code = 1;
4735   3            else
4736   3              ret_code = 0;
4737   3          }
4738   2        }
4739   1        else if (len == 9)
4740   1        {
4741   2          for (i = 0; i < 4; i++)
4742   2          {
4743   3            time_buf[i] = dec_pwd[5 + i];
4744   3          }
4745   2          delay_time = dq_sdk_CharToInt(time_buf, 4);
4746   2          if ((sys_hour >= hour_time) && (sys_hour <= hour_time + delay_time))
4747   2          {
4748   3            ret_code = 1;
4749   3          }
4750   2          else
4751   2          {
4752   3            ret_code = 0;
4753   3          }
4754   2        }
4755   1        if ((ret_val == 0) && (ret_code == 1))
4756   1        {
4757   2          //save pwd
4758   2          if (dq_otp_save_temp_pwd(pwd_in, OTP_PWD_TYPE_LIM) != 0) //, dq_otp_get_lim_pwd_end_time(dec_pwd, len));
4759   2            ret_code = 5;
4760   2        }
4761   1        return ret_code;
4762   1      }
4763          
4764          /*
4765          parameter: 
4766            current status machine
4767          return :
4768            none
4769          */
4770          unsigned char dq_otp_loop_pwd_check_week_verify(unsigned char loop_flag, unsigned char week_info)
4771          {
4772   1        if (loop_flag < 6) //week 1-6
4773   1        {
4774   2      
4775   2          if (loop_flag == (week_info - 1))
4776   2            return 1;
4777   2          else
4778   2            return 0;
4779   2        }
4780   1        else if (loop_flag == 0x06)
4781   1        {
4782   2          if (week_info == 0)
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 80  

4783   2            return 1;
4784   2          else
4785   2            return 0;
4786   2        }
4787   1        else if (loop_flag == 0x07) //work day,1-5
4788   1        {
4789   2          if ((week_info >= 1) && (week_info <= 5))
4790   2            return 1;
4791   2          else
4792   2            return 0;
4793   2        }
4794   1        else if (loop_flag == 0x08) //week end 6.7
4795   1        {
4796   2          if ((week_info == 6) || (week_info == 0))
4797   2            return 1;
4798   2          else
4799   2            return 0;
4800   2        }
4801   1        else if (loop_flag == 0x09) //every day
4802   1        {
4803   2          if (week_info <= 6)
4804   2            return 1;
4805   2          else
4806   2            return 0;
4807   2        }
4808   1        return 1;
4809   1      }
4810          /*
4811          parameter: 
4812            current status machine
4813          return :
4814            none
4815          */
4816          unsigned char dq_otp_check_loop_pwd_verify(unsigned char *dec_pwd, unsigned char *pwd_in, unsigned char le
             -n)
4817          {
4818   1        unsigned char loop_val[2];
4819   1        unsigned char ret_val = 0;
4820   1        //  unsigned int  delay_time;
4821   1        unsigned char week;
4822   1        unsigned char end_time = 0;
4823   1        unsigned char week_info = dec_pwd[8];
4824   1        unsigned short sys_hour = 0;
4825   1        unsigned short sys_hour2 = 0;
4826   1        unsigned short pwd_hour = dq_otp_get_pwd_time_hour(dec_pwd, 5, 1);
4827   1        unsigned short pwd_hour2 = 0;
4828   1        uint32_t pwd_sec = 0;
4829   1        unsigned char new_pwd_flag = 0;
4830   1      
4831   1      //  NRF_LOG_PRINTF_DEBUG("dq_otp_check_loop_pwd_verify\n");
4832   1      
4833   1        if (dec_pwd[0] != 0x06)
4834   1          return 0;
4835   1      
4836   1        //if(otp_set_info.otp_empty_hour != 0xFFFF&&pwd_hour < otp_set_info.otp_empty_hour)
4837   1        //  return 0;
4838   1      
4839   1        memset(loop_val, 0x00, sizeof(loop_val));
4840   1      
4841   1        loop_val[0] = dec_pwd[6];
4842   1        loop_val[1] = dec_pwd[7];
4843   1      
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 81  

4844   1        end_time = dq_sdk_CharToInt(loop_val, 2);
4845   1        ret_val = dq_otp_check_password(pwd_in);
4846   1        if (ret_val == 0)
4847   1        {
4848   2          ret_val = dq_otp_get_sys_time_hour(&sys_hour);
4849   2          if (ret_val == 1)
4850   2          {
4851   3            if ((sys_hour >= pwd_hour) && (sys_hour < (pwd_hour + 24)))
4852   3            {
4853   4              ret_val = 1;
4854   4            }
4855   3            else
4856   3              ret_val = 0;
4857   3          }
4858   2          if (ret_val == 1)
4859   2            new_pwd_flag = 1;
4860   2        }
4861   1        else
4862   1          ret_val = dq_otp_get_sys_time_hour(&sys_hour);
4863   1      
4864   1        if (ret_val == 1)
4865   1        {
4866   2          pwd_sec = (pwd_hour * 3600 + otp_set_info.otp_start_hour);
4867   2          g_dq_otp_init.time_zone_pro(&pwd_sec);
4868   2          pwd_hour2 = (pwd_sec / 3600) % 24;
4869   2          dq_otp_get_local_sys_time_hour(&sys_hour2);
4870   2      //    NRF_LOG_PRINTF_DEBUG("dq_otp_check_loop_pwd_verify pwd_hour2 %d  ; sys_hour2 %d ;   end_time %d\n", pw
             -d_hour2, sys_hour2, end_time);
4871   2          if ((sys_hour2 >= pwd_hour2) && (sys_hour2 <= end_time))
4872   2          {
4873   3            // week = dq_otp_get_sys_local_time_week();
4874   3            // NRF_LOG_PRINTF_DEBUG("dq_otp_check_loop_pwd_verify week %d\n", week);
4875   3      
4876   3            ret_val = dq_otp_loop_pwd_check_week_verify(week_info, week);
4877   3          }
4878   2          else
4879   2            ret_val = 0;
4880   2        }
4881   1        if ((new_pwd_flag == 1) && (ret_val == 1))
4882   1        {
4883   2          //save the passowrd
4884   2          if (dq_otp_save_temp_pwd(pwd_in, OTP_PWD_TYPE_LOOP) != OTP_BASE_SUCESS)
4885   2            ret_val = 5;
4886   2        }
4887   1        return ret_val;
4888   1      }
*** WARNING C280 IN LINE 4816 OF mmi_src\dq_sdk_main.c: 'len': unreferenced local variable
4889          /*
4890          Function:check the password user input right or not
4891          parameter: 
4892            pwd_in: the password user input
4893          return :
4894            if the password can be verify,return OTP_BASE_SUCESS
4895            if the password can't be verify,return OTP_BASE_PWD_NOT_FOUND
4896          */
4897          uint8_t dq_otp_temp_pwd_check(unsigned char *pwd_in, unsigned char len)
4898          {
4899   1        unsigned char hex_pwd_char[15];
4900   1        unsigned char dec_pwd_char[15];
4901   1        unsigned char sec_pwd_char[10];
4902   1        unsigned char ret_val = 0;
4903   1        unsigned char i = 0;
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 82  

4904   1      
4905   1        memset(hex_pwd_char, 0x00, sizeof(hex_pwd_char));
4906   1        memset(dec_pwd_char, 0x00, sizeof(dec_pwd_char));
4907   1        memset(sec_pwd_char, 0x00, sizeof(sec_pwd_char));
4908   1      
4909   1        if ((len == 8) || (len == 9))
4910   1        {
4911   2          //dq_sdk_HexCharToByte((const char *)pwd_in,(unsigned char *)hex_pwd_char,len);
4912   2          if (len == 8)
4913   2            dq_otp_enc_pwd(pwd_in, len, otp_set_info.otp_sec_key_8, otp_set_info.otp_exg_key_8, dec_pwd_char);
4914   2          else if (len == 9)
4915   2            dq_otp_enc_pwd(pwd_in, len, otp_set_info.otp_sec_key_9, otp_set_info.otp_exg_key_9, dec_pwd_char);
4916   2          // else if (len == 10)
4917   2          //  dq_otp_enc_pwd(pwd_in, len, otp_set_info.otp_sec_key_10, otp_set_info.otp_exg_key_10, dec_pwd_char);
4918   2      
4919   2          for (i = 0; i < len; i++)
4920   2          {
4921   3      //      NRF_LOG_PRINTF_DEBUG("dq_otp_temp_pwd_check [%d]=  %d\n", i, dec_pwd_char[i]);
4922   3          }
4923   2      
4924   2          if (dec_pwd_char[0] <= 5)
4925   2          {
4926   3            ret_val = dq_otp_check_lim_pwd_verify(dec_pwd_char, pwd_in, len);
4927   3          }
4928   2          else if (dec_pwd_char[0] == 6)
4929   2          {
4930   3            ret_val = dq_otp_check_loop_pwd_verify(dec_pwd_char, pwd_in, len);
4931   3          }
4932   2          else if (dec_pwd_char[0] == 7)
4933   2          {
4934   3            ret_val = dq_otp_check_empty_pwd_verify(dec_pwd_char, len);
4935   3          }
4936   2          else if (dec_pwd_char[0] == 8)
4937   2          {
4938   3            ret_val = dq_otp_check_sin_pwd_verify(dec_pwd_char, pwd_in, len);
4939   3          }
4940   2          else if (dec_pwd_char[0] == 9)
4941   2          {
4942   3            ret_val = dq_otp_check_per_pwd_verify(dec_pwd_char, pwd_in, len);
4943   3          }
4944   2        }
4945   1      #if 0
                else if(len == 10)//adjust system time
                {
              #if 1
                  ret_val = dq_otp_adjust_sys_time_verify(pwd_in,len);
              #else
                  
                  ret_val = dq_otp_adjust_sys_time_verify_for_test(pwd_in,len);
              #endif
                }
              #endif
4956   1      #if 0
                if(ret_val == 1)
                  return OTP_BASE_SUCESS;
                else
                  return OTP_BASE_NOT_PAIR;
              #else
4962   1        return ret_val;
4963   1      #endif
4964   1      }
4965          
C51 COMPILER V9.59.0.0   DQ_SDK_MAIN                                                       04/28/2021 17:32:28 PAGE 83  

4966          /*
4967          parameter: 
4968            current status machine
4969          return :
4970            none
4971          */
4972          #if 0
              //unsigned char user_input_pwd[] = {0x06,0x06,0x07,0x03,0x08,0x08,0x02,0x02};//66738822--01721940
              //unsigned char user_input_pwd[] = {0x06,0x04,0x07,0x02,0x03,0x00,0x06,0x05,0x03};//647230653--017228761
              //unsigned char user_input_pwd[] = {0x06,0x07,0x03,0x03,0x09,0x05,0x01,0x03};//67339513--01721051
              //unsigned char user_input_pwd[] = {0x07,0x05,0x04,0x07,0x07,0x04,0x06,0x08,0x01};//754774681--601721189
              //unsigned char user_input_pwd[] = {0x05,0x04,0x09,0x09,0x01,0x03,0x03,0x02};//54991332--70172170
              //unsigned char user_input_pwd[] = {0x08,0x05,0x03,0x02,0x08,0x01,0x03,0x04};//85328134--
              //unsigned char user_input_pwd[] = {0x6,0x5,0x01,0x07,0x01,0x05,0x06,0x07};//65171567--01724023
              unsigned char user_input_pwd[] = {0x2,0x1,0x8,0x3,0x1,0x3,0x1,0x8,0x5};//218313185--
              unsigned char temp_exg_key_8[] = {0x43,0x26,0x71,0x58};
              unsigned char temp_sec_key_8[] = {0x50,0x72,0x29,0x98};
              unsigned char temp_exg_key_9[] = {0x93,0x42,0x67,0x15,0x8F}; 
              unsigned char temp_sec_key_9[] = {0x15,0x02,0x23,0x28,0x6F};
              int main(void)
              {
                unsigned char sec_pwd[9];
                unsigned char pwd_ret =0;
                unsigned short pwd_short_ret = 0;
                unsigned char pwd_len = 9;
                memset(sec_pwd,0xFF,sizeof(sec_pwd));
                memset(otp_set_info.otp_exg_key,0x00,sizeof(otp_set_info.otp_exg_key));
                memset(otp_set_info.otp_sec_key,0x00,sizeof(otp_set_info.otp_sec_key));
                if(pwd_len == 8)
                {
                  memcpy(otp_set_info.otp_sec_key,temp_sec_key_8,4);
                  memcpy(otp_set_info.otp_exg_key,temp_exg_key_8,4);
                }
                else if(pwd_len == 9)
                {
                  memcpy(otp_set_info.otp_sec_key,temp_sec_key_9,5);
                  memcpy(otp_set_info.otp_exg_key,temp_exg_key_9,5);
                }
              
                dq_otp_pwd_check(user_input_pwd,pwd_len);
              }
              #endif
5008          
5009          #endif //__LOCK_VIRTUAL_PASSWORD__
5010          #endif //__DQ_SDK_MAIN_C__


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  22983    ----
   CONSTANT SIZE    =     28    ----
   XDATA SIZE       =   3283    1083
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  22 WARNING(S),  0 ERROR(S)
